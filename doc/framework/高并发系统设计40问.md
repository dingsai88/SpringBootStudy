



01 | 高并发系统：它的通用设计方法是什么？


高并发处理的三种方法:
1.横向：多台服务器承担并发和流量 单核cpu变多核 Scale-up(CPU提升性能) Scale-out低性能机器处理
2.缓存：使用缓存来提高系统的性能  内存比硬盘快
3.异步：削峰填谷 12306排队


02 | 架构分层：我们为什么一定要这么做？

架构分层 
MVC、OSI 网络模型
优点:专注自己层、复用



03 | 系统设计目标（一）：如何提升系统性能？


三大目标：高性能、高可用、可扩展


性能的度量指标：
平均值：所有请求的响应时间数据相加，再除以总请求数： 作为一个参考
最大值：
分位值:



吞吐量：每秒钟请求的数量
响应时间：接口响应时间




高并发下的性能优化
1. 提高系统的处理核心数 （提高吞吐量，但是有机器上限）

2. 减少单次任务响应时间
CPU核数：CPU核数+1
IO密集:1+(IO耗时/CPU耗时)



发现这类性能瓶颈的手段主要有两类。
第一类是采用工具
网络协议栈、网卡、磁盘、文件系统、内存，等等

第二类
通过监控来发现性能问题

系统瓶颈: 数据库、网络、算法

总结:
数据优先，你做一个新的系统在上线之前一定要把性能监控系统做好；
掌握一些性能优化工具和方法，这就需要在工作中不断地积累；
计算机基础知识很重要，比如说网络知识、操作系统知识等等，掌握了基础知识才能让你在优化过程中抓住性能问题的关键，也能在性能优化过程中游刃有余。




04 | 系统设计目标（二）：系统怎样做到高可用？





可用性的度量=可用时间/(可用+失败)
MTBF（Mean Time Between Failure）是平均故障间隔
MTTR（Mean Time To Repair）表示故障的平均恢复时间


高可用系统设计的思路

1. 系统设计
failover（故障转移):平级故障转移和主备故障转移
超时控制：设置超时时间
降级和限流:
 
转移规则:
客户端定时向主备发心跳检测
选主:多个备份点达成一致 需要分布式一致性算法

CAP Consistency 一致性
数据一致性模型：
强一致性:用户写什么下次读取的就是什么
弱一致性：不保证能读取到最新的
最终一致性：是弱一致性的一种特例。

分布式一致性算法：2PC、3pc、paxos



两阶段提交:
1.程序调用各个数据库进行事务操作 2.都执行没问题了
第一阶段提交:3.程序>各个资源管理器(库)要执行-预提交>告诉事务管理器已经prpare
第二阶段提交:4.事务管理器(收到各个子节点)>告诉各个资源管理器执行rollback还是commit;

管理者单点、同步阻塞、数据不一致性最后管理者通知commit；


三阶段提交:
第一阶段：预询盘管理者询问是否可以执行CanCommit
第二阶段：预提交 PreCommit
第三阶段：事务提交DoCommit

3PC 和2PC区别
1.准备阶段一分为二 
2.引入超时机制

Paxos 帕克斯OS:  对比2PC 3PC没有协调者管理者
提议者、Acceptor批准者、学习者
1.提议者发起选主提议   批准者第一个必须同意，后期只同意更大的。
2.半数以上统一以后 广播结果




降级和限流:
降级:保核心业务非核心不保
    抛异常、返回NULL、调用Mock数据、调用Fallback处理逻辑

限流:超出请求返回错误





2. 系统运维
灰度发布:90%的错误发生在上线变更事情
故障演练:线上随机关闭机器；未成形之前 线下部署一样的环境演练








05 | 系统设计目标（三）：如何让系统易于扩展？
无状态的服务和组件更易于扩展
MySQL 这种存储服务是有状态的，就比较难以扩展


数据库、缓存、依赖的第三方、负载均衡、交换机带宽等等

拆分


1.通用：高性能、高可用、易拓展




I.数据库篇

07 | 池化技术：如何减少频繁创建数据库连接的性能损耗？
08 | 数据库优化方案（一）：查询请求增加时，如何做主从分离？
主库挂3-5个从库
binlog同步慢的解决方案
1.把数据同时放到消息队列
2.把数据同事放到内存数据库中
3.查询主库
TDDL cobar mycat shardingjdbc


09 | 数据库优化方案（二）：写入数据量增加时，如何实现分库分表？
分库分表
分库：用户库  商品库

分表：区间拆分、hash拆分

count 统一到 redis

10 | 发号器：如何保证分库分表后ID的全局唯一性？
单表 建议自增ID
UUID不建议
snowflake雪花 时间戳+机器ID+进程ID+业务ID +



11 | NoSQL：在高并发场景下，数据库和NoSQL如何做到互补？

redis
habse 列式存储 https://blog.csdn.net/zl1zl2zl3/article/details/86632044
mongodb 无结构 副本集高级主从、分片



I.缓存
静态缓存、分布式缓存、热点本地缓存


13 | 缓存的使用姿势（一）：如何选择缓存的读写策略？
cache aside 旁路缓存(写完删除缓存):1.更新时删除缓存2.再读取命中就缓存

命中率严格，那就加入分布式锁更新缓存

读穿、写穿透(read write through):新操作缓存，再更新数据库


14 | 缓存的使用姿势（二）：缓存如何做到高可用？
缓存命中率
分布式缓存高可用方案：
客户端方案:客户端分片
中间代理层:中间件分片
服务端方案：服务端字段redis 哨兵

一致性hash算法解决了增加删除节点，命中率下降的问题

15 | 缓存的使用姿势（三）：缓存穿透了怎么办？

缓存穿透以后
1.缓存空值类
2.布隆过滤器：判断一个值是否在集合里（集合区hashID，新值区hashid对比）




 CDN：静态资源如何加速？
请求离你最近的节点






I.消息队列
17 | 消息队列：秒杀时如何处理每秒上万次的下单请求？

CDN、通用户IP设备重复丢弃
消息队列削峰填谷

18 | 消息投递：如何保证消息仅仅被消费一次？
接口幂等（唯一ID）
1.生产端：一样的消息丢弃
2.消费端：一样的ID直接返回（可加版本号）


23 | RPC框架：10万QPS下如何实现毫秒级的服务调用？
RPC远程过程调用（webservice、dubbo）：网络性能+序列化
网络传输性能:阻塞、非阻塞、IO多路、异步、信号驱动
序列化：json等


25 _ 分布式Trace：横跨几十个分布式组件的慢请求要如何排查？
traceid 或者requestID
面向切面
静态代理:编译器植入aspectj
动态代理:不影响class

设计要点：1代码无入侵：2.不影响性能

27 _ API网关：系统的门面要如何做呢？
入口网关
出口网关
认证、授权、限流熔断

28 _ 多机房部署：跨地域的分布式系统如何做？
同城双活
异地多活：肯定有延迟  数据库同步、消息队列同步

30 _ 给系统加上眼睛：服务端监控要怎么做？


日志》收集工具》消息队列》elaticsearch>kibanna


35 _ 流量控制：高并发系统中我们如何操纵流量？
限流算法：
1.漏桶算法：入口宽，出口按照速率出（当大于漏桶时就丢弃）。
2.令牌桶算法：每隔1/N时间往桶里放一个令牌















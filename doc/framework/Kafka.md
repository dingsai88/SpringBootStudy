



**I.Kafka核心技术与实战（HTML版 -完结）**

**根据维基百科的定义:**
消息引擎系统是一组规范。企业利用这组规范在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递。



**II.重要模块**
消息传输的对象+消息传递模型

**III.消息引擎传输的对象是消息:纯二进制的字节序列**

**III.如何传输消息:两种消息引擎模型**

**1.点对点模型(消息队列模型)**(电话客服)
A 发送的消息只能被系统 B 接收

**2.发布 / 订阅模型**(报纸订阅)
它有一个主题（Topic）的概念
发布者（Publisher）
订阅者（Subscriber）

多个发布者可以向一个Topic发送消息
一个Topic可以被多个订阅者消费

**消息引擎系统和JMS(java message service)关系**
JMS 接口规范

**主要作用削峰填谷**
上游大流量有两种处理方式:
1.上游限流:影响上游的TPS 
2.消息队列:解决上下游系统 TPS 的错配


Apache Kafka 是一款开源的消息引擎系统:(忽视了这类系统引以为豪的消息传递属性)


Kafka 的选择：它使用的是纯二进制的字节序列。当然消息还是结构化的，只是在使用之前都要将其转换成二进制的字节序列。






**02 | 一篇文章带你快速搞定Kafka术语** 


**II.Clients客户端**生产者+消费者
生产者和消费者统称为客户端（Clients）。


Producer> 发送Topic >Consumer


**II.服务器端**多个Broker经纪人
Broker 负责接收和处理客户端发送过来的请求，以及对消息进行持久化

**III.高可用:** Broker运行在多台;副本的备份机制
1.Broker 分散运行在不同的机器上，一个挂了其他的可用
2.备份机制（Replication） ：相同的数据拷贝到多台机器上，而这些相同的数据拷贝在 Kafka 中被称为副本（Replica）。
副本的数量是可以配置的，这些副本保存着相同的数据，但却有不同的角色和作用。

**Kafka 定义了两类副本：**
领导者副本（Leader Replica）:与客户端程序进行交互
追随者副本（Follower Replica）:被动地追随领导者副本而已，不能与外界进行交互

MySQL 的从库是可以处理读操作的，但是在 Kafka 中追随者副本不会对外提供服务。

**Master-Slave>Leader-Follower**

**副本工作机制:**
领导者副本:1.生产者总是向领导者副本写消息；2.消费者总是从领导者副本读消息。
追随者副本:向领导者副本发送请求，请求领导者把最新生产的消息发给它，这样它能保持与领导者的同步。 


**III.高性能:**
伸缩性即所谓的 Scalability
单台 Broker 机器都无法容纳

**分区（Partitioning）：** 分片、分区
把数据分割成多份保存在不同的 Broker 上。

Kafka 中的分区机制指的是将每个topic主题划分成多个分区（Partition），
0,1平均分区
hash平均分区等


**副本和分区**
副本是在分区这个层级定义的

0分区:1个领导者副本+N个追随者副本
1分区:1个领导者副本+N个追随者副本

**位移（Offset）** (分区内的消息位置，它是不变的)
生产者向分区写入消息，每条消息在分区中的位置信息由一个叫位移（Offset）的数据来表征。
分区位移总是从 0 开始，假设一个生产者向一个空分区写入了 10 条消息，那么这 10 条消息的位移依次是 0、1、2、…、9。



**II.持久化** 一个log物理文件有多个日志段

Kafka 使用消息日志（Log）来保存数据
一个日志就是磁盘上一个只能追加写（Append-only）消息的物理文件。
因为只能追加写入，故避免了缓慢的随机 I/O 操作，改为性能较好的顺序 I/O 写操作，这也是实现 Kafka 高吞吐量特性的一个重要手段


**III.日志段（Log Segment）机制:**
日志分成多个日志段，消息被追加写到当前最新的日志段中，当写满了一个日志段后，Kafka 会自动切分出一个新的日志段，并将老的日志段封存起来。
Kafka 在后台还有定时任务会定期地检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。


**III.Consumer Group:消费者组**
多个消费者实例共同组成一个组来消费一组主题。

**每个分区**都只会被组内的一个消费者实例消费，其他消费者实例不能消费它

提升消费者端的吞吐量
消费者实例（Consumer Instance）:可以是运行消费者应用的进程，也可以是一个线程

“重平衡”（Rebalance）
组内某个实例挂掉了，Kafka 能够自动检测到，然后把这个 Failed 实例之前负责的分区转移给其他活着的消费者

**消费者位移（Consumer Offset）:**
字段记录它当前消费到了分区的哪个位置上。

每个消费者有着自己的消费者位移

**两个位移的区别**
上文的位移是写入时，在组内的相对位置：
消费者位移，是每个消费者记录的消费位置

II.名词


• 消息：Record。Kafka 是消息引擎嘛，这里的消息就是指 Kafka 处理的主要对象。
• 主题：Topic。主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。
• 分区：Partition。一个有序不变的消息序列。每个主题下可以有多个分区。
• 消息位移：Offset。表示分区中每条消息的位置信息，是一个单调递增且不变的值。
• 副本：Replica。Kafka 中同一条消息能够被拷贝到多个地方以提供数据冗余，这些地方就是所谓的副本。副本还分为领导者副本和追随者副本，各自有不同的角色划分。副本是在分区层级下的，即每个分区可配置多个副本实现高可用。
• 生产者：Producer。向主题发布新消息的应用程序。
• 消费者：Consumer。从主题订阅新消息的应用程序。
• 消费者位移：Consumer Offset。表征消费者消费进度，每个消费者都有自己的消费者位移。
• 消费者组：Consumer Group。多个消费者实例共同组成的一个组，同时消费多个分区以实现高吞吐。
• 重平衡：Rebalance。消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance 是 Kafka 消费者端实现高可用的重要手段。





![RUNOOB 图标](https://github.com/dingsai88/SpringBootStudy/blob/master/img/生产者-消费者组-leaderFollower.png)



I.阿里人现身说法：最全面的分布式事务解决方案，全面剖析阿里面试套路。
https://www.bilibili.com/video/BV1Mh411R7nJ?from=search&seid=15576250487038114377


https://www.bilibili.com/video/BV1FJ411A7mV?p=2

讲清楚分布式事务选型：XA、2PC、TCC、Saga、阿里Seata 
1.分布式事务不能100%解决数据不一致。
2.如果数据不一致-用人工或者脚本进行补偿

**I.理论：**

**II.2PC：**


每个事务都预提交到-事务协调器

事务协调器-通知各个业务是否要提交。

1.（ a perCommit、b perCommit）事务协调器:没有超时一直等待
2. 事务协调器返回都提交，还是都回滚  :没有超时一直等待




问题：
1.效率低
2.资源占用大
3.不能完全保证事务


**II.3PC 实现比较少**


1.（ a canCommit、b canCommit）事务协调器   :相比perCommit canCommit不占用资源
2.（ a perCommit、b perCommit）事务协调器   :相比 2PC  带有超时机制，超时了回滚
2. 事务协调器返回都提交，还是都回滚           :相比2PC  如果事务协调器超时了，默认是提交的。





**TCC（try confirm cancel）**


try{
直接落库  insert数据
update sss a=a+10;

不能保证在一个事务里
mysql;
redis;
写文件;

}

confirm{
业务代码、或者空、或者做一些事。

}

cancel{
如果try 有一个失败，那就 delete
update sss a=a-10;
}

cancel 是 try的逆SQL



**LCN (Lock confirm notify)**
MQ消息事务



**阿里巴巴分布式事务框架：Seata**
https://seata.io/zh-cn/
https://github.com/seata/seata/issues/1246


最新精讲【Spring底层源码全集解析】全网唯一P8级架构师教程
https://www.bilibili.com/video/BV1mZ4y1378K

来自阿里、京东、百度、美团、顺丰的并发编程面试真题，让你自由发挥，你能讲多深？
https://www.bilibili.com/video/BV1aV41167s4

清华马士兵：横扫一切关于Redis的问题，吊打所有敢于提问Redis问题的面试官
https://www.bilibili.com/video/BV13z411b7mU

慎入！马士兵教育价值3W架构师视频教程：
透彻讲解Alibaba Java岗需要掌握的
JVM、多线程并发、Spring源码、Redis、Mysql、算法等技术栈
https://www.bilibili.com/video/BV1Da411c7Lx










**【黑马】分布式事务解决方案专题**

https://www.bilibili.com/video/BV1FJ411A7mV?p=4

**CAP理论**
CAP是 Consistency、Availability、Partition tolerance三个词语的缩写，分别表示一致性、可用性、分区容忍性



C - Consistency 一致性：读取到最新的数
一致性是指写操作后的读操作可以读取到最新的数据状态，当数据分布在多个节点上，从任意结点读取到的数据都 是最新的状态

要么不响应，要么响应最新的数据


A - Availability 可用性：得到响应结果
可用性是指任何事务操作都可以得到响应结果，且不会出现响应超时或响应错误。

可以返回旧数据，不能不返回。


P - Partition tolerance 分区容忍性： 主从不通信-也能正常对外提供服务
通常分布式系统的各各结点部署在不同的子网，这就是网络分区，不可避免的会出现由于网络问题而导致结点之间 通信失败，此时仍可对外提供服务，这叫分区容忍性。

1、主数据库向从数据库同步数据失败不影响读写操作。
2、其一个结点挂掉不影响另一个结点对外提供服务。




**CAP组合方式**  AP最常见，不给最新数据
保证P和A，舍弃C强一致，保证最终一致性。

1）AP： 可能读取到老数据，一会才能读取到新数据。
放弃一致性，追求分区容忍性和可用性。这是很多分布式系统设计时的选择。

订单退款等。
上边的商品管理，完全可以实现AP，前提是只要用户可以接受所查询的到数据在一定时间内不是最新的即可。
通常实现AP都会保证最终一致性，后面讲的BASE理论就是根据AP来扩展的，一些业务场景 比如：订单退款，今
日退款成功，明日账户到账，只要用户可以接受在一定时间内到账即可。




2）CP： 转账，操作
放弃可用性，追求一致性和分区容错性，我们的zookeeper其实就是追求的强一致，又比如跨行转账，一次转账请
求要等待双方银行系统都完成整个事务才算完成。

zookeeper 就是CP 



3）CA：
放弃分区容忍性，即不进行分区，不考虑由于网络不通或结点挂掉的问题，则可以实现一致性和可用性。那么系统
将不是一个标准的分布式系统，我们最常用的关系型数据就满足了CA。

主数据库和从数据库中间不再进行数据同步，数据库可以响应每次的查询请求，通过事务隔离级别实现每个查询请
求都可以返回最新的数据。



**BASE理论**基本可用、软状态、最终一致性
Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩



BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性，
当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态

柔性事务

**Basically Available(基本可用) :**
分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用

电商交易系统出问题，电商商品还可以正常浏览

**Soft state(软状态):**
:由于不要求强一致性，所以BASE允许系统中存在中间状态（也叫软状态），这个状态不影响系统可用

性，如订单的"支付中"、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态。

**Eventually consistent (最终一致性):**
:最终一致是指经过一段时间后，所有节点数据都将会达到一致。

如订单的"支付中"状态，最终会变为“支付成功”或者"支付失败"，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待。



---------------------------------------记录理论完成-- 2PC实现开始 - XA---------------------------------------------------------


**I。2PC实现**

mysql oracle

**I.成功的2PC**
II.第一阶段
1.事务管理器TM >发送给各个资源节点 Prepare指令
2.执行各自的事务，并不真正提交
3.资源节点> 事务管理器TM OK 

II.第二阶段 
1.事务管理器TM >发送给各个资源节点 Commit指令
2.各个资源节点都commit

**I.成功的2PC**
II.第一阶段
1.事务管理器TM >发送给各个资源节点 Prepare指令
2.执行各自的事务，并不真正提交
3.资源节点> 事务管理器TM  error失败

II.第二阶段
1.事务管理器TM >发送给各个资源节点 Rollback指令
2.预提交成功的节点 rollback.



**I。2PC实现-解决方案-XA方案**
应用程序AP 和 事务管理器TM 之间的通信协议叫 XA


国际开放标准组织Open Group定义了分布式事务处理模型
DTP（Distributed Transaction Processing Reference Model）。


DTP模型定义TM和RM之间通讯的接口规范叫XA，简单理解为数据库提供的2PC接口协议，
基于数据库的XA协议来实现2PC又称为XA方案。


**DTP模型定义如下角色**

**AP(Application Program)：** 程序
即应用程序，可以理解为使用DTP分布式事务的程序。


**RM(Resource Manager)：**  数据库
即资源管理器，可以理解为事务的参与者，一般情况下是指一个数据库实例，通过
资源管理器对该数据库进行控制，资源管理器控制着分支事务。


**TM(Transaction Manager)：**  分布式事务管理器
事务管理器，负责协调和管理事务，事务管理器控制着全局事务，管理事务生命
周期，并协调各个RM。全局事务是指分布式事务处理环境中，需要操作多个数据库共同完成一个工作，这个工作即是一个全局事务。


DTP模型定义TM和RM之间通讯的接口规范叫XA，简单理解为数据库提供的2PC接口协议，
基于数据库的XA协议来实现2PC又称为XA方案。


执行流程如下：
1、应用程序（AP）持有用户库和积分库两个数据源。
2、应用程序（AP）通过TM通知用户库RM新增用户，同时通知积分库RM为该用户新增积分，RM此时并未提交事
务，此时用户和积分资源锁定。
3、TM收到执行回复，只要有一方失败则分别向其他RM发起回滚事务，回滚完毕，资源锁释放。
4、TM收到执行回复，全部成功，此时向所有RM发起提交事务，提交完毕，资源锁释放。



**XA方案的问题：**
1、需要本地数据库支持XA协议。
2、资源锁需要等到两个阶段结束才释放，性能较差。










---------------------------------Seata方案---------------------------------------------------
是开源的分布式事务框架


Seata的设计目标其一是对业务无侵入，因此从业务无侵入的2PC方案着手，在传统2PC的基础上演进，并解决 2PC方案面临的问题。


**Transaction Coordinator (TC)：** 事务协调器--独立部署
事务协调器，它是独立的中间件，需要独立部署运行，它维护全局事务的运行状态，接收TM指令发起全局事务的提交与回滚，负责与RM通信协调各各分支事务的提交或回滚。



**Transaction Manager (TM)：** 事务管理器--JAR包嵌入到程序
事务管理器，TM需要嵌入应用程序中工作，它负责开启一个全局事务，并最终 向TC发起全局提交或全局回滚的指令。


**Resource Manager (RM)：** 控制分支事务---数据库实例
控制分支事务，负责分支注册、状态汇报，并接收事务协调器TC的指令，驱动分支（本地）事务的提交和回滚。




具体的执行流程如下：
1. 用户服务的 TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID。
2. 用户服务的 RM 向 TC 注册 分支事务，该分支事务在用户服务执行新增用户逻辑，并将其纳入 XID 对应全局
   事务的管辖。
3. 用户服务执行分支事务，向用户表插入一条记录。
4. 逻辑执行到远程调用积分服务时(XID 在微服务调用链路的上下文中传播)。积分服务的RM 向 TC 注册分支事
   务，该分支事务执行增加积分的逻辑，并将其纳入 XID 对应全局事务的管辖。
5. 积分服务执行分支事务，向积分记录表插入一条记录，执行完毕后，返回用户服务。
6. 用户服务分支事务执行完毕。
7. TM 向 TC 发起针对 XID 的全局提交或回滚决议。
8. TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。





seata服务端(TC)：seata-server-0.7.1

seata客户端（RM、TM）：spring-cloud-alibaba-seata-2.1.0.RELEASE





注册中心 :discover-server

两个应用程序:dtx-seata-demo


I.启动开始

1.事务协调器 TC  端口:8888   jar包不用开发
下载地址：
https://github.com/seata/seata/releases/download/v0.7.1/seata-server-0.7.1.zip
 
cd C:\Work\Project\FenBuShi\seata-server-0.7.1\bin
seata-server.bat -p 8888 -m file



2.启动类似zk eureka 我找到了  项目 discoverserver 端口:56080
cn.itcast.dtx.discoverserver.DiscoveryServer
C:\Work\Project\FenBuShi\day1\代码\dtx\discover-server


3.
springboot1启动 端口:56081 
cn.itcast.dtx.seatademo.bank1.Bank1Server

http://127.0.0.1:56081/bank1/transfer?amount=5

C:\Work\Project\FenBuShi\day1\代码\dtx\dtx-seata-demo

springboot2启动 端口:56082
cn.itcast.dtx.seatademo.bank2.Bank2Server

127.0.0.1:56082/bank2/transfer?amount=5

C:\Work\Project\FenBuShi\day1\代码\dtx\dtx-seata-demo


4.测试调用
http://127.0.0.1:56081/bank1/transfer?amount=5




第一章绪论
1.1 数据结构的定义、抽象数据型、算法分析
学习路线:高等数学>计算机导论>离散数学>程序设计>数据结构>计算机原理>数据库原理



数据:一切能输入到计算机中并且能被识别和处理的符号集合
数值数据:整数、实数等

   
整数、实数等
非数值数据：图形、图象、声音 、文字等




数据元素：数据的基本单位，在计算机程序中通常作为一个整体进行考 虑和处理。

数据项：构成数据元素 的不可分 割的最 小单位。


数据对象：具有相同性质的数据  元素 的集合。


结点 ：数据  元素 在计算机内的位串 表示。




数据结构:


数据的逻辑结构
数据的物理结构(存储结构)



算法（Algorithm）:是对特定问题求解步骤的一种描述，是指令的有限序列。


输入：一个算法有零个或多个输入。
输出：一个算法有一个或多个输出。
有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成。
确定性：算法中的每一条指令必须有确切的含义，对于相同的输入只能得到相同的输出。
可行性：算法描述的操作可以通过已经实现的基本操作执行有限次来实现。


欧几里德算法，最大公约数(12和16最大公约数4)



算法分析

时间复杂度(Time Complexity)
空间复杂度(Space Complexity)
O(1)<O(log2N)<O(n)<(Nlog2N)<O(N2)<O(N3)



程序设计的方法:
1.模型化(建模)
2.确定算法
3.逐步求精
4.ADT abstract data type(选用适当的数据结构)




AB AC AD
BA BC BD
DA DB DC
EA EB EC ED

1.穷举法
2.试探法
3.贪心法


1.数据结构简介
2.线性表(1v1)

栈 队列

线性表的逻辑结构
线性表的存储结构
栈Stack
队列Queue
串String
数组Array
广义表Generalized List


是由n（n >=0）个性质（类型）相同的元素组成的序列。


有限性:线性表中数据元素的个数是有穷的。

相同性:ai为线性表中的元素元素类型相同

相继性:a1为表中第一个元素，无前驱元素；an为表中最后一个元素，无后继元素;
对于...ai-1,ai,ai+1...(1<i<n)，称ai-1为ai的直接前驱， ai+1为ai的直接后继。
中间不能有缺项。

线性表的存储结构1:顺序表

把线性表的元素按照逻辑顺序依次存放在数组的连续单元内；
再用一个整型量表示最后一个元素所在单元的下标，即表长


存储结构特点：

元素之间逻辑上的相继关系，用物理上的相邻关系来表示（用物理上的连续性刻画逻辑上的相继性）

是一种随机访问存取结构，也就是可以随机存取表中的任意元素，其存储位置可由一个简单直观的公式来表示。




单链表

一个线性表由若干个结点组成，每个结点均含有两个域：存放元素的信息域和存放其后继结点的指针域，这样就形成一个单向链接式存储结构，简称单链表




逻辑次序和物理次序不一定相同；
元素之间的逻辑关系用指针表示；
需要额外空间存储元素之间的关系;
非随机访问存取结构（顺序访问）;





双链表:(在单链表的各结点中再设置一个指向其前驱结点的指针域)



单向环形链表(在的单向链表中，使末尾结点的指针域指向头结点，得到一个环形结构；用指向末尾结点的指针标识这个表。)


线性表的存储结构:

一元多项式：p ( x ) = 3x14 + 2x8 + 1(3x14次方+2x的8次方+1)存储表示:采用单链表表示coef系数exp指数(3,14,next)(2,8,next)(1,0,next)


特殊的线性表:栈



栈：限定仅在表尾进行插入和删除操作的线性表。
空栈：不含任何数据元素的栈。
栈顶和栈底允许插入（入栈、进栈、压栈）和删除（出栈、弹栈）的一端称为栈顶，另一端称为栈底




栈的链接存储结构及实现
链栈:栈的链接存储结构
  第四章 树
    对于大量的输入数据，链表的线性访问时间太慢，不宜使用。本章讨论一种简单的数据结
构，其大部分操作的运行时间平均为O(logN)。我们还要简述对这种数据结构在概念上的简单
的修改，它保证了在最坏的情形下上述的时间界。此外，还讨论了第二种修改，对于长的指令序列
它基本上给出每种操作的OlogN运行时间。
  我们涉及到的这种数据结构叫做二叉查找树binary search tree.二叉查找树是两种库集合
类treeSet和treemap实现的基础。他们勇于许多应用之中。在计算机科学中树是非常有
用的抽象概念，因此，我们将讨论书在其他更一般的应用中的使用。在这一张，我们将
看到树是如何勇于实现几个流行的操作系统中的文件系统的。
看到树如何能够用来计算算术表达式的值。
指出如何利用树支持以0logn平均时间进行的各种搜索操作，以及如何细化以得到最坏情况时间界Ologn
我们还将讨论当数据被存放在磁盘上时如何来实现这些操作。
讨论并使用treeset类和treemap类

4.1 预备知识
   树tree可以用几种方式定义。定义树的一种自然方式是递归的方式。一棵树是一些节点
的集合。这个集合可以是空集；若不是空集，则树由称作根root的节点r以及0个或多个非空
的子树T1 T2 Tk组成，这些子树中每一颗的根都被来自根r的一条有向的边edge所
连接。
    每一颗子树的跟叫做根r的儿子child，而r是每一颗子树的根的父亲parent。图4-1显
示用递归定义的典型的树。

   从递归定义中我们发现，一棵树是N个节点和N-1条变的结婚，其中一个节点叫做根。
存在N-1条边的结论是由下面的事实得出的：每条边都将某个节点连接到它的父亲，而除去根
节点外每一个节点都有一个父亲。
   在图4-2的树种，节点A是根。节点F有一个父亲A并且有儿子K、L和M。每一个节点
可以有任意多个儿子，也可能是零个儿子。没有儿子的节点成为树叶leaf;上图中的树叶是B、
CHIPQKLM和N。具有相同父亲的节点为兄弟siblings;因此，KLM都是
兄弟。用类似的方法可以定义祖父gandparent和孙子grandchild关系
  从节点N1到Nk的路径path定义为节点n1,n2 ,nk的一个序列，使得对于1<=i<k
节点N是N+1的父亲。这条路径的长length是为该路径上的边的条数 即k-1 。从每一个节点
到它自己有一条长为0的路径。注意，在一棵树中从根到每个节点恰好存在一条路径。
   对任意节点n ,n的深度depth为从根到n的唯一的路径的长。因此，跟的深度为0.n
的高height是从n到一片树叶的最长路径的长。因此所有的树叶的高都是0.一棵树的高等于
它的根的高。对于图4-2中的树，E的深度为1而高位2；F的深度为1而高也是1；该书的高为
3.一棵树的深度等于它的最深的树叶的深度；该深度总是等于这棵树的高。

   如果存在从n到n2的一条路径，那么1是2的以为祖先ancestor而2是1的一个后裔
descendant。如果1!=2,那么1是2的真祖先proper ancestor而2是1的真后裔
proper descendant
4.1.1 树的实现
     实现数的一种方法可以是在每一个节点除数据外还要有一些链，使得该节点的每一个儿子
都有一个链指向它。然而，由于每个节点的儿子数可以变化很大并且事先不知道，因此在数据结构
中简历到各额日子节点直接的链接是不可行的，因为这样会产生太多浪费的空间。实际上解决
方法很简单，将每个节点的所有的儿子都放在树节点的链表中。图4-3中的声明就是典型的
声明。
   图4-4中指出一棵树如何用这种实现方法表示出来。途中向下的箭头是指向firstChild第一儿子
的链，而水平箭头指向nextSibling下一兄弟的链。因为null链太多了，所以没有把
它们画出。
   在图4-4的树种，节点E有一个链指向兄弟F，另一个链指向儿子I，而有的节点这两种链
都没有。
4.1.2 树的遍历及应用
   树有很多应用。流行的用法之一是包括unix和dos在内的许多常用操作系统中的目录结构
。图4-5是UNIX文件系统中一个典型的目录。
    这个目录的跟是usr的一个目录。usr有三个儿子：mark
alex 和bill，他们自己也都是目录。因此usr包含三个目录并且没有正规的文件。文件名usr
markbook吃。r先后三次通过最左边的子节点而得到。在第一个后的每个都表示一条边；结
果为一全路径名pathname.这个分级文件系统非常流行，因为它能是的用户逻辑地组织数据。
不仅如此，在不同目录下的两个文件还可以享有相同的名字，因此他们必然有从跟开始的不
同的路径从而具有不同的路径名。在UN系统中的目录就是含有它的所有儿子的一个文件，
因此，这些目录几乎是完全按照上述的类型声明构造的。事实上，按照unix的某些版本，
如果将打印一个文件的标准命令应用到一个目录上，那么这该目录中的这些文件名就能偶在
输出中被看到。
 设我们想要列出目录中所有文件的名字。输出格式将是：深度为d的文件将被d次跳格
tab缩进后打印其名。该算法在图4-6中以为嘛给出。
  算法的核心为递归方法listall。为了显示根时不进行缩进，该例需要从深度0开始。这
里的深度是一个内部记变量，而不是主调程

二叉树
二叉树 binary tree 是一颗树，其中每个节点都不能有多余两个的儿子。
图4-11 显示一颗由一个根和两颗子树组成的二叉树，子树T和R均可能为空。
二叉树的一个性质是一颗平均二叉树的深度要比节点个数N小得多，这个性质有时很重要。
分析表明，其平均深度为0N ，而对于特殊类型的二叉树，即二叉查找树 binary search tree
其深度的平均值是O logN 。不幸的是，正如图所示，这个深度是可以达到N-1

Object element;
BinaryNode left;
BinaryNode right;

4.2.1 实现
   因为一个二叉树节点最多有两个子节点，所以我们可以报错直接链接到他们的链。树节点
的生命在结构上类似双链表的声明，在生命中，节点就是由elemengt元素的信息加上两个到
其他节点的 引用left和right组成的结构。
treeSet 底层 treeMap 
        K key;
        V value;
        Entry<K,V> left = null;
        Entry<K,V> right = null;
        Entry<K,V> parent;
        boolean color = BLACK;
        
4.2.2 例子:表达式树 (a+b*c)+((d*e+f)*g)
expression tree。表达式树的树叶是操作数operand.如
常数或变量名，而其他节点为操作符operator.由于这里所有的操作都是二元的，因此这颗
特定的书正好是二叉树，虽然这是最简单的情况，但是节点还是有可能含有多于两个的儿子。一个
节点也有可能只有一个儿子，如具有一目减算符 unary minus operator的情形。我们可以将通过
递归计算左子树和右子树的值是因此整个书标识。
  我们可以通过递归地产生一个带括号的左表达式，然后打印出在根处的运算符，最后再递归
地产生一个带括号的右表达式而得到一个对
两个括号整体进行运算的中缀表达式。这种
一般的方法左、节点、右称为中序遍历(in-order traveasal)。由于其产生的表达式类型，这种
遍历很容易记忆。
另一种遍历策略是递归地打印出左子树 右子树，然后打印运算符。如果我讲这种策略
应用于上面的书，显而易见  这种遍历策略一般称为后续遍历。
第三种遍历策略是先打印出运算符，然后递归地打印出左子树和右子树。此时得到的表达式 是不太常用的
前缀记发。这种变量策略为贤婿遍历，稍早我们也在
4.1节讲过。以后，我们还要在本章讨论这些遍历方法。

构造表达式树
  我们现在给出一种算法来吧后缀表达式转变成标识的子树。
        

  左子树、右子树、运算符:后序遍历
  先打印运算符然后递归打印右子树和左子树:先序遍历
  
  
  4.3 查找树ADT 二叉查找树
     二叉树的一个重要的应用是它们在查找中的使用。假设树种的每个节点存储一项数据。在
我们的例子中，虽然任意复杂的项在java中都容易处理，但为简单起见还是假设它们是整数。还
将假设所有的项都是互异的，以后再处理有重复元的情况。
     使二叉树成为二叉查找树的性质是，对于树种的每个节点X，它的左子树中所有项的值
小于X中的项，而它的右子树中所有的值都大于X中的项目。
注意这意味着改书所有的元素可以用某一种一致的方式排列。
在图4-15中，左边的树是二叉查找树，但右边的树则不是。右边的树在其项是6的
节点该节点正好是跟节点的左子树中，有一个节点的项是7。
   现在给出通常对二叉查找树进行的操作的简要描述。注意，由于树的递归定义，通常是递归
地编写这些操作的例程。因为二叉查找树的平均深度是OlogN，所以一般不必担心栈空间被
用尽。
    二叉查找树要求所有的项都能够排序。要写出一个一般的类，我们需要提供一个interface
来标识这个性质。这个接口就是comparable，第一章曾经描述过。该接口告诉我们，书中
的两项总可以使用compareto方法进行比较。由此，我们能够确定所有的其他可能的关系。特别是
我们不使用equals方法，而是根据两项相等且仅当compareTo方法返回0来判断相等。另一种
方式是使用一个函数对象，将在binaryNode类像链表类中的节点类一样，是一个嵌套类。
BinarySearchTree 类架构，其中唯一的数据区域是对跟节点的引用，这个引用对于
空树来说是null。这些public方法使用了调用注入private递归方法的一般技巧。
现在描述某些私有方法
  
  
第五章 散列
 我们在第四章讨论了查找树ADT，它允许对元素的结合进行各种操作。本章讨论散列表
 hash tableADT,不过它只支持二叉树所允许的一部分操作。
   散列表的实现常常叫做散列hashing.散列是一种用于以常数平均时间执行插入、删除和
   查找的技术。但是，那些需要元素间任何排序信息的树操作将不会得到有效的支持。因此，注入
   findMin、findmax以及限行时间将过序的整个表进行打印的操作都是散列所不支持的。
   本章的中心数据结构是散列表。我们将
   看到实现散列表的几种方法。
   解析地比较这些方法。
   介绍散列的多种应用。
   将散列表和二叉树进行比较。
   
5.1 一般想法
    理想的散列表数据结构只不过是一个包含一些项item的具有固定大小的数组。第四章讨论过
，通常查找是对项的某个部门进行的。这部分就
叫做关键字key。例如项可以由一个串它可以座位关键字和其他一些数据域组成
例如姓名是大型固原结构的一部分。我们把表的大小记作tablesize，并将其理解为散列数据结构
的一部分，二部仅仅是浮动与全局的某个变量。通常的习惯是让表从0到tablesize变化；稍后我们将会明白为什么这样做

每个关键字被映射到从0到tablesize-1这个范围中的某个数，并且被放到适当的单元中。这个映射就叫做
散列的函数hash function ,理想情况下它应该计算机起来简单，并且应该保证任何两个不同的关键字映射到不同的单元。
不过，这是不可能的，因为单元色数目是有限的，而关键字实际上是用不完的。因此，我们寻找一个列三函数，
该函数要在单元之间均匀地分配关键字。图
这就是散列的基本想法。剩下的问题就是要选择一个函数，决定当两个关键字散列到同一个值
的时候 这叫做冲突 应该做什么以及如何确定散列表的大小。

散列表:一个包含一些项的具有固定大小的数组。

散列函数
   如果输入的关键字是整数，则一般合理的方法就是直接返回key mod tablesize ,除非key碰巧
具有某些不合乎需要的性质。在这种情况下，散列函数的选择需要仔细地考虑。例如，若表的
大小是10而关键字都以0位个位，则此时上述标准的散列函数就是一个不好的选择。其原因我
们将在后面看到，而为了避免上面那样的情况，好的办法通常是保证表的大小是素数。当输入的
关键字是随机整数时，散列函数不仅计算起来简单而关键字的分配也很均匀。
   通常，关键字是字符串；在这种情形下，散列函数需要仔细地选择。
   一种选择方法是吧字符串中字符的ASCLL值加起来。
    描述的散列函数实现起来很简单而且能够很快地计算出答案。不过，如果表很大，函
数将不会很好地分配关键字。例如，设tablesize10007素数，并设所有的关键字至多
8个字符长。由于ascii字符的值最多是127，因此散列函数只能假设值在0和1016之间，其中
1016位127*8.先让这不是一种均匀的分配。

  另一个散列函数如图所示。这个散列函数假设key至少3个字符。值27表示英文字母
表的字母外加一个空格的个数,而729是。该函数值考查前三个字符，但是，加入他们是
随机的，而表的大小像前面那样还是10007，那么我们就会得到一个合理的均衡分布。可是不巧
的是，英文不是随机的。虽然三个字符有17576种可能的组合，但查验合理的
足够大的联机词典却揭示：三个字母的不同组合数实际只有2851.即使这些组合没有冲突，也不过
只有表的28被真正散列到。因此，虽然很容易计算，但是当散列表具有合理大小的时候这个
函数还是不合适的。
  图5-4列出了散列函数的第三种尝试。这个散列函数设计关键字中的所有字符，并且一般可
以分布得很好，并将结果限制在适当的范围内。程
序根据homer法则计算一个37的多项式函数。例如，计算的另一种方
式是借助于公式进行。homer法则将其拓展到用于N此多项式。
   这个散列函数立勇到事实：允许溢出。这可能会引进负的数，因此在末尾有附加的测试。
   图5-4所描述的散列函数就表的分布而言未必是最好的，但确实具有极其简单的有点而且速
度也很快。如果关键字特别长，那么该散列函数计算起来将会花费过多的时间。在这种情况下
通常的经验是不是用所有的字符。此时关键字的长度和性质将影响选择。例如，关键字可能是
完整的街道地址，散列函数可以包括街道地址的几个字符，也许还有城市名和邮政编码的几个字
符。有些程序设计人员通过只使用奇数位置上的字符来实现他们的散列函数，这里有那么一层
想法：用计算散列函数节省下的时间来补偿由此产生的对均匀地分布的函数的轻微干扰。
   剩下的主要编程细节是解决冲突的消除问题。如果当一个元素被插入时与一个已经掺入的
元素散列到相同的值。那么就产生一个冲突，这个冲突需要消除。解决这种冲突的方法有几种，
我们将讨论其中最简单的两种：分离链接法和开放定址法。

5.3 分离链接法
    解决冲突的第一种方法通常叫做分离链接法 separate chaining,其做法是将散列到同一个值
的所有元素保留到一个表中。我们可以使用标准库表的实现方法。
如果空间很紧，则更可取的方法是避免使用它们 因为这些表是双向连接的并且浪费空间。
本节我们假设关键字是前10个完全平方数并设散列函数就是hashr= xmod 10
表的大小不是素数，用在这里是为了简单。图5-5 对此
做出更清晰的解释。
    为执行一次查找，我们使用散列函数来确定究竟遍历那个
链表。然后我们再被确定的链表中执行 一次查找。为执行
insert，我们检查响应的链表看看该元素是否已经处于在适当的位置
如果允许插入重复元，那么通常要留出一个额外的区域
这个区域当出现匹配时间时增1.如果这个元素是个新
元素，那么它将被插入到链表的前端，这不仅因为方便，还因为常常发生这样的事实：新近插入
的元素最有可能不久又被访问。
   实现分离链接法所需要的类架构如图5-6所示。散列表存储一个链表数组，他们在构造方法
中被指定。
   就像二叉查找树只对那些是Comparable的对象工作一样，本章中的散列表只对遵守确
定协议的那些对象工作。在java中这样的对象必须提供适当equals方法和返回一个int型
量的hashcode方法，此时，散列表把这个int
型量通过myhash转成适当的数组下标，如
图5-7所示。图5-8解释了employee类，可以
将其存放在一个散列表中，类employee提供
equals方法和基于employee名字的hashcode方法。
employee类的hashcode通过使用标准
String类中的hashcode基本上是图5-4中将14行到16行除去后的程序。
   图5-9列出构造方法和方法makeempty
   实现contains insert 和remove的例程突入5-10 所示。


3.1 树与二叉树的基本









I.数据结构


数据结构分类:
1.数据的逻辑结构
2.数据的物理结构(存储结构)



数据的逻辑结构
(无关系)集合:数据之间属于同一个集合
(1v1)数据线性结构:数据元素之间存在一对一的线性关系  线性表  
(1vS)树型结构:数据元素之间存在着一对多的层次关系
(SvS)图结构:数据元素之间存在着多对多的任意关系



数据的物理结构(存储结构)
顺序存储(内存连续存储，指针下移输出)  
链接存储(链表第一条存下一条的地址)
散列存储
索引存储:所有的存储结点按照生成的次序连续存放。另外设置一个索引区域表示结点之间的关系。

时间复杂度(Time Complexity)
O(1)<O(log2N)<O(n)<(Nlog2N)<O(N2)<O(N3)



II.线性表种类(1v1)
1.线性表的存储结构1:顺序表
2.线性表的存储结构2:单链表
3.静态链表(用数组描述的链表，即称为静态链表)
4.双链表:(在单链表的各结点中再设置一个指向其前驱结点的指针域)
5.单向环形链表(在的单向链表中，使末尾结点的指针域指向头结点，得到一个环形结构；用指向末尾结点的指针标识这个表。)
6.一元多项式：p ( x ) = 3x14 + 2x8 + 1(3x14次方+2x的8次方+1)存储表示:采用单链表表示coef系数exp指数(3,14,next)(2,8,next)(1,0,next)
7.栈：限定仅在表尾进行插入和删除操作的线性表。  顺序栈(数组)   链栈(链表实现)
8.队列:只允许在一端进行插入操作，而另一端进行删除操作的线性表。
9.数组:是由下标（ index） 和值（ value）组成的序对（ index，value） 的集合


II.树与二叉树(1vS)
定义(二叉树 binary tree 是一颗树，其中每个节点都不能有多余两个的儿子。)



二叉树

特殊的二叉树--满二叉树
定义:高度为K且有2k-1个结点的二叉树称为满二叉树。每个结点都有两个结点


特殊的二叉树--完全二叉树(最后一层节点不需要是满的，其他的每一层从左到右都必须是满的。)
堆(完全二叉树)

1.所有的叶都出现在K或K-1层







II.查找

查找分类:


分类方法1：根据查找方法取决于记录的键值还是记录的存储位置
1.基于关键字比较的查找(线性顺序查找、折半查找、分块查找、BST&AVL、B-树和B+树)
2.基于关键字存储位置的查找(散列法)


分类方法2：根据被查找的数据集合存储位置
1.内查找：整个查找过程都在内存进行
2.外查找：若查找过程中需要访问外存，如B-树和B+树

分类方法3：根据查找方法是否改变数据集合
1.静态查找：
查找+提取数据元素属性信息
被查找的数据集合经查找之后并不改变，不插删记录。
2.动态查找
查找+插入或删除元素
被查找的数据集合经查找之后可以改变，可删改增。





一：线性表的查找：

1.线性顺序查找
思想:从线性表的一端开始， 顺序扫描线性表，依次将扫描到的结点关键字与给定值K相比较


2.折半查找（二分查找）


3.分块查找
思想(分块，块间有序，块内无序)均匀分块，块间有序，块内无序：首先将表中的元素均匀地分成若干块，每一块中的元素的任意排列，而各块之间要按顺序排列













二：查找-树表（存储结构决定查找方法）二叉查找树、AVL平衡二叉树、B+树、红黑树



二叉查找树BST(二叉搜索树、二叉分类（排序）树)


AVL平衡树是平衡的二叉查找树balanced binary tree。


B树（平衡的多叉树）
性质
	1.树中每个节点至多有m棵子树；
	2.根节点至少有2棵子树； 2~m
	3.除根节点和失败节点外，所有节点至少有(m/2)棵子树；m/2 ~ m
	4.所有的终端节点和叶子节点（失败节点）都位于同一层。



B+树：可以看作是B-树的一种变形，在实现文件索引结构方面比B-树使用得更普遍。
B-树只适合随机检索，但B+树同时支持随机检索和顺序检索，在实际中应用比较多。



红黑树(RedBlackTree自平衡查找树)












三：基于关键字存储位置的查找：哈希查找(散列查找)


散列技术需解决的关键问题
	散列函数的构造。(如何设计一个简单、均匀、存储利用率高的散列函数)
	冲突的处理;如何采取合适的处理冲突方法来解决冲突。
	散列结构上的查找、插入和删除



 散列函数的构造方法:（计算Hash函数所需时间、关键字的长度、散列表的大小、关键字的分布情况、记录的查找频率）

1.直接定址法
2.质数除余法
3.平方取中法
4.折叠法
5.数字分析法
6.随机数法






冲突处理的方法：

开放定址法（闭散列表）：基本思想：当冲突发生时，使用某些探测技术在散列表中形成一个探测序列，沿此序列逐个单元查找，直到找到给定的关键字或者碰到一个开放地址（即该空的地址单元、 空桶） 或者既未找到给定的关键字也没碰到一个开放地址为止。

带溢出表的内散列法（闭散列表）：基本思想： 扩充散列表中的每个桶，形成带溢出表的散列表。每个桶包括两部分：一部分是主表元素；另一部分或者为空或者由一个链表组成溢出表，其首结点的指针存入主表的链域。主表元素的类型与溢出表的类型相同。

拉链法（链地址法）开散列表：基本思想： 将所有散列地址相同的记录，即所有同义词的记录存储在一个单链表中（称为同义词子表），在散列表中存储的是所有同义词子表的头指针。




对比:(堆积:非同义词争夺地址)
开散列表:堆积现象(无)、结构开销(有)、插入/删除(高)、 查找效率(高)、估计容量(不需要)
闭散列表:堆积现象(有)、结构开销(无)、插入/删除(低)、 查找效率(低)、估计容量(需要)






 




I.排序-基于比较[比较(泡、快排两头)、选择（直接选择、堆排）、插入(直插、折半插、希尔)、归并(二路归并)];不比较[基数排序]

分类方法1:存放的设备
内部排序:排序过程中数据对象全部在内存中的排序。
外部排序:排序过程数据对象并非完全在内存中的排序  归并(二路归并)
 

 
 

分类方法2:按照排序是的基本操作是否基于关键字的比较: 

比较(泡、快排两头)
选择（直接选择、堆排）
插入(直插、折半插、希尔)


1.交换排序-气泡BubbleSort：算法的基本思想：将待排序的记录看作是竖着排列的“气泡”，关键字较小的记录比较轻，从而要往上浮。
平均情况:时间复杂度为O(n2)、空间复杂度为O(1)

2.交换排序-快速排序-两头排QuickSort 不稳定47<=X<268
最左边是基准，左边找第一个大于它的，右边找第一个小于它的，交换。找到中间，替换基准
算法的基本思想:通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对着两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
时间复杂度为O(nlog2n)、空间复杂度为O(log2n)

3.选择排序-直接选择:算法的基本思想:每趟排序在当前待排序序列中选出关键字值最小 的记录，添加到有序序列中。
气泡排序区别：气泡排序每次比较后，如果发现顺序不对立即进行交换，而选择排序不立即进行交换，而是找出最小关键字记录后再进行交换。

4.选择排序-堆排序（完全二叉树）直接选择升级版-把数据组成一个堆完全二叉树（最上边是极值）



5.插入排序-直接插入(扑克牌)稳定:算法的基本思想：插入排序的主要操作是插入，其基本思想是：每次将一个待排序的记录按其关键字的大小插入到一个已经排好序的有序序列中，直到全部记录排好序为止。
时间复杂度为O(n2)、空间复杂度： O(1)

6.插入排序-折半插入:(插入优化，插入有序部分时从中间找)  直接插入排序， 在插入第 i（ i＞ 1）个记录时，前面的 i-1个记录已经排好序，则在寻找插入位置时，可以用折半查找来代替顺序查找，从而较少比较次数。




7.外部排序 归并(二路归并)
按照分块大小拆分成N块。  每两块进行比较，完成后合并
递归拆分成单独的，然后两个合并、四个合并全部合并。






共享锁shared lock 也叫 读锁 read lock

排他锁exclusive lock 也叫 写锁 write lock


读锁是共享的，或者说是互相不阻塞的。多个客户在同一时刻可以同时读取同一个资源，互不干扰。


写锁是排他的，也就是说一个写锁会阻塞其他的写锁和读锁。


1.2.2 锁粒度
一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分
数据，而不是所有的资源。更理想的方式是，只对会修改的数据片进行精确的锁定。
任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程序越高，只要互相之间
不发生冲突即可。

问题是加锁也需要消耗资源。锁的各种操作，包括获得

row level lock 

mysql存储引擎都可以实现自己的锁策略和锁粒度。

表锁 table lock
表锁是mysql中最基本的锁策略，并且是开销最小的策略。表锁非常类似于前文描述
的邮箱加锁机制：它会锁定整张表。一个用户在对表进行写操作 插入 删除 更新等
前，需要先获得写锁，这回阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他
读取的用户才能获得读锁，读锁之间是不相互阻塞的。

在特定的场景中，表锁也可能有良好的性能。例如 read local表锁支持某些类型的
并发写操作。另外，写锁也比读锁有更高的优先级，因此一个写锁请求可能会被插入到
读锁队列的前面（写锁可以插入到锁队列中读锁的前面，反之读锁则不能出插入到写锁的前面）

尽管存储引擎可以管理自己的锁，mysql本身还是会使用各种有效的锁来实现不同
的目的。例如，服务器会为诸如 alter table之类的语句使用表锁，而忽略存储引擎的
锁机制。

行级锁row lock
行级锁row lock可以最大程度地支持并发处理同事也带来了最大的锁开销。众所周知，在
innodb和xtardb,以及其他一些存储引擎中实现了行级锁。行级锁只在存储引擎层实现
，而mysql服务层没有实现。服务器层
完全不了解存储引擎中的锁实现。在本章的后续内容以及全书中，所以的存储引擎都以自己
的方式显现了锁机制。


1.3 事务
在理解事务的概念之前,接触数据库系统的其他高级特性还言之过早。事务就是一组原子性
的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用
改组查询的全部语句，那么就执行改组查询。如果其中有任何一条语句因为崩溃或其
他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要全部执行成功
，要么全部执行失败。

事务的ACID
原子性 atomicity
一致性 consistency
隔离性 isolation
持久性 durability

一个运行良好的事务处理系统，必须具备这些标准特性。


原子性atomicity
一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部
提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中一部分的
操作，这就是事务的原子性。

一致性 consistency
数据库总是从一个一致性的状态转换到另外一个一致性的状态。在前面的例子中，
一致性确保了，即使在执行第三四条语句之间时系统崩溃，支票账户中也不会损失
，因此事务最终没有提交，所以事务中锁座的修改也不会报错到数据库中。


隔离性 isolation
通常来说，一个事务锁座的修改在最终提交以前，对其他事务是不可见的。在签名
的例子中，当执行完第三条语句，第四条语句还未开始时，此时有另外一个账户汇总
程序开始运行，则其看到的支票账户的余额并没有被减去200元。后面我们讨论
隔离级别 isolation level的时候，会发现为什么我们要说通常来说是不可见的。


持久性 durability
一旦事务提交，则其所作的修改就会永久保存到数据库中。此时即使系统崩溃，修改
的数据也不会丢失。持久性是个有点模糊的概念，因为实际上持久性也分很多
不同的级别。有些持久性策略能够提供非常强的概念，因为实际上持久性也分很多不同
的级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。而且
不可能有能做到100的持久性保证的策略 如果数据库本身就能做到真正的持久性
那么备份有能增加吃就能呢。

事务的 acid特性可以确保银行不会弄丢你的钱。而在应用逻辑中，要实现这一点非常难，
甚至可以说是不可能完成的任务。一个兼容 acid的数据库系统，需要做很多复杂但可能
yoghurt并没有察觉到的工作，才能确保ACID的实现。

就想锁粒度的升级会增加系统开销一样，这种事务处理过程中额外的安全性，也会需要
数据库系统做更多的额外工作。一个实现了acid的数据库，相比没有实现acitd的数据库
通常会需要更强的CPU处理能力更大的内存和更多的磁盘。正如本章不断
重复的，这也正是mysql的存储引擎架构可以发挥优势的地方。用户可以根据业务是否
需要事务处理，来选择合适的存储引擎。对于一些不需要事务的查询类应用，选择
一个非事务性的存储引擎，可以获得更高的性能。及时存储引擎不支持事务，也可以
通过locktables语句为应用提供一定程度的保护，这些选择用户都可以自助决定。

1.3.1 隔离级别
隔离性其实比想象的要复杂。在SQL标准中定义了四种隔离级别，每一种级别都规定了
一个事务中所做的修改，那些在事务内和事务间是课件的，那些是不可见的。较低级别
的隔离通常可以执行更高的并发，系统的开销也更低。

每种存储引擎实现的隔离级别不尽相同。如果熟悉其他的数据库产品，可能会发现
某些特性和你期望的会有些不一样。读者可以根据所选择的存储引擎，查阅相关手册。

下面简单地介绍一下四种隔离级别。

READ UNCOMMITTED 未提交读
在 read uncommit ted级别，事务中的修改，即使没有提交，对其他事务也都是可见的。
事务可以读取未提交的数据，这也被称为脏读 dirty read.这个级别会导致
很多问题，从性能上来说，read uncommitted不会比其他的级别好太多，但却缺乏
其他级别的好处，除非真的有非常必要的理由，在实际应用中一般很少使用。

READ COMMITTED 提交读
大多数数据库系统的默认隔离级别都是 read committed 但mysql不是。read 
committed满足签名提到的隔离性的简单定义：一个事务开始时，只能看见已经
提交的事务所做的修改。换句话说，一个事务从开始直到提交之前，锁座的任何修改
对其他事务都是不可见的。这个界别有时候也叫做不可重复读 nonrepeatable
read ,因为两次执行同样的查询，可能会得到不一样的结果。

REPEATABLE READ 可重复读
repea table read 解决了脏读的问题。 该级别保证了在同一个事务中多次读取同样
记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读
phantom read的问题。所谓幻读，值得是当某个事务在读取某个范围内的记录时，
另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取改范围的记录时
会产生幻行 phantom row  innodb xtra db 存储引擎通过多版本并发控制
MVCC 解决幻读的问题。本章稍后会做进一步的跳楼

可重复读是mysql的默认事务隔离级别


SERIALIZABLE 可串行化
serializable 是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读
的问题。简单来说，serializable会在读取的每一行数据上都加锁，所以可能导致
大量的超时和锁争用的问题。实际应用中也很少用到这个隔离级别，只有在非常需要
确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。

























这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。








索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。



I.索引常见的数据结构：
哈希表:等值查询快，不能范围查询;更新维护快memcache:redis
有序数组:等值查询快，范围查询快(二分法O(logn));更新麻烦，适合静态存储
搜索树:
1.更新和查询都是O(log(N));不用二叉树(索引不止存在内存中，还要写到磁盘上)
2.使用N叉树，取决于数据块的大小。

跳表(跳跃列表):有序的链表，增加索引，比原有索引路径短。

LSM树(LogStructuredMergeTree)写性能高:两个或以上的存储结构组成:内存中C0结构(树)+磁盘中C1等结构(树)
一个存储结构常驻内存中，称为C0 tree 
当C0大小达到某一阈值时或者每隔一段时间，将C0中记录滚动合并到磁盘C1中


I.根据数据结构，决定应用场景.





页分裂

除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。


你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。




自增主键的适用场景：
业务逻辑字段作为主键：只有key value


https://blog.csdn.net/u011389515/article/details/80192996


有一道MySQL的面试题，为什么MySQL的索引要使用B+树而不是其它树形结构?比如B树？

现在这个问题的复杂版本可以参考本文；

他的简单版本回答是：

因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；


06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？



全局锁
表级锁
行锁


MySQL 提供了一个加全局读锁的方法
Flush tables with read lock (FTWRL)
-- 打开全局锁
FLUSH TABLES WITH READ LOCK ;
-- 解除全局锁
UNLOCK TABLES;

数据更新语句（数据的增删改）
数据定义语句（包括建表、修改表结构等）
更新类事务的提交语句

场景:全局锁的典型使用场景是，做全库逻辑备份


mysqldump 使用参数–single-transaction 的时候，
导数据之前就会启动一个事务，来确保拿到一致性视图。


set global readonly=true 和 FTWRL(flush tables with read lock)
一是，在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，我不建议你使用。

二是，在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。
 DML(DataManipulationLanguage)数据操纵语言





表级锁MySQL 

里面表级别的锁有两种：
一种是表锁，
一种是元数据锁（meta data lock，MDL)。


表锁的语法是 lock tables … read/write。与 FTWRL 类似，
可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。
需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象


即使是小表，操作不慎也会出问题





 


事务支持是在引擎层实现的


MyISAM 引擎就不支持事务

ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）

SQL 标准的事务隔离级别包括：
读未提交（read uncommitted）:其他事务可以读取未提交的数据,脏读 dirty read
读提交（read committed）不可重复读:
可重复读（repeatable read）:幻读Phantom Read(A事务读取某个范围的数据，B事务插入记录，A事务再读出现幻行Phantom Row)
串行化（serializable ）能读


Oracle 数据库的默认隔离级别其实就是“读提交”read committed
Mysql 默认隔离级别是 可重复读repeatable read
 

1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
　　2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。



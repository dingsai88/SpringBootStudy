
第12章 Java内存模型与线程
   并发处理的广泛应用是使得amdahl定律代替默认定律成为计算机性能发展源动力的根
本原因，也是人类压榨计算机运算能力的最有力武器。

12.1概述
    多任务处理在现代计算机操作系统中几乎已是一项必备的功能了。在许多情况下，让
计算机同时去做几件事情，不仅是因为计算机的运算能力强大了，还有一个很重要的原因是
计算机的运算速度与它的存储和通信子系统速度的差距太大，大量的时间都花费在磁盘I/O、
网络通信或数据库访问上。如果不希望处理器在大部分时间里都处于等待其他资源的状
态，就必须使用一些手段去把处理的运算能力“压榨”出来，否则就会造成很大的浪费，
而让计算机同事处理机箱任务则是最容易想到、也被证明是非常有效的压榨手段。
    除了充分利用计算机处理器的能力外，一个服务端同时对多个客户端提供服务则是两一个
更具体的并发应用场景。衡量一个服务性能的高低好坏，每秒事务处理数transactions
per second tps是最重要的性能指标之一，它代表着1秒内服务端平均能响应的请求总数，而
TPS值与程序的并发能力又有非常密切的关系。对于计算量相同的任务，程序线程并发协调
得越有条不紊，效率自然就会越高；反之线程之间频繁阻塞甚至死锁，将会大大降低程序
的并发能力。
   服务端是java语言最擅长的领域之一，这个领域的应用占了java应用中最大的一块份
额，不过如何写好并发应用程序却又是服务端程序开发的难点之一，处理好并发方面的问
题通常需要更多的编码经验来支持。幸好java语言和虚拟机提供了许多工具，把并发编程
的门槛降低了不少。并且各种中间件服务器、各类框架都努力地替程序员处理尽可能多的线
程并发细节，使得程序员在编码时能更关注业务逻辑，而不是划分大部分时间去关注此服务
会同时被多少人调用、如何协调硬件资源。无论语言、中间件和框架如何先进，开发人员都
不能期望它们能独立完成所有并发处理的事情，了解并发的内部也是成为一个高级程序员不
可缺少的课程。
   高效开发是本书讲解java虚拟机的最后一部分，将会向读者介绍虚拟机如何实现多
线程、多线程之间由与共享和竞争数据而导致的一系列问题及解决方案。

12.2 硬件的效率与一致性
   在正式讲解虚拟机并发相关的知识之前，我们先花费一点时间去了解一下屋里计算
机中的并发问题，物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发
的处理方案对于虚拟机的实现也有相当打的参考意义。
   让计算机并发执行若干个运算任务与更充分地利用计算机处理器的效能之间的
因果关系，看起来顺利成章，实际上并没有想象中的那么简单，其中一个重
要的复杂性来源是绝大多数的运算任务都不可能只靠处理器计算就能完成，处理器至少
要与内存交互，如读取运算数据、存储运算结果等，这个IO操作是很难消除的（无法仅靠
寄存器来完成所有的运算任务）。由于计算机的存储设备与处理器的运算速度的高速缓
存cache来座位内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让
运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内
存读写了。
    基于告诉缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统
带来更高的复杂度，因为它引入了一个新的问题：缓存一致性cachecoherence。在多处
理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主内存main memory
如图12-1所示。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的
缓存数据不一致，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为
了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来
进行操作，这类协议有MSImesimosi
protocol等。在本章中将会多次提到的内存模型一词，可以理解为在特定的操作协议下，
对特定的内存或告诉缓存进行读写访问的过程抽象。不同架构的物理机器可以拥有不一样的
内存模型，而java虚拟机也有自己的内存模型，并这里介绍的内存方位操作与硬件的缓存
访问操作具有很高的可比性。


   除了增加高速缓存之外，为了使得处理器内部的运算单元能尽管被充分利用，处理器
可能会对输入代码进行乱序执行outoforderexecution优化，处理器会在计算之后将乱
序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计
算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务以来另外一个计算任
务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类
似，java虚拟机的即时编译器中也有类似的指令重排序instruction reorder 优化。
12.3 java内存模型
   java虚拟机规范中试图定义一种java内存模型java memory model jmm来屏蔽
掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的
内存访问效果。再次之前，主流程序语言直接使用武力硬件和操作系统的
内存模型，因此，会由不同平台上内存模型的差异，有可能导致程序在一套平台上并发完
全正常，而在另外一套平台上并发访问却经常出错，因此在某些场景就必须针对不同平台
来编写程序。
   定义java内存模型并非一件容易的事情，这个模型必须定义得足够严谨，才能让java
的并发内存访问操作不会产生歧义：但是，也必须定义得足够宽松，使得虚拟机的实现有
足够的自有空间去立勇硬件的各种特性（寄存器、高速缓存和指令集中某些特有的指令）来
获取更好的执行速度。经过长时间的验证和修补，在jdk1.5实现了JSR-133发布后，
java内存模型已经成熟和完善起来了。
12.3.1主内存与工作内存
   java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储
到内存和从内存中取出变量这样的底层细节。此处的变量variables与java变成中所说的
变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与
方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得教
好的执行效能，java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主
内进行交互，也没有限制即时编译器调整代码顺序这类优化措施。
   java内存模型规定了所有的变量都存储在?主内存mainmemory中此处的主内存
与介绍物理硬件时的主内存名字一样，两种也可以互相类比，但此处仅是虚拟机内存的
部分。每个线程还有自己的工作内存workingmemor可与前面讲的处理器告诉缓存类
比，线程的工作内存中报错了被该线程使用到的变量的内存副本拷贝，线程对变量的所
有操作读取赋值等都必须在工作内存中进行，而不能直接读写主内存中的变量。不
同的线程之间也无法直接访问对象工作内存中的变量，线程间变量值的传递均需要通过主内存来完成
，线程、主内存、工作内存散着的交互关系如图
    这里所讲的主内存、工作内存与本书第2张所讲的内存区域中的java堆栈方
法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对
应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于java堆中的对象实例
数据部分，儿工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，住内存就直接
对应屋里硬件的内存，而为了获取更好的运行速度，虚拟机设置是硬件系统本身的优化措施
可能会让工作内存优先存储寄存器和高速缓存中，因为程序运行时主要访问读写的
是工作内存。
12.3.2 内存间交互操作
    关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存
、如何从工作内存同步回主内存之类的实现细节,java内存模型中定义了以下8中操作来完
成、虚拟机实现时必须保证下面提及的每一宗操作都是原子的、不可再分的对于double和
long类型的变量来说，loadstroereadwrite操作在某些平台上允许有例外，这个问题在
12.3.4节再讲。
   lock锁定：作用于主内存的变量，它把一个变量标示为一条线程独占的状态。
   unlock解锁：作用域主内存的变量，他把一个处于锁定状态的变量释放出来，
   释放后的变量才可以被其他线程锁定。
   read读取：作用域主内存的变量，他把一个变量的值从主内存传输到线程的工作
   内存中，以便随后的load动作使用。























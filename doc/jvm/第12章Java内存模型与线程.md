https://www.cnblogs.com/czwbig/p/11127124.html


第12章 Java内存模型与线程
   并发处理的广泛应用是使得amdahl定律代替默认定律成为计算机性能发展源动力的根
本原因，也是人类压榨计算机运算能力的最有力武器。

12.1概述
    多任务处理在现代计算机操作系统中几乎已是一项必备的功能了。在许多情况下，让
计算机同时去做几件事情，不仅是因为计算机的运算能力强大了，还有一个很重要的原因是
计算机的运算速度与它的存储和通信子系统速度的差距太大，大量的时间都花费在磁盘I/O、
网络通信或数据库访问上。如果不希望处理器在大部分时间里都处于等待其他资源的状
态，就必须使用一些手段去把处理的运算能力“压榨”出来，否则就会造成很大的浪费，
而让计算机同事处理机箱任务则是最容易想到、也被证明是非常有效的压榨手段。
    除了充分利用计算机处理器的能力外，一个服务端同时对多个客户端提供服务则是两一个
更具体的并发应用场景。衡量一个服务性能的高低好坏，每秒事务处理数transactions
per second tps是最重要的性能指标之一，它代表着1秒内服务端平均能响应的请求总数，而
TPS值与程序的并发能力又有非常密切的关系。对于计算量相同的任务，程序线程并发协调
得越有条不紊，效率自然就会越高；反之线程之间频繁阻塞甚至死锁，将会大大降低程序
的并发能力。
   服务端是java语言最擅长的领域之一，这个领域的应用占了java应用中最大的一块份
额，不过如何写好并发应用程序却又是服务端程序开发的难点之一，处理好并发方面的问
题通常需要更多的编码经验来支持。幸好java语言和虚拟机提供了许多工具，把并发编程
的门槛降低了不少。并且各种中间件服务器、各类框架都努力地替程序员处理尽可能多的线
程并发细节，使得程序员在编码时能更关注业务逻辑，而不是划分大部分时间去关注此服务
会同时被多少人调用、如何协调硬件资源。无论语言、中间件和框架如何先进，开发人员都
不能期望它们能独立完成所有并发处理的事情，了解并发的内部也是成为一个高级程序员不
可缺少的课程。
   高效开发是本书讲解java虚拟机的最后一部分，将会向读者介绍虚拟机如何实现多
线程、多线程之间由与共享和竞争数据而导致的一系列问题及解决方案。

12.2 硬件的效率与一致性
   在正式讲解虚拟机并发相关的知识之前，我们先花费一点时间去了解一下屋里计算
机中的并发问题，物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发
的处理方案对于虚拟机的实现也有相当打的参考意义。
   让计算机并发执行若干个运算任务与更充分地利用计算机处理器的效能之间的
因果关系，看起来顺利成章，实际上并没有想象中的那么简单，其中一个重
要的复杂性来源是绝大多数的运算任务都不可能只靠处理器计算就能完成，处理器至少
要与内存交互，如读取运算数据、存储运算结果等，这个IO操作是很难消除的（无法仅靠
寄存器来完成所有的运算任务）。由于计算机的存储设备与处理器的运算速度的高速缓
存cache来座位内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让
运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内
存读写了。
    基于告诉缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统
带来更高的复杂度，因为它引入了一个新的问题：缓存一致性cachecoherence。在多处
理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主内存main memory
如图12-1所示。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的
缓存数据不一致，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为
了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来
进行操作，这类协议有MSImesimosi
protocol等。在本章中将会多次提到的内存模型一词，可以理解为在特定的操作协议下，
对特定的内存或告诉缓存进行读写访问的过程抽象。不同架构的物理机器可以拥有不一样的
内存模型，而java虚拟机也有自己的内存模型，并这里介绍的内存方位操作与硬件的缓存
访问操作具有很高的可比性。


   除了增加高速缓存之外，为了使得处理器内部的运算单元能尽管被充分利用，处理器
可能会对输入代码进行乱序执行outoforderexecution优化，处理器会在计算之后将乱
序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计
算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务以来另外一个计算任
务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类
似，java虚拟机的即时编译器中也有类似的指令重排序instruction reorder 优化。
12.3 java内存模型
   java虚拟机规范中试图定义一种java内存模型java memory model jmm来屏蔽
掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的
内存访问效果。再次之前，主流程序语言直接使用武力硬件和操作系统的
内存模型，因此，会由不同平台上内存模型的差异，有可能导致程序在一套平台上并发完
全正常，而在另外一套平台上并发访问却经常出错，因此在某些场景就必须针对不同平台
来编写程序。
   定义java内存模型并非一件容易的事情，这个模型必须定义得足够严谨，才能让java
的并发内存访问操作不会产生歧义：但是，也必须定义得足够宽松，使得虚拟机的实现有
足够的自有空间去立勇硬件的各种特性（寄存器、高速缓存和指令集中某些特有的指令）来
获取更好的执行速度。经过长时间的验证和修补，在jdk1.5实现了JSR-133发布后，
java内存模型已经成熟和完善起来了。
12.3.1主内存与工作内存
   java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储
到内存和从内存中取出变量这样的底层细节。此处的变量variables与java变成中所说的
变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与
方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得教
好的执行效能，java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主
内进行交互，也没有限制即时编译器调整代码顺序这类优化措施。
   java内存模型规定了所有的变量都存储在?主内存mainmemory中此处的主内存
与介绍物理硬件时的主内存名字一样，两种也可以互相类比，但此处仅是虚拟机内存的
部分。每个线程还有自己的工作内存workingmemor可与前面讲的处理器告诉缓存类
比，线程的工作内存中报错了被该线程使用到的变量的内存副本拷贝，线程对变量的所
有操作读取赋值等都必须在工作内存中进行，而不能直接读写主内存中的变量。不
同的线程之间也无法直接访问对象工作内存中的变量，线程间变量值的传递均需要通过主内存来完成
，线程、主内存、工作内存散着的交互关系如图
    这里所讲的主内存、工作内存与本书第2张所讲的内存区域中的java堆栈方
法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对
应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于java堆中的对象实例
数据部分，儿工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，住内存就直接
对应屋里硬件的内存，而为了获取更好的运行速度，虚拟机设置是硬件系统本身的优化措施
可能会让工作内存优先存储寄存器和高速缓存中，因为程序运行时主要访问读写的
是工作内存。
12.3.2 内存间交互操作
    关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存
、如何从工作内存同步回主内存之类的实现细节,java内存模型中定义了以下8中操作来完
成、虚拟机实现时必须保证下面提及的每一宗操作都是原子的、不可再分的对于double和
long类型的变量来说，loadstroereadwrite操作在某些平台上允许有例外，这个问题在
12.3.4节再讲。
   lock锁定：作用于主内存的变量，它把一个变量标示为一条线程独占的状态。
   unlock解锁：作用域主内存的变量，他把一个处于锁定状态的变量释放出来，
   释放后的变量才可以被其他线程锁定。
   read读取：作用域主内存的变量，他把一个变量的值从主内存传输到线程的工作
   内存中，以便随后的load动作使用。
   load载入:作用域工作内存的变量,它把read操作从主内存中得到的变量值放入
   工作内存的变量副本中.
   use使用:作用域工作内存的变量,它把工作内存中一个变量的值传递给执行引擎,
   每当虚拟机遇到一个需要使用到变量的值得字节码指令时会执行这个操作.
   assign赋值:作用于工作内存的变量,它把一个从执行引擎接受到的值赋给工作
   内存的变量,每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作.
   store存储:作用于工作内存的变量,它把工作内存中一个变量的值传送到住内存
   中,以便随后的write操作使用.
    write写入:作用于主内存的变量,它把store操作从工作内存中得到的变量的值放
    入主内存的变量中.
    
    如果要把一个变量从主内存复制到工作内存,那就要顺序地执行read和load操作,如
    果要把变量从工作内存同步回主内存,就要顺序地执行storewrite啊哦做.注意,java内存
    模型只要求上述两个操作必须按顺序执行,如对主内存中的变量ab进行访问时,一种
    可能出现顺序是read啊readbload不load啊除此之外,java内存模型还规定了在执行上
    8种基本操作时必须满足如下规则:
    不允许read和loadstore和write操作之一单独出现,即不允许一个变量从猪内存读
    取了但工作内存不接受,或者从工作内存发起回写了但主内存不接受的情况出现.
    不允许一个线程丢弃它的最近assign操作,即变量在工作内存中改变了之后必须把
    改变或同步回主内存.
    不允许一个线程无原因地,没有发生过任何assign操作把数据从线程的工作内存同步
    回主内存zhong
    一个新的变量只能在主内存中诞生,不允许在工作内存中直接使用一个未被初始化
    laodassign的变量,换句话说,就是对一个变量实时usestore操作之前,
    必须先执行过了assign和load操作.
    一个变量在同一个时刻只允许一条线程对其进行lock操作但loack操作可以被同一条
    线程重复执行多次,多次执行lock后,只有执行相同次数的unloack操作,变量才会
    被解锁.
    如果对一个变量执行lock操作,那将会清空工作内存中此变量的值,在执行引擎使
    用这个变量强,需要重新执行load或assign操作初始化变量的值.
    如果一个变量事先没有被lock操作锁定,那就不允许对他执行unlock操作,也不允
    许去unlock一个被其他线程锁定住的变量.
    对一个变量执行unlock操作之前,必须先把此变量同步回主内存中执行sotrewrite
    操作.
    这8种内存访问操作以及上述规则限定,再加上稍后介绍的对volatile的一些特殊规定,
就已经完全确定了java程序中那些内存访问操作在并发下是安全的.由于这种定义相当严谨
但又是否烦琐,实践起来很麻烦,所以在12.3.6节中笔者将介绍这种定义的一个等效判断原
则先行发生原则,用来确定一个访问在并发环境下是否安全.

12.3.3 对于volatile(不稳定)型变量的特殊规则
    关键字volatile可以说是java虚拟机提供的最轻量级的同步机制,但是它并不容易完全
被正确\完整地理解,以至于许多程序员都习惯不去使用它,遇到需要处理多线程数据竞争
问题的时候一律使用synchronized来进行同步.了解volatile变量的语义对后面了解多线程
操作的其他特性很有意义,在本节中我们将多花费一些时间去弄清楚volatile的语义到底是
什么.
   java内存模型对volatile专门定义了一些特殊的访问规则,在介绍这些比较绕口的规则
定义之前,笔者先用不那么正式但通俗易懂的语言来介绍一下这个关键字的作用.
   当一个变量定义为volatile之后,他将具备两种特性,第一是保证此变量对所有线程的
可见性,这里的可见性是指当一条线程修改了这个变量的值,新值对于其他线程来说是
可以立即的值的.而普通变量不能做到这一点,普通变量的值在线程间传递均需要通过主内存
来完成,例如,线程A修改一个普通变量的值,然后向主内存进行回写,另外一条线程B
在线程A回写完成了之后再从主内存进行读取操作,新变量值才会对线程B可见.
   关于volatile变量的可见性,经常会被开发人员误解,认为以下描述成立:volatile变量
对所有线程是立即可见的,对volatile变量所有的写操作都能立即反应到其他线程之中,换句话说
,volatile变量在各个线程中是一致的,所以基于volatile变量的运算在并发
下是安全的.这句话的论据部分并没有错,但是其论据并不能得出基于volatile变量的运算在并发
下是安全的这个结论.volatile变量也可以存在不一致的问题(在各个线
程的工作内存中,volatile变量也可以存在不一致的情况,但由于每次使用之前都要先刷新,
执行引擎看不到不一致的情况,因此可以认为不存在一致性问题),但是java里面的运算并
非原子操作,导致volatile变量的运算在并发下一样是不安全的,我们可以通过一段简单的
演示来说明原因,请看代码清单12-1中演示的例子.
  这段代码发起了20个线程，每个线程对race变量进行10000次自增操作，如果这段代
码能够正确并发的话，最后输出的结果应该是200000.读者运行完这段代码之后，并不会获得
期望的结果,而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的
数字，这是为什么呢？

    问题就出现在自增运算race++之中，我们用于javap反编译这段代码后会得到代码清单
12-2 发现只有一行代码increase方法在class文件中由4条字节码指令构成的
return指令不是由race++产生的，这条指令可以不计算，从字节码层面上很容易就分析出
并发失败的原因了：当getstatic指令吧race的值渠道操作栈顶时，volatile关键字保证了race
的值在此时是正确的，但是在执行inconst——1iadd这些指令的时候，其他线程可能已经把race
的值加大了，而在操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能吧较
小的race值同步回主内存之中。
    客观的说，笔者在此使用字节码来分析并发问题，仍然是不严谨的，因为即使编译出来
只有一条字节码指令，也并不意味执行这条指令就是一个原子操作。一条字节码指令在解释
执行时，解释器将要运行许多行代码才能实现它的语义，如果是编译执行，一条字节码指令
也可能转化成若干条本地机器码指令，此处使用-xxprintassembly参数输出反汇编来分析 -XX+PrintAssembly
会更加严谨一些，但考虑到读者阅读的方便，并且字节码已经能说明问题，所以此处使用字节码来分析

   由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要
通过加锁使用synchronized或java.util.concurrent中的原子类来保证原子性。
   运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
   变量不需要与其他的状态变量共同参与不变约束。
   而在像如下的代码清单12-3所示的这类常军就很适合使用volatile变量来控制并发，当
shutdown方法被调用时，能保证所有线程中执行的dowork方法都立即停下来。
   
     使用volatile变量的第二个语义是禁止指令重排序优化，普通的变量仅仅会保证在该
方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值
操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知
到这点，这也就是java内存模型中描述的所谓的线程内表现为穿行的语义within-thread as if serial semantiex
    上面的描述仍然不太容易理解，我们还是继续通过一个例子来看看为何指令重排序会干
扰程序的并发执行，演示程序如代码清单12-4所示。
     
     
     代码清单12-4中的程序是一段伪代码，其中描述的场景十分常见，只是我们在处理配
置文件时一般不会出现并发而已。如果定义initialized变量时没有使用volatile修饰，就可能
会由于指令重排序的优化，导致位于线程A中最后一局的代码initialized=true被提前执
行这里虽然使用java作为伪代码，但所指的重排序优化是机器级的优化操作，提前执行是
指这句话对应的汇编代码被提前执行，这样的在线程B中使用配置信息的代码就可能出现错
误，而volatile关键字则可以避免此类情况的发生。
   指令重排序是并发编程中最容易让开发人员产生疑惑的地方，除了上面伪代码的例子之
外，笔者再举一个可以实际操作运行的例子来分析volatile关键字是如何禁止指令重排序优
化的。代码清单12-5是一段标准的DCL单例代码，可以观察加入volatile和未加入volatile
关键字时所生产汇编代码的差别
double
dubbo
12.3.4 对于long和double类型变量的特殊规则
  java内存模型要求lock、unlock、read\load\assign use\store write这8个操作都
具有原子性，但是对于64位的数据类型long和都变了，在模型中特别定义了一条相对宽
松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操
作来进行，即允许虚拟机实现选择可以不保证64位数据类型的loadstorereadwrite这
4个操作的原子性，这点就是所谓的long和double的非原子协定nonatomic treatment of
double and long variables
  如果有多个线程共享一个并未声明为volatile和long和double类型的变量，并且同事对
它们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改
值的代表了半个变量的数值。
  不过这种读取到半个变量的情况非常罕见在目前的商用java虚拟机中不会出现
因为java内存模型虽然运行虚拟机不把long和double变量的读写实现成原子操作，但允
许虚拟机选择吧这些操作实现为具有原子性的操作，而且还强烈建议虚拟机这样实现。
在实际开发中，目前各种平台下的商用虚拟机几乎都选择吧64位数据的读写操作作为原子
操作来对待，因此我在编写代码时一般不需要把用到的long和double变量专门声明为
volatile
12.3.5 原子性、可见性与有序性
   介绍完java内存模型的相关操作和规则，我们再整体回顾一下这个模型的特征。java内存
模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的，我们
逐个来看一下哪些操作实现了这三个特性。
   原子性atomicity：由于java内存模型来直接保证原子性变量操作包括readload
assign、use、store、write，我们大致可以认为基本数据类型的访问读写是具备原子性的例
外就是long和double的非原子性协定，读者要知道这件事情就可以了，无须太过在意这
些几乎不会发生的例外情况。
    如果应用场景需要一个更大范围的原子性保证经常会遇到，java内存模型还提供了
lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使
用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个
操作，这两个字节码指令反应到java代码中就是同步块synchronized关键字，因此在
synchronized块之间的操作也具备原子性。
   可见性visibility：可见性是指当一个线程修改了共享变量的值，其他线程能够立即的
知这个修改。上文在讲解volatile变量的时候我们已经详细讨论过这一点。java内存模型是通
过在变量修改后将新值同步回住内存，在变量读取前从住内存刷新变量值这种依赖主内存作
为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如何，普通变量
与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使
用前立即用从主内存刷新。因此，可以说volatile保证了多线程操作时变量的可见性，而普通
变量则不能保证这一点。
   除了volatile之外，java还有两个关键字能实现可见性，即synchronized和final。同步
块的可见性是由“对一个变量执行unlock操作之前，必须把此变量同步回主内存中执行
store、write操作”这条规则获得的，而final关键字的可见性是指：呗final修饰的字段在构
造器中一旦初始化完成，并且构造器没有吧this的引用传递出去（this引用逃逸是一件很
危险的事情，其他线程有可能通过这个引用访问到初始化了一般的对象），那在其他线
程中就能看见final字段的值。如代码清单12-7所示，变量i与j都具备可见性，他们无需同
步就能被其他线程正确访问。

     有序性ordering：java内存模型的有序性在前面讲解volatile时也详细地讨论过了，
java程序中天然的有序性可以总结为一句话：如果本线程内观察，所有的操作都是有序的：
如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指线程内编写为串行
的语义within thread as if serial semanties 后半句是指指令重排序现象和工作
内存与主内存同步延迟现象。
   java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性
volatile关键字本身就包含了紧张指令重排序的语义，而synchronized则是由一个变量在同
一个时刻只允许一条线程对其进行lock操作这条规则获得的，这条规则决定了持有同一个
锁的两个同步块只能串行地进入。
   介绍未并发中3中重要的特性后，读者有没有发现synchronized synchronized关键字在需要这3中特
性的时候都可以作为其中一种的解决方案？看起来很万能吧。的确，大部分的并发控制
操作都能使用sychronized来完成。synchronized的完成也简介造就了他被程序员滥用
的局面，越完成的并发控制，通常会伴随着越大的性能影响，这点我们将在第13章讲解
虚拟机锁优化时再介绍
   12.3.6 先行发生原则
   如果java内存模型中所有的有序性都仅仅靠volatile和synchronized来完成，那么有一
些操作将会变得很繁琐，但是我们在编写java并发代码的时候并没有感觉到这一点，这是因
为java语言中有一个先行发生happens before的原则。这个原则非常重要，它是判断
数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一篮
子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。
   现在就来看看先行发生原则指的是什么。先行发生是java内存模型中定义的两项
操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操
作A产生的影响能被操作B观察到，影响包括修改了内存中共享变量的值、发送了消息、
调用了方法等。这句话不难理解，但它意味着什么呢？我们可以举个例子来说明一下，如代
码清单12-8中所示的这三居伪代码。
     假设线程A中的操作I=1先行发生于B的操作j=i，那么可以确定在线程B的
操作执行后，变量J的值一定等于1，得出这个结论的依据有两个：一是根据先行发生原
则，i=1的结果可以被观察到；二是线程C还没登场，线程A操作结束之后没有其他
线程会修改变量I的值。线程再来考虑线程C，我们依然保持线程A和线程B之间的先行发
生关系，而线程C出现在线程A和线程B的操作之间，但是线程C与线程B没有先行发生
关系，那j的值回事多少呢？答案是不确定，1和2都有可能，因为线程C对变量i的影响
可能会被B观察到，也可能不会，这时候线程B就存在读取到过去数据的风险，不具备
多线程安全性。
    下面是java内存模型下一些天然的先行发生关系，这些先行发生关系无须任何同步
器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法
从下列规则推倒出来的话，他们就没有顺序行保障，虚拟机可以对它们随意地进行重排序。
  程序次序规则program order rule：在一个线程内，按照程序代码顺序，抒写在前
  面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码
  顺序，因为要考虑废纸循环等结构

  管程锁定规则monitor lock rule：一个unlock操作先行发生于后面对同一个锁的
  lock操作。这里必须强调的是同一个锁，而后面是指时间上的先后顺序。
  
  volatile变量规则volatile variable rule：对一个volatile变量的写操作先行发生于
  后面对这个变量的读操作，这里的后面同样是指时间上的先后顺序。
  
  线程启动规则thread start rule：thread对象的start方法先行发生于此线程的每一个动作。
  
  线程终止规则 thread termination rule线程中的所有操作都先行发生于对此线程
   的中指检测，我们可以通过thread。join方法结束、thread.isalive的返回值等后端
   检测到线程已经终止执行。
  
  线程中断规则 thread interruption rule ：对线程interrupt(阻断打扰)方法的调用先行发生于
  被中断线程的代码检测到中断时间的发生，可以通过thread.interrupted方法检测到
  是否有中断发生。
  
  对象终结规则 finalizer rule 一个对象初始化完成 构造函数执行结束 先行
  发生于他的finalize方法的开始。
   
   传递性transitivity 如果操作A先行发生于操作B，操作B先行发生于操作C，
   那就可以得出操作A先行发生于操作C的结论。
   
    java语言无须任何同步手段保障就能成立的先行发生规则就只有上面这些了，笔者演
示一下如何使用这些规则去判定操作间是否具备顺序行，对于读写共享变量的操作来说，就
是线程是否安全，读者还可以从下面这个例子中感受一下时间上的先后顺序与先行发
生之间有什么不同。演示例子如代码清单12-9所示。
      假设存在线程A和
B，线程A先（时间上的先后）调用了setvalue1，然后线程B调用了同一个对象的getvalue，那么线程B收到
的返回值是什么？
     我们依次分析一下先行发生原则中各项规则，由于两个方法分别由线程A和线程B
调用，不在一个线程中，所以程序次序规则在这里不适用；由于没有同步块，自然就不会发
生lock和unlock操作，所以管程锁定规则不适用；由于value变量没有被volatile关键字修
饰，所以volatile变量规则不适用；后面的线程启动、终止、中断规则和对象终结规则也和这
里完全没有关系。因为没有一个使用的先行发生规则，所以最后一条传递性也无从谈起，因
此我们可以判断尽管线程A在操作时间上优于线程B，但是无法确定线程B中getvalue
方法返回结果，换句话说，这里面的操作不是线程安全的。
   那么怎么修复这个问题呢？我们至少有两种比较简单的方案可以选择：要么吧getwet
方法都应以为synchronized方法，这样就可以套用管程锁定的规则；要么吧value定义为
volatile变量，由于getfangfa对value的修改不依赖value的原值，满足volatile关键字使用
场景，这样就可以套用volatile变量规则来实现先行发生关系。
   通过上面的例子，我们可以得出结论：一个操作时间上的先发生不代表这个操作会
是先行发生，那如果一个操作先行发生是否就能推导出这个操作必定是时间上的
先发生呢？很遗憾，这个推论也是不成立的，一个典型的例子就是多次提到的指令重排序
演示例子如代码清单12-10所示。
   代码清单12-10的两条赋值语句在同一个线程之中，根据程序次序规则，inti=1的操
作先行发生于int j=2,但是int j=2的代码完全可能先被处理器执行，这并不影响先行
发生原则的正确性，因为我们在这条线程之中没有办法感知到这点。
   上面两个例子综合起来证明了一个结论：时间先后顺序与先行发生原则之间基本没有
太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行
发生原则为准。
12.4 java与线程
   并发不一定要依赖多线程如PHP中很常见的多进行并发，但是在java里面谈论并发
，大多数都与线程脱不开关系。既然我们这本书探讨的话题是java虚拟机的特性，那讲到
java线程，我们就从java线程在虚拟机中的实现开始讲起。
12.4.1 线程的实现
    我们知道，线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资
源分配和执行调度分开，各个线程既可以共享进程资源内存地址文件io等，有可以独立
调度线程是CPU调度的基本单位
  主流的操作系统都提供了线程实现，java语言则提供了在不同硬件和操作系统平台下对
线程操作的统一处理，每个已经执行start且还未结束的java.lang.thred类的实例就代表了
一个线程。我们注意到thread类与大部分的javaapi有显著的差别，它的所有关键方法都
是生命为native的。在javaapi中一个native方法往往意味着这个方法没有使用或无法
使用平台无关的手段来实现（当然也可能是为了执行效率而使用native方法，不过，通常最
高效率的手段也就是平台相关的手段）。正因为如此，作者吧本节的标题定位线程的实现
而不是java线程的实现。
    实现线程主要有三种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进行
混合实现。

       1.使用内核线程实现
       内核线程kernel-level thread klt 就是直接由操作系统内存 kernel 下称内核
支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器scheduler对线程
进行调用，并负责将线程的任务映射到各个处理器上。每个内存线程可以视为内核的一个分身
，这样操作系统就有能力同事处理多件事情，支持多线程的内核就叫做多线程内核multi-threads kernel
  程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口--轻量级进程
light 光 weight 重量 process 过程 lwp，轻量级进行就是我们通常意义上所讲的进程，由于每个轻
量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进行。这种轻量
级进行与内核线程之间1：1的关系成为1对1的线程模型
  由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使有一个轻量
级进行在系统调用中阻塞了，也不会影响整个进程继续工作，但是轻量级进程具有他的局限性
寿险，由于是基于内核线程实现的，所以各种线程操作，如创建析构（构造函数对立清理工作）以及同步，都需要
进行系统调用。而系统调用的代价相对较高，需要在用户态usermode和内核态kernel mode
中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程
要消耗一定的内核资源如内核线程的占空间，因此一个系统支持轻量级进程的数量是有限的。
   2.使用用户线程实现
   从广义上来讲，一个线程只要不是内核线程，就可以认为是用户线程 user thread ut
因此，从这个定义上来讲，轻量级进程也属于用户线程，但轻量级进程的实现始终是
建立在内核之上的，许多操作都需要进行系统调用，效率会受到限制。
  而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存
在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内存的帮助。
如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，
也可以支持大规模更大的线程数量，部分高性能
数据库中的多线程就是由用户线程实现的。这种
进行与用户线程之间1：n的关系成为1对多的线程模型，

   使用用户线程的优势在于不需要系统内核支援
，掠视也在于没有系统内核的支援，所有的线程操作都需要用户程序自己处理。线程的
创建、切换和调度都是需要考虑的问题，而且由于
操作系统只把处理器资源分配到进程，那诸如阻塞如何处理、多处理器系统中如何
将线程映射到其他处理器上，这类问题解决起来将会异常困难，甚至不可能完成。因而使用
用户线程实现的程序一般都比较复杂，除了以前在不支持多线程的操作系统中dos
的多线程程序与少数有特殊需求的程序外，现在使用用户线程的程序越来越少了，java
ruby等语言都曾经使用过用户线程，最终又都放弃使用它。
   3.使用用户线程加轻量级进程混合实现
   线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用
户线程一起使用的实现方式。在这种混合实现下，及存在用户线程，也存在轻量级进程。用
户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并
且可以支持大规模的用户线程并发。而操作系统提供支持的轻量级进程则作为用户线程和内
核线程之间的桥梁，这样可以使用内核提供的线程调度功能以及处理器映射，并且用户线程的
系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。在这种混合模
式中，用户线程与轻量级进程的数量比是不定的，及为N：m的关系，如图12-5所示，这种
就是多对多的线程模型。
    许多unix系列的操作系统，如solarishpux等都提供了nm的线程模型实现。
  4.java线程的实现
  java线程在jdk1.2之前,是基于称为绿色线程greenthreads的用户线程实现
的,而在jdk1.2中,线程模型替换为基于操作系统原生线程模型来实现.因此,在目前的
jdk版本中,操作系统支持曾阳的线程模型,很大程度上决定了java虚拟机的线程是怎样
映射的,这点在不同的平台上没有办法达成一致,虚拟机规范中也并未限定java线程需要使
用那种线程模型来实现.线程模型只对线程的并发规模和操作成本产生影响,对java程序的
编码和运行过程来说,这些差异都是透明的.
对于sunjdk来说,他的windows版与liux版都是使用一对一的线程模型实现的,
一条java线程就映射到一条轻量级线程之中,因为windows和inux系统提供的线程模型
就是一对一的.
而在solaris平台中,由于操作系统的线程特性可以同时支持一对一,通过bound
threads或alternate libthread实现以及多对多通过lwpthreadbasedsynchfonization
实现的线程模型,因此在solaris版的jdk中也对应提供了两个平台颛臾的虚拟机参数
xxuselwpsynchronization和xx+useboundthreads来明确制定虚拟机
使用那种线程模型.


12.4.2 java线程调度
    线程调度是指系统为线程分配处理器使用权的过程,主要调度方式有两种,分别是协
同式线程调度cooperativethreadsscheduling和抢占式线程调度preemptive threads -schduling
scheduling.
   如果使用协同式调度的多线程系统,线程的执行时间由线程本身来控制,线程把自己的
工作执行完了之后,要主动通知系统切换到另外一个线程上。协同式多线程的最大好处是实
现简答，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可
知的，所以没有什么线程同步的问题。lua语言中的协同例程就是这类实现。它的坏处
也很明显：线程执行时间不可控制，甚至如果一个线程编写有问题，一直不告知系统进行线
程切换，那么程序就会一直阻塞在那里。很久以前windows3.xxitong就是使用协同式来实
现多线程任务的，相当不稳定，一个进程检测不让出cpu执行时间就可能会导致整个系统
崩溃。
   如果使用抢占式调度多线程系统，那么每个线程将由系统来分配执行时间，线程的切
换不由线程本身来觉得在java中 thread.yield可以让出执行时间，但是要获取执行时间
的话，线程本身是没有什么方法的。在这种实现线程调度的方式下，线程的执行时间是系
统可控的，也不会有一个线程导致整个进程阻塞的问题，java使用的线程调度方式就是抢占式
调度。与前面所说的windows2.x的例子相对，在windows9xnt内核中就是使用抢占式
来实现多进程的，当一个进程除了问题，我们还可以使用任务管理器把这个进程傻屌
而不至于导致系统崩溃。
    虽然java线程调度是系统自动完成的，但是我们还是可以建议系统给某些线程多
分配一点执行时间，另外的一些线程则可以少分配一点-这项操作可以通过设置线程优先
级来完成。java语言一共设置了10个级别的线程优先级thread.min_priority至tread。max priority
在两个线程同时处于ready状态时，优先级越高的线程越容易被系统选择
执行。
    不过，优先级并不是太靠谱，原因是java的线程是通过映射到系统的原生线程上来
实现的，所以线程调度最终还是取决于操作系统，虽然现象很多操作系统都提供线程优先级
的概念，但是并不见得与java线程的优先级一一对应，如solaris中有2 32
种优先级，但windows中就只有7中，比java线程优先级多的系统还好说，中间留一下
点空位置就可以了，但比java线程优先级少的系统，就不得不出现几个优先级相同的情况了，
显示了java线程优先级与windows线程优先级之间的对应关系，windows平台的
jdk中使用了除thread priorif有ldle之外的其余6种线程优先级。（一共7个就用6个）
thread priorify idle
 上文说道线程优先级并不是太靠谱，不仅仅是说一些平台上不同的优先级实际会
 变得相同这一点，还有其他情况让我们不能太依赖优先级：优先级可能会被系统自行改变。
 例如，在windwos系统中存在一个成为优先级推进去priority boosting当然它可以被
 关闭掉的功能，它的大志作用就是当系统发现一个线程执行得特别勤奋努力的话，可
 能会越过线程优先级去为它分配执行时间。因此，我们不能在程序中通过优先级来完全准确
 地判断一组状态都为ready的线程将会先执行那一个。
 
 12.4.3 状态转换 383
  Java语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种
状态，这5中状态分别如下。
  新建new:创建后尚未启动的线程处于这种状态
  
  运行runnable:runnable包括了操作系统线程状态中的running和ready，也就是
  处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。
  
   无限期等待waiting：处于这种状态的线程不会被分配CPU执行时间，他们要等待
   被其他线程显示的唤醒。以下方法会让线程先入无限期等待的状态：
     没有设置timeout参数的object.wait方法
     没有设置timeout参数的thread.join方法。
     locksupport.park()方法

    限期等待timed waiting ：处于这种状态的线程也不会被分配CPU执行时间，不过
    无须等待被其他线程显示地唤醒，在一定时间之后它们会由系统自动唤醒。以下方法
    会让线程进入限期等待状态：
       thread.sleep方法
       设置了timeout参数的object.wait方法
       设置了timeout翻书的thread。join方法。
       LockSupport.parkNanos方法
       LockSupport.parkUntils方法

     阻塞blocked 线程被阻塞了，阻塞状态与等待状态的区别是:阻塞状态 synchronized
     在等待着获取到一个排他锁，这是事件将在另外一个线程放弃这个锁的时候发生；而
     等待状态则是在等待一段时间，
     或者唤醒动作发生。在程序等待
     进入同步区域的时候，线程将进入这种状态。
    
    结束terminated :已终止线程的线程状态，线程已经结束执行。
    
    上述5种状态在遇到特定事件发生的时候将会互相转换，他们的转换关系如图所示。
    
    12.5本章小结
    本章中，我们首先了解了虚拟机java内存模型的结构以及操作，然后讲解了原子性、可见性
、有序性在java内存模型中的体现，最后介绍了先行发生原则的规则以及使用。另外，我们
还了解了线程在java语言之中是如何实现的。
   关于高效并发这个话题，在本章中主要介绍了虚拟机如何实现并发，在第13章
中，我们的主要关注点将是虚拟机如何实现高效，以及虚拟机对我们编写的并发代码提
供了什么样的优化手段。




 

ByteBuffer(direct 、heap)

I.直接内存direct memory

https://www.cnblogs.com/stevenczp/p/7506280.html
https://blog.csdn.net/weixin_34198797/article/details/85833303
https://www.cnblogs.com/czwbig/p/11127124.html
https://www.cnblogs.com/duanxz/p/6089485.html


ByteBuffer的源码中有这样一段注释：

 A byte buffer is either direct or non-direct. Given a direct byte buffer, the Java virtual machine will make a best effort to perform native I/O operations directly upon it. That is, it will attempt to avoid copying the buffer's content to (or from) an intermediate buffer before (or after) each invocation of one of the underlying operating system's native I/O operations.
大概意思是说ByteBuffer分为direct与heap两种，如果使用direct版本的ByteBuffer，JVM会尽可能的直接在这个ByteBuffer上做IO操作。从而省去了将数据在中间buffer上来回复制带来的开销。
看到这里你当然是一头雾水了，不过不要慌，本文会详尽的分析direct memory与IO之间的关系。

**进程的用户地址空间可以被分成两份：**  
JVM数据区 + direct memory。

ByteBuffer.allocateDirect()方法的调用流程：

base = unsafe.allocateMemory(size);//申请内存
unsafe.setMemory(base, size, (byte) 0);//初始化内存

Unsafe的实际实现位于src/share/vm/prims/unsafe.cpp

http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/prims/unsafe.cpp#l583
http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/prims/unsafe.cpp#l629

direct memory，其实就跟一般的c语言编程里一样，是直接用malloc方法申请的。
JVM会将malloc方法的返回值（申请到的内存空间的首地址）转换成long类型的address变量，然后返还给Java应用程序。
Java应用程序在需要操作direct memory的时候，会调用native方法将address传给JVM，然后JVM就能对这块内存为所欲为了。

3. Java应用程序是如何访问direct memory的？
以DirectByteBuffer.get()方法为例

4. 为什么说direct memory更加适合IO操作？

因为在JVM层面来看，所谓的direct memory就是在进程空间中申请的一段内存，而且指向direct memory的指针是固定不变的，因此可以直接用direct memory作为参数来执行各种系统调用，比方说read/pread/mmap等。
而为什么heap memory不能直接用于系统IO呢，因为GC会移动heap memory里的对象的位置。如果强行用heap memory来搞系统IO的话，IO操作的中途出现的GC会导致缓冲区位置移动，然后程序就跑飞了。
除非采用一定的手段将这个对象pin住，但是hotspot不提供单个对象层面的object pinning，一定要pin的话就只能暂时禁用gc了，也就是把整个Java堆都给pin住，这显然代价太高了。
总结一下就是：heap memory不可能直接用于系统IO，数据只能先读到direct memory里去，然后再复制到heap memory。






**Direct Memory的回收机制 ：**
Direct Memory是受GC控制的，例如ByteBuffer bb = ByteBuffer.allocateDirect(1024)，这段代码的执行会在堆外占用1k的内存
，Java堆内只会占用一个对象的指针引用的大小，堆外的这1k的空间只有当bb对象被回收时，才会被回收，
这里会发现一个明显的不对称现象，就是堆外可能占用了很多，而堆内没占用多少，导致还没触发GC，
那就很容易出现Direct Memory造成物理内存耗光。



ByteBuffer(direct 、heap)




**正确释放Unsafe分配的堆外内存**

覆盖了finalize方法，手动释放分配的堆外内存。如果堆中的对象被回收，那么相应的也会释放占用的堆外内存。这里有一点需要注意下：

unsafe.freeMemory(address);

public class RevisedObjectInHeap
{
private long address = 0;
	private Unsafe unsafe = GetUsafeInstance.getUnsafeInstance();
	// 让对象占用堆内存,触发[Full GC
	private byte[] bytes = null;
	public RevisedObjectInHeap()
	{	address = unsafe.allocateMemory(2 * 1024 * 1024);
		bytes = new byte[1024 * 1024];
	}
	@Override
	protected void finalize() throws Throwable
	{		super.finalize();
		System.out.println("finalize." + bytes.length);
		unsafe.freeMemory(address);
	}
}





























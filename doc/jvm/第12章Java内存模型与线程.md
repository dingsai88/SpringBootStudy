
第12章 Java内存模型与线程
   并发处理的广泛应用是使得amdahl定律代替默认定律成为计算机性能发展源动力的根
本原因，也是人类压榨计算机运算能力的最有力武器。

12.1概述
    多任务处理在现代计算机操作系统中几乎已是一项必备的功能了。在许多情况下，让
计算机同时去做几件事情，不仅是因为计算机的运算能力强大了，还有一个很重要的原因是
计算机的运算速度与它的存储和通信子系统速度的差距太大，大量的时间都花费在磁盘I/O、
网络通信或数据库访问上。如果不希望处理器在大部分时间里都处于等待其他资源的状
态，就必须使用一些手段去把处理的运算能力“压榨”出来，否则就会造成很大的浪费，
而让计算机同事处理机箱任务则是最容易想到、也被证明是非常有效的压榨手段。
    除了充分利用计算机处理器的能力外，一个服务端同时对多个客户端提供服务则是两一个
更具体的并发应用场景。衡量一个服务性能的高低好坏，每秒事务处理数transactions
per second tps是最重要的性能指标之一，它代表着1秒内服务端平均能响应的请求总数，而
TPS值与程序的并发能力又有非常密切的关系。对于计算量相同的任务，程序线程并发协调
得越有条不紊，效率自然就会越高；反之线程之间频繁阻塞甚至死锁，将会大大降低程序
的并发能力。
   服务端是java语言最擅长的领域之一，这个领域的应用占了java应用中最大的一块份
额，不过如何写好并发应用程序却又是服务端程序开发的难点之一，处理好并发方面的问
题通常需要更多的编码经验来支持。幸好java语言和虚拟机提供了许多工具，把并发编程
的门槛降低了不少。并且各种中间件服务器、各类框架都努力地替程序员处理尽可能多的线
程并发细节，使得程序员在编码时能更关注业务逻辑，而不是划分大部分时间去关注此服务
会同时被多少人调用、如何协调硬件资源。无论语言、中间件和框架如何先进，开发人员都
不能期望它们能独立完成所有并发处理的事情，了解并发的内部也是成为一个高级程序员不
可缺少的课程。
   高效开发是本书讲解java虚拟机的最后一部分，将会向读者介绍虚拟机如何实现多
线程、多线程之间由与共享和竞争数据而导致的一系列问题及解决方案。

12.2 硬件的效率与一致性
   在正式讲解虚拟机并发相关的知识之前，我们先花费一点时间去了解一下屋里计算
机中的并发问题，物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发
的处理方案对于虚拟机的实现也有相当打的参考意义。
   让计算机并发执行若干个运算任务与更充分地利用计算机处理器的效能之间的
因果关系，看起来顺利成章，实际上并没有想象中的那么简单，其中一个重
要的复杂性来源是绝大多数的运算任务都不可能只靠处理器计算就能完成，处理器至少
要与内存交互，如读取运算数据、存储运算结果等，这个IO操作是很难消除的（无法仅靠
寄存器来完成所有的运算任务）。由于计算机的存储设备与处理器的运算速度的高速缓
存cache来座位内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让
运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内
存读写了。
    基于告诉缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统
带来更高的复杂度，因为它引入了一个新的问题：缓存一致性cachecoherence。在多处
理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主内存main memory
如图12-1所示。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的
缓存数据不一致，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为
了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来
进行操作，这类协议有MSImesimosi
protocol等。在本章中将会多次提到的内存模型一词，可以理解为在特定的操作协议下，
对特定的内存或告诉缓存进行读写访问的过程抽象。不同架构的物理机器可以拥有不一样的
内存模型，而java虚拟机也有自己的内存模型，并这里介绍的内存方位操作与硬件的缓存
访问操作具有很高的可比性。


   除了增加高速缓存之外，为了使得处理器内部的运算单元能尽管被充分利用，处理器
可能会对输入代码进行乱序执行outoforderexecution优化，处理器会在计算之后将乱
序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计
算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务以来另外一个计算任
务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类
似，java虚拟机的即时编译器中也有类似的指令重排序instruction reorder 优化。
12.3 java内存模型
   java虚拟机规范中试图定义一种java内存模型java memory model jmm来屏蔽
掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的
内存访问效果。再次之前，主流程序语言直接使用武力硬件和操作系统的
内存模型，因此，会由不同平台上内存模型的差异，有可能导致程序在一套平台上并发完
全正常，而在另外一套平台上并发访问却经常出错，因此在某些场景就必须针对不同平台
来编写程序。
   定义java内存模型并非一件容易的事情，这个模型必须定义得足够严谨，才能让java
的并发内存访问操作不会产生歧义：但是，也必须定义得足够宽松，使得虚拟机的实现有
足够的自有空间去立勇硬件的各种特性（寄存器、高速缓存和指令集中某些特有的指令）来
获取更好的执行速度。经过长时间的验证和修补，在jdk1.5实现了JSR-133发布后，
java内存模型已经成熟和完善起来了。
12.3.1主内存与工作内存
   java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储
到内存和从内存中取出变量这样的底层细节。此处的变量variables与java变成中所说的
变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与
方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得教
好的执行效能，java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主
内进行交互，也没有限制即时编译器调整代码顺序这类优化措施。
   java内存模型规定了所有的变量都存储在?主内存mainmemory中此处的主内存
与介绍物理硬件时的主内存名字一样，两种也可以互相类比，但此处仅是虚拟机内存的
部分。每个线程还有自己的工作内存workingmemor可与前面讲的处理器告诉缓存类
比，线程的工作内存中报错了被该线程使用到的变量的内存副本拷贝，线程对变量的所
有操作读取赋值等都必须在工作内存中进行，而不能直接读写主内存中的变量。不
同的线程之间也无法直接访问对象工作内存中的变量，线程间变量值的传递均需要通过主内存来完成
，线程、主内存、工作内存散着的交互关系如图
    这里所讲的主内存、工作内存与本书第2张所讲的内存区域中的java堆栈方
法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对
应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于java堆中的对象实例
数据部分，儿工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，住内存就直接
对应屋里硬件的内存，而为了获取更好的运行速度，虚拟机设置是硬件系统本身的优化措施
可能会让工作内存优先存储寄存器和高速缓存中，因为程序运行时主要访问读写的
是工作内存。
12.3.2 内存间交互操作
    关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存
、如何从工作内存同步回主内存之类的实现细节,java内存模型中定义了以下8中操作来完
成、虚拟机实现时必须保证下面提及的每一宗操作都是原子的、不可再分的对于double和
long类型的变量来说，loadstroereadwrite操作在某些平台上允许有例外，这个问题在
12.3.4节再讲。
   lock锁定：作用于主内存的变量，它把一个变量标示为一条线程独占的状态。
   unlock解锁：作用域主内存的变量，他把一个处于锁定状态的变量释放出来，
   释放后的变量才可以被其他线程锁定。
   read读取：作用域主内存的变量，他把一个变量的值从主内存传输到线程的工作
   内存中，以便随后的load动作使用。
   load载入:作用域工作内存的变量,它把read操作从主内存中得到的变量值放入
   工作内存的变量副本中.
   use使用:作用域工作内存的变量,它把工作内存中一个变量的值传递给执行引擎,
   每当虚拟机遇到一个需要使用到变量的值得字节码指令时会执行这个操作.
   assign赋值:作用于工作内存的变量,它把一个从执行引擎接受到的值赋给工作
   内存的变量,每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作.
   store存储:作用于工作内存的变量,它把工作内存中一个变量的值传送到住内存
   中,以便随后的write操作使用.
    write写入:作用于主内存的变量,它把store操作从工作内存中得到的变量的值放
    入主内存的变量中.
    
    如果要把一个变量从主内存复制到工作内存,那就要顺序地执行read和load操作,如
    果要把变量从工作内存同步回主内存,就要顺序地执行storewrite啊哦做.注意,java内存
    模型只要求上述两个操作必须按顺序执行,如对主内存中的变量ab进行访问时,一种
    可能出现顺序是read啊readbload不load啊除此之外,java内存模型还规定了在执行上
    8种基本操作时必须满足如下规则:
    不允许read和loadstore和write操作之一单独出现,即不允许一个变量从猪内存读
    取了但工作内存不接受,或者从工作内存发起回写了但主内存不接受的情况出现.
    不允许一个线程丢弃它的最近assign操作,即变量在工作内存中改变了之后必须把
    改变或同步回主内存.
    不允许一个线程无原因地,没有发生过任何assign操作把数据从线程的工作内存同步
    回主内存zhong
    一个新的变量只能在主内存中诞生,不允许在工作内存中直接使用一个未被初始化
    laodassign的变量,换句话说,就是对一个变量实时usestore操作之前,
    必须先执行过了assign和load操作.
    一个变量在同一个时刻只允许一条线程对其进行lock操作但loack操作可以被同一条
    线程重复执行多次,多次执行lock后,只有执行相同次数的unloack操作,变量才会
    被解锁.
    如果对一个变量执行lock操作,那将会清空工作内存中此变量的值,在执行引擎使
    用这个变量强,需要重新执行load或assign操作初始化变量的值.
    如果一个变量事先没有被lock操作锁定,那就不允许对他执行unlock操作,也不允
    许去unlock一个被其他线程锁定住的变量.
    对一个变量执行unlock操作之前,必须先把此变量同步回主内存中执行sotrewrite
    操作.
    这8种内存访问操作以及上述规则限定,再加上稍后介绍的对volatile的一些特殊规定,
就已经完全确定了java程序中那些内存访问操作在并发下是安全的.由于这种定义相当严谨
但又是否烦琐,实践起来很麻烦,所以在12.3.6节中笔者将介绍这种定义的一个等效判断原
则先行发生原则,用来确定一个访问在并发环境下是否安全.

12.3.3 对于volatile(不稳定)型变量的特殊规则
    关键字volatile可以说是java虚拟机提供的最轻量级的同步机制,但是它并不容易完全
被正确\完整地理解,以至于许多程序员都习惯不去使用它,遇到需要处理多线程数据竞争
问题的时候一律使用synchronized来进行同步.了解volatile变量的语义对后面了解多线程
操作的其他特性很有意义,在本节中我们将多花费一些时间去弄清楚volatile的语义到底是
什么.
   java内存模型对volatile专门定义了一些特殊的访问规则,在介绍这些比较绕口的规则
定义之前,笔者先用不那么正式但通俗易懂的语言来介绍一下这个关键字的作用.
   当一个变量定义为volatile之后,他将具备两种特性,第一是保证此变量对所有线程的
可见性,这里的可见性是指当一条线程修改了这个变量的值,新值对于其他线程来说是
可以立即的值的.而普通变量不能做到这一点,普通变量的值在线程间传递均需要通过主内存
来完成,例如,线程A修改一个普通变量的值,然后向主内存进行回写,另外一条线程B
在线程A回写完成了之后再从主内存进行读取操作,新变量值才会对线程B可见.
   关于volatile变量的可见性,经常会被开发人员误解,认为以下描述成立:volatile变量
对所有线程是立即可见的,对volatile变量所有的写操作都能立即反应到其他线程之中,换句话说
,volatile变量在各个线程中是一致的,所以基于volatile变量的运算在并发
下是安全的.这句话的论据部分并没有错,但是其论据并不能得出基于volatile变量的运算在并发
下是安全的这个结论.volatile变量也可以存在不一致的问题(在各个线
程的工作内存中,volatile变量也可以存在不一致的情况,但由于每次使用之前都要先刷新,
执行引擎看不到不一致的情况,因此可以认为不存在一致性问题),但是java里面的运算并
非原子操作,导致volatile变量的运算在并发下一样是不安全的,我们可以通过一段简单的
演示来说明原因,请看代码清单12-1中演示的例子.
  这段代码发起了20个线程，每个线程对race变量进行10000次自增操作，如果这段代
码能够正确并发的话，最后输出的结果应该是200000.读者运行完这段代码之后，并不会获得
期望的结果,而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的
数字，这是为什么呢？

    问题就出现在自增运算race++之中，我们用于javap反编译这段代码后会得到代码清单
12-2 发现只有一行代码increase方法在class文件中由4条字节码指令构成的
return指令不是由race++产生的，这条指令可以不计算，从字节码层面上很容易就分析出
并发失败的原因了：当getstatic指令吧race的值渠道操作栈顶时，volatile关键字保证了race
的值在此时是正确的，但是在执行inconst——1iadd这些指令的时候，其他线程可能已经把race
的值加大了，而在操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能吧较
小的race值同步回主内存之中。
    客观的说，笔者在此使用字节码来分析并发问题，仍然是不严谨的，因为即使编译出来
只有一条字节码指令，也并不意味执行这条指令就是一个原子操作。一条字节码指令在解释
执行时，解释器将要运行许多行代码才能实现它的语义，如果是编译执行，一条字节码指令
也可能转化成若干条本地机器码指令，此处使用-xxprintassembly参数输出反汇编来分析 -XX+PrintAssembly
会更加严谨一些，但考虑到读者阅读的方便，并且字节码已经能说明问题，





    
    
    
    
    
    
    
    





















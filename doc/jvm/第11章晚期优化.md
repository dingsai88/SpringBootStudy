# 第10章（编译期）优化

   从计算机程序出现的第一天起，对效率的追求就是程序天生的坚定信仰，这个过程犹如一

场没有终点、永不停歇的F1方程式竞赛，程序员是车手，技术平台则是在赛道上飞车的赛车。

##### 10.1概述302

  java语言的编译期其实是一段不确定的操作过程，因为它可能是指一个前端编译

器（其实叫编译器的前端更准确一些）吧java文件转变成。class文件的过程；也可能是

指虚拟机的后端运行期编译器（jit编译器，justintime compiler）吧字节码转变成机器码的

过程；还可能是指使用静态提前编译器（AOT编译器，ahead of time compiler） 直接把*java

文件编译成本地机器代码的过程。下面列举了这三类编译过程中一些比较有代表性的编译器。

前端编译器:sum的javac、eclipsejdt中的增量式编译器ECJ

JIT编译器:hotspotVM的c1、c2编译器。

AOT编译器:GUN compiler for the javaGCJ ExcelsiorJET

​     这三类过程中最符合大家对java程序编译认知的应该是第一类，在本章的后续文字里，

笔者提到的编译期和编译器都仅限于第一类编译过程，把第二类编译过程留到下一

章中讨论。限制了编译范围后，我们对于优化二字的定义就需要宽松一些，因为javac

这类编译器对代码的运行效率几乎没有任何优化措施（在jdk1.3以后，javac的-O优化参

数就不再有意义）。虚拟机设计团队把对性能的优化集中到了后端的即时编译器重，这样可

以让那些不是由javac产生的class文件（如jruby\groovy等语言的class文件）也同样能

享受到编译器优化所带来的好处。但是javac做了许多针对java语言编码过程的优化错误来

改善程序员的编码风格和提高编码效率。相当多新生的java语法特性，都是靠编译器的语

法糖来实现，儿不是依赖虚拟机的底层改进来支持，可以说，java中即时编译器在运行期

的优化过程对于程序运行来说更重要，而前端编译器在编译期的优化过程对于程序编码来说

关系更加密切。



#### 10.2.2 解析与填充符号表

  解析步骤由图

- 准备过程：初始化插入式注解处理器
- I.解析与填充符号表-----------parseFiles
- 过程1.1：词法分析、语法分析
- 过程1.2：输入到符号表
- II.注解处理器-----------
- 过程2：执行注解处理
- III.语义分析与字节码生成------------
- 过程3：分析及字节码生成
- 过程3.1：标注
- 过程3.2：数据流分析
- 过程3.3：解语法糖
- 过程3.4：生成字节码

10.2.2解析与填充符号表

  解析步骤由图10-5中的parseFiles()方法(图10-5中的过程1.1)完成，解析步骤包括

了经典程序编译原理中的词法分析和语法分析两个过程。

 1.词法分析、语法分析

词法分析是将源代码的字符流转变为标记token即可，单个字符是编写过程的

最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为

标记，如int a=b+2这句代码包含了6个标记，分别是inta=b+2，虽然关键字

int由3个字符构成，但是它只是一个token，不可再拆分。在javac的源码中，词法分析过程

由com.sun.tools.javac.parser.Scanner类来实现。

​     语法分析是根据token序列构造抽象语法树的过程，抽象语法树abstract syntax tree ast

是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程

序代码中的一个语法结构construct例如包、类型、修饰符、运算符、接口、返回值甚

至代码注释等都可以是一个语法结构。

   图10-6 是根据elcipse ast view插件分析出来的某段代码的抽象语法树视图，读者可以

通过这张图对抽象语法树有一个直观的认识。在javac的源码中，语法分析过程由com.sun.

tools.javac.parser.parser类实现，这个阶段产出的抽象语法树由com.sun.tools.javac.treejctree

类表示，经过这个步骤之后，编译器就基本不会再对源码文件进行操作了，后续的操作都建

立在抽象语法树之上。

######    2.填充符号表

​     完成了语法分析和词法分析之后，下一步就是填充符号表的过程，也就是图10-5中

enterTrees方法所做的事情。符号表symbol table是由一组符号地址

和符号信息构成的表格，读者可以吧它想象成哈希表中k-v值对的形式实际上符

号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等。符号表中

所登记的信息在编译的不同阶段都要用到。在语义分析中，符号表所登记的内容将用于语义检查（如检查一个名字的使用和原先的说明是否一致）和产生中间代码。在目标代码生成阶

段，当对符号名进行地质分配时，符号表是地址分配的依据。

​    在javac源代码中，填充符号表的过程由com.sun.tools.java.comp.Enter类实现。此过程

的出口是一个待处理列表，包含了每一个编译单元的抽象语法树的顶级节点，

以及package-info的顶级节点。

#### 10.2.3 注解处理器

​    在jdk1.5之后，java语言提供了对注解annotation的支持，这些注解与普通的

java代码一样，是在运行期间发挥作用的。在jdk1.6中实现了jsr-269规范，提供了一组

出入式注解处理器的标准api在编译期间对注解进行处理，我们可以把它看做是一组编译器

的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件

在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直

到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个round，也

就是图10-4中的回环过程。

​    有了编译器注解处理的标准API后，我们的代码才有可能干涉编译器的行为，由于语法树

中的任意元素，设置包括代码注释都可以在插件之中访问到，所以通过插入值注解处理器实现的

插件在功能上有很大的发挥空间。只要有足够的创意，程序员可以使用插入式注解处理器实现

许多远门只能在编码中完成的事情，本章最后会给出一个使用插入式注解处理器的简单实战。

​       在javac源码中，插入式注解处理器的初始化过程是在initPorcessAnnotations()方

法中完成的，而它的执行过程则是在processAnnotations()方法中完成的，这个方法判

断是否还有新的注解处理器需要执行，如果有的话，通过com.sun.tools.javac.processing.

javaProcessingEnvironment里的doProcessing方法生成一个新的javaCompiler对象对编译

的后续步骤进行处理。

#### 10.2.4 语义分析与字节码生成

​    语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确

的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是对结构上正确

的源程序进行上下文有关的性质的审查，如进行类型审查。举个例子，假设有如下的三个变量

定义语句：

  int a=1;

boolean b=false;

char c=2;

后续可能出现的赋值运算：

int d=a+c;

int d=b+c;

char d=a+c;

后续代码中如果出现了如上三种赋值运算的话，那它们都能构成结构正确的语法树，但

是只有第一种的写法在语义上是没有问题的，能够通过编译，其余两种在java语言中是不合

逻辑的，无法编译(是否合乎语义逻辑必须限定在具体的语言与具体的上下文环境之中才有

意义。如在C语言中，a\b\c的上下文定义不变，第2、3种写法都是ikeyi正确编译)。

  1.标注检查

  javac的编译过程中，语义分析过程分为标注检查以及数据及控制流分析两个步骤，分别

由图10-5中所示的attribute和flow方法（分别对应图10-5中的过程3.1和过程3.2）完成。

​    标注检查步骤检查的内容包括诸如变量使用前是否已经被声明、变量与复制直接的数据类

型是否能够匹配等。在标注检查步骤中，还有一个重要的动作称为常量折叠，如果我们在代

码中写了如下定义：

  int a=1+2;

那么在语法树上仍然能看到字面量“1”，“2”以及操作符“+”，但是在经过常量折叠之后，他们将会被折叠为字面量3，如图10-7所示，这个插入式表达

式infix expression的值已经在语法树上标注出来了

（constantExpressionValue:3）。由于编译期间进

行了常量折叠，所以在代码里面定义“a=1+2”比起

直接定义"a=3",并不会增加程序运行期哪怕仅仅

一个CPU指令的运算。

  标注检查步骤在javac源码中的实现类是com.

sun.tools.javac.comp.Attr类和com.sun.tools.javac.comp.Check 类。

###### 2.数据以及控制类分析

数据以及控制类分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变

量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的的受查异常都被正确处理里等问题。编译事情的数据以及控制流分析与类加载时的数据以及控制类分析的目的基本上是一致的，但是校验范围有所区别，有一些校验项只有在编译期或运行期才能进行。下面举一个关于final修饰符的数据以及控制类分析的离职，见代码清单10-1.

public void foo(final int arg){

​    final int var=0;

//do somthing

}

public void foo(int arg){

   int var=0;

//do something

}

  在这两个foo（）方法中，第一种方法的参数和局部变量定义使用了final修饰符，而第

二种方法则没有，在代码编写时程序肯定会受到final修饰符的影响，不能再改变arg和var

变量的值，但是在两段代码编译器出来的class文件是没有任何一点区别的，通过第六章的讲

解我们已经知道，局部变量与字段（实例变量，类变量）是有区别的，它在常量池中没有

CONSTANT——fielref_inf的符号引用，自然就没有访问标志access_flags的信息,设置

可能连名称都不会保留下来（取决于编译时的选项），自然在class文件中不可能知道一个局

部比那里是不是声明为final了，因此，将局部变量声明为final，对于运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保障。在javac的源码中，数据以及控制类分析的入口是

图10-5中的flow方法com.sun.tools.javac.comp.Flow类来完成。

3.解语法糖

语法糖（Syntactic sugar）,也称为糖衣语法，是由英国计算机科学家彼得。约翰、兰大

peter j.landin发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能

并没有影响，但是更方便程序员使用。通常来说，使用语法糖能够增加程序的可读性，从而

减少程序代码出错的机会。

​     Java在现代编程语言之中属于“低糖语言”（相对于C#以及许多其他JVM语言来说），尤

其是JDK1.5之前的版本，“低糖”语法也是java语言被怀疑已经“落后”的一个表面理由。

java中最常用的语法糖主要是前面提到过的泛型（泛型并不一定都是语法糖实现，如C#的

泛型就是直接由CLR支持的）、变长参数、自动装箱、拆箱等，虚拟机运行时不支持这些语

法，它们在编译阶段还原回简单的基础语法结构，这个过程称为语法糖。java的这些语法

糖被接触后是什么样子，将在10.3节中详细讲述。

   在javac的源码中，解语法糖的过程由desugar方法触发，在com.sun.tools。javac。comp.TransTypes类和com.sun.tools.javac.comp.Lower类中完成。

###### 4.字节码生成

 字节码生产是javac编译过程的最后一个阶段，在javac源码里面由com.sun.tools.javac.

jvm.Gen类来完成。字节码生成阶段不仅仅是吧前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。

例如，前面章节中多次提到的实例构造器《init》方法和类构造器<clinit>方法就是

在这个阶段添加到语法树之中的（注意，这里的实力构造器并不是指默认构造函数，如果

用户代码中没有提供任何构造函数，这个工作在填充符号表阶段就已经完

成），这两个构造器的产生过程实际上是一个代码收敛的过程，编译器会把语句块（对于实

例构造器而言是｛｝块，对于类构造器而言是static块）、变量初始化（实例变量

和类变量）、调用父类的实力构造器（仅仅是实例构造器，《clinit》方法中经常会生成

调用java.lang.object的init方法的代码）等操作瘦脸到init和clinit方法之

中，并且保证一定是按照先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序

进行，上面所述的动作由Gen.normalizeDefs方法来实现。除了生产构造器以外，还有其他

的一些代码替换工作用语优化程序的实现逻辑，如吧字符串的加操作替换为stringbuffer或

stringbuilder取决于目标代码的版本是否大于等于1.5的appedn操作等。

##### 10.3 Java语法糖的味道

   几乎各种语言或多或少都提供过一些语法糖来方便程序员的代码开发，这些语法糖虽

然不会提供实质性的功能改进，但是他们或能提高效率，或能提升语法的严谨性，或能减少

编码出错的机会。不过也有一种观点认为语法糖并不一定都是有益的，大量添加和使用含糖

的语法，容易让程序员产生依赖，无法看清语法糖并不一定都是有益的，成

##### 10.3.1 泛型与类型擦除

​    泛型是JDK1.5的一项新增特性，它的本质是参数化类型parametersized type 的应

用，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法

的创建中，分别称为泛型类，泛型接口和泛型方法。

   泛型思想早在C++语言的模版template中就开始生根发芽，在java语言处于还没

有出现泛型的版本时，只能通过Object是所有类型的父类和类型强制转换两个特点的配合来

实现类型泛华。例如，在哈利表的存取中

·	······

  当初JDK设计团队为什么选择类型擦除的方式来实现java语言的反省支持呢，是因为

实现简单、兼容性考虑还是别的原因？我们已不得而知，但确实有不少人对java语言提供的

伪泛型颇有微词，当时甚至连thinking in java一书的作者bruce eckel也发飙了一篇文章

这不是泛型来批评jdk1.5中的泛型实现。

​    当时众多的批评之中，有一些是比较表面的，还有一些从性能上说泛型会由于强制转型

操作和运行期缺少针对类型的优化等从而导致比C#的泛型慢一些，则是完全偏离了方向，则是完全偏离了方向，姑且不论java泛型是不是真的会比C#泛型慢，选择从性能的角度上评价用于提升语义准确性的

泛型思想就不太恰当。但笔者也并非在为java的泛型辩护，它在某些场景下确实存在不足，

笔者认为通过擦除法来实现泛型丧失了一些泛型思想应用的优化，例如代码清单10-4的例子。

   请想一想，上面这段代码是否正确,能否编译执行？也许你已经有答案，这段代码是

不能被编译的，因为参数list integer和liststring编译之后都被擦除了，变成了一样的

原生类型LIST，擦除动作导致这两种方法的特征签名变得一模一样。初步看来，无法重

载的原因已经找到了，但真的就是如此吗？只能说，泛型擦除成相同的原生类型只是无法重

载的其中一部分原因，请再接着看一看代码清单内容



差别是两个method方法添加了不同的返回值，由于这

两个返回值的家人，方法重载居然成功了，即这段代码可以被编译和执行了。这是对java

语言中返回值不参与重载选择的基本认知的挑战吗?

  代码清单10-5中的重载当然不是根据返回值来确定的，之所以这次能编译和执行成功，

是因为两个method方法加入了不同的返回值后才能共存在一个class文件之中。第六章介

绍class文件方法表methodinfo的数据结构时曾经提到过，方法重载要求方法具备不同

的特征前面，返回值并不包含在方法的特征前面之中，所以返回值不参与重载选择，但是在

class文件格式之中，只要描述符不是完全一直的两个方法就可以共存。也就是说，两个方

法如果有相同的名称和特征签名，但返回值不同，那他们也是可以何方地工作在于一个class

文件中的。

​    由于java泛型的引入，各种场景虚拟机解析反射等下的方法调用都可能对原有的

基础产生影响和新的需求，如在泛型类中如何获取传入的参数和类型等。因此JCP组织对

虚拟机规范做出了响应的修改，引入诸如signature、localVariableTypeTable等新的属性用

于解决伴随泛型而来的参数类型的识别问题，signatrue是其中最重要的一项属性，他的作用

就是存储一个方法在字节码层面的特征签名，这个属性中报错的参数类型并不是原生类型，

而是包括了参数化类型的信息。修改后的虚拟机规范要求所有能识别49以上版本的class

文件的虚拟机都要能正确地识别signatrue参数。  

​    从上面的例子可以看到擦除法对实际编码带来的影响，由于list string和list integer

擦除后是同一个类型，我们只能添加两个并不需要实际使用到的返回值才能完成

重载，这是一种毫无优化和美感可言的解决方案，并且存在一定语义上的混乱，譬如上面

脚注中提到的，必须用SUNJDK1.6的javac才能编译通过，其他版本或者ECJ编译器都可

能拒绝编译。

​     另外，从Signature属性的出现我们还可以得出结论，擦除法所谓的擦除，紧紧是对方法的

code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能

通过反射手段取得参数和类型的根本依据。

##### 10.3.2  自动装箱、拆箱与遍历循环

​    从纯技术的角度来讲，自动装箱、自动拆箱与遍历循环foreach循环这些语法糖，无论

是实现上还是思想上都不能和上文介绍的泛型相比，两者的难度和深度都有很大差距。专门拿出

一届来讲解他们只有一个理由“毫无疑问”，他们是java语言里使用的最多的语法糖。我们通过

代码清单10-6和代码清单10-7中所示的代码来看这些语法糖在编译后会发生什么样的变化

​    代码清单10-6中一共包含了泛型、自动装箱、自动拆箱、遍历循环与变长参数5种语

法糖，代码清单10-7则展示了他们在编译后的变化。泛型就不比说了，自动装箱、拆箱在编

译之后被转换成了对应的包装和还原方法，如本例中的integer.valueOf与integer.iniValue

方法，而遍历循环则吧代码还原成了迭代器的实现，这也是为何遍历循环需要被遍历的类实

现iterable接口的原因。最后再看看变长参数，它在调用的时候变成了一个数组类型的参数，

在变长参数出现之前，程序员就是使用数组来完成类似功能的。

这些语法糖虽然看起来很简单，但也不见得就没有任何值得我们注意的地方，代码清单

10-8演示了自动装箱的一些错误用法。

这两个问题的答案可以很容易试验出来，

笔者就暂且略去答案，希望读者自己上机实践一下。无论读者的回答是正确，鉴于

包装类的==运算在不遇到算数运算的情况下不会自动拆箱，以及它们equals方法不处

理数据转型的关系，笔者建议在实际编码中进来避免这样使用自动装箱与拆箱。

##### 10.3.3 条件编译

   许多程序设计语言都提供了条件编译的途径，如C、C++中使用预处理器指示符

#ifdef来完成条件编译。C、C++的预处理器最初的任务是解决编译时的代码依赖关系（如

非常常用的#include预处理命令），而在java语言之中并没有使用预处理器，因为java语言

天热的编译方式（编译器并非一个各地编译java文件，而是将所有编译单元的语法树顶级节点

输入到待处理列表后再进行斌阿姨，因此各个文件之间能够互相提供符号信息）无须使用预

处理器。那java语言是否有版本实现条件编译呢？

​     Java语言当然也可以进行条件编译，方法就是使用条件为常量的if语句。如代码清单10-9

所示，此代码中的if语句不同于其他java代码，它在编译阶段就会被运行，生成的字节码

之中只包括system.out.printlnblock1 一条语句，并不会包含if语句以及另外一个分子中的

system.out.println block2



​      只能使用条件为常量的if语句才能达到上述效果，如果使用常量与其他带有条件判断能

力的语句搭配，则可能在控制类分析中提示错误，被拒绝编译。



​       java语言中条件编译的实现,也是java语言的一颗语法糖，根据布尔常量值的真假，

编译器将会吧分支中不成立的代码块消除掉，这一工作将在编译器接触语法糖阶段（com.sun.tools.javac.comp.Lower类中）完成。由于这种条件编译的实现方式使用了if语句，所以

它必须遵守最基本的java语法，只能卸载方法体内部，因此它只能实现语句基本块(Block)

级别的条件编译，而没有办法实现根据条件调整整个java类的结构。

 

​    除了本节中介绍的泛型、自动装箱、自动拆箱、编译循环、变长参数和条件编译之外，

java语言还有不少语法糖，如内部类、枚举类、断言语句、对枚举和字符串在JDK

1.7中支持的switch支持、try语句中定义和关闭资源等，读者可以通过跟踪javac源码、反编译class文件等方式了解他们的本质实现，鉴于篇幅，笔者就不一一

介绍了



#### 10.4 实战：插入式注解处理器

​    jdk编译优化部分在本书中并没有设置独立的实战章节，因为我们开发程序，考虑的主要

是程序会如何运行，很少会针对程序编译的需求。也因为这个原因，在jdk的编译子系统

里面，提供给用户直接控制的功能能相对较少，除了第11张会介绍虚拟机jit编译的几个

相关参数以外，我们就只有使用JSR-296中定义的插入式注解处理器API来对JDK编译子

系统的行为产生一些影响.

   但是笔者并不认为相对于前两部分介绍的内存管理子系统和字节码执行子系统，JDK的

编译子系统就不那么重要。一套编程语言中编译子系统的优劣，很大程序上决定了程序运行

性能的好坏和编码效率的高低、尤其在java语言中，运行期及时编译与虚拟机执行子系统非常

紧密地互相依赖、配合运作。了解JDK如何斌阿姨和优化

代码，有助于我们写出合适JDK自优化的程序。下面我们回到本章的实战中，看看插入式

注解处理器API能实现什么功能。

###### 10.4.1 实战目标

   通过阅读javac编译器的源码，我们知道编译器在吧java程序源码编译为字节码的

时候，会对java程序源码做各方面的检查校验。这些校验主要以程序写的对不对为

出发点，虽然也有各种WARNING的信息，但总体来讲还是较少去校验程序写的好不好。

。有鉴于此，业界出现了许多针对程序写的好不好的辅助校验工具，如checkstyle

findbugklocwork等。这些代码校验工具有一些是基于java的源码进行校验，还有一些是

通过扫描字节码来完成，在本节的实战中，我们将会使用注解处理器API来编写一款拥有自己

编码风格的校验工具：nameCheckprocessor.

   当然，由于我们的实战都是为了学习和演示技术原理，而不是为了做出一款能媲美

CheckStyle等工具的产品来，所以NameCheckProcessor的目标也仅定位对java程序命名进行

检查，根据java语言规范第三版中第6.8节的要求，java程序命名应当符合下列各

式的书写规范。

类或接口：符合驼式命名法，首字母大写。

方法：符合驼式命名法，首字母小写。

字段：

类或实例变量：符合驼式命名法，首字母小写。

常量：要求全部由大写字母或下划线构成，并且第一个字符不能是下划线。

   上文提到的驼式命名法camel case name,正如它的名称所标识的那样，是指混合使

用大小写字母来分割构成变量或函数的名字，犹如驼峰一般，这是当前java语言中流的命名

规范，我们的实战目标就是为javac编译器添加一个额外的功能，在编译程序时检测程序

名是否符合上述对类或接口方法字段的命名要求。

##### 10.4.2 代码实现

   要通过注解处理器API实现一个编译器插件，首先需要了解这组API的一些基本知识。

我们实现注解处理器的代码需要继承抽象类javax.annotation.processing.AbstractProcessor,

这个抽象类中只有一个必须覆盖的abstract方法：process它是javac编译器在执行

注解处理器代码时要调用的过程，我们可以从这个方法的第一个参数annotations中

获取到此注解处理器所要处理的注解集合，从第二个参数roundEnv中访问到当前这个

round中的语法树节点，每个语法树节点在这里表示为一个element在jdk1.6新增

的javax.lang.model包中定义了16类的elment，包括了java代码中国最常用的元素，如：

包package枚举enum类class、注解annotation_type接口interface枚举值enum_constant、字段field、参数parameter、本地变量、local_variable、异常exception_parameter、方法method、构造函数constructor、静态语句块static_init、实例语句块

instance_init、参数和类型type_parameter,既泛型尖括号内的类型

和未定义的其他语法树节点other.除了process方法的传入参数之外，还有一个很

常用的实例变量processingEnv它是abstractProcessor中的一个protected变量,在注解

处理器初始化的时候init方法执行的时候创建，集成了abstractProcessor的注解处理器

代码可以直接访问到它。它代表了注解处理器框架提供的一个上下文环境，要创建新的代码、

向编译器输出信息、获取其他工具类等都需要用到这个实例变量。

  注解处理器除了process方法以及其他阐述之外，还有一个很常用

的实例变量processingenv踏实abstractprocessor中的一个protectred变量，在注解

处理器初始化的时候init方法执行的时候创建，集成了abstractprocessor的注解处理器代码可以直接访问到它。它代表了注解处理器框架提供的一个上下文环境，要创建新的代码

向编译器输出信息、获取其他工具类等都需要用到这个实例变量。

   注解处理器除了process方法以及其他参数之外，还有两个可以配合使用的annotations

supportedAnnotationType和supportedSourceBersion,前者代表了这个注解处理器对那些

注解感兴趣，可以使用*座位通配符代表对所有的注解都感兴趣，后者支出这个注解处理器

可以处理那些版本的代码。

​    每一个注解处理器在运行的时候都是单例的，如果不需要改变或生成语法树的内容，

process方法就可以返回一个false的布尔值，通知编译器这个round中的代码未发生

变化，无需构造新的javacompiler实例，在这里实战的注解处理器中只对程序命名进行检查

，不需要改变语法树的内容，因此process方法的返回值都是false。关于注解处理器的

API，笔者就简单介绍这些，这个领域有兴趣的读者可以阅读相关的帮助文档。下面来

看看注解处理器NameCheckProcessor的具体代码

javax.lang.model.element.ElementKind

​    NameChecker的代码看起来有点长，但实际上注释占了很大一部分，其实即使

算上注释也不到190行。它通过一个继承与javax.lang.model.util.ElementScanner6的

NameCheckScanner类，以Vistor模式来完成对语法树的遍历，分别执行visitType()、

visitVariable和visitExecutalbe方法来访问类、字段和方法，这三个visit方法对各个的命

名规则做相应的检测，checkCamelCase与checkAllCaps方法则用于实现驼式命名法和全

大写命名规则的检查。

P326

​     整个注解处理器只需要NameCheckProcessor和NameChecker两个类就可以全部完成，为

了验证我们的实战成果，代码清单10-13中提供了一段命名规范的反面交代码



###### 10.4.3 运行与测试

​    我们可以通过javac命令的 -processor  参数来执行编译时需要附带的注解处理器，如

果有多个注解处理器的话，用都好分割。还可以使用-XprintRounds和-XprintProcessorInfo

参数来查看注解处理器的运作的详细信息，本次实战中的NameCheckProcessor的编译以及执行过程

10.4.4 其他应用案例

​    NameCheckProcessor的实战例子只演示了 JSR-269嵌入式注解处理器API中的一部分功

能，基于这组API支持的项目还有用于校验hibernate标签使用正确性的hibernate validator

Annotation Processor、自动为字段生成

getter和setter方法的Project Lombok等读者有兴趣的话可以参考他们官方站点的相关内容。

##### 10.5 本章小结

   本章中，我们从编译器源码实现的层次上了解了java源代码编译为字节码的过程，分析

了java语言中泛型、主动装箱拆箱、条件编译等多种语法糖的前因后果，并实战练习了

如何使用插入式注解处理器来完成一个检查程序命名规范的编译期插件。如本章概述所说

的那样，在前端编译器中，优化手段主要用于提升程序的编码效率，只所以吧javac这里

讲java代码砖面为字节码的编译器乘坐前端编译器，是因为它只完成了从程序到抽象语法

树活中间字节码的生产，而在此之后，还有一组内置于虚拟机内部的后端编译器完成

了从字节码生成本地机器码的过程，及前面多提提到的即时编译器或JIT编译器，这个编译

器的编译速度以及编译记过的优略，是横岭虚拟机性能一个很重要的指标。在第11章中，我们

将会介绍即使编译器的运作和优化过程。



#  第11章 晚期（运行期）优化

从计算机程序出现的第一天起，对效率的追求就是程序天生的坚定信仰，这个过程犹如一

场没有终点、用不停歇的F1方程式竞赛，程序员是车手，技术平台则是在赛道上飞驰的赛车。

### 11.1 概述

   在部分的商用虚拟机sun hotspot ibmj9中，java程序最初是通过解释器

interpreter 进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会吧

这些代码认定为热点代码hot spot code .为了提高热点代码的执行效率,在运行时，

虚拟机将会吧这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个

任务的编译器成为即时编译器just in time compiler 下文中简称jit编译器。

   即时编译器并不是虚拟机必须的部分，java虚拟机规范并没有规定java虚拟机内不许要

有即时编译器存在，更没有限定或知道即时编译器应该如何去实现。但是，即时编译器编译性能

的好坏、代码优化程度的高低确实衡量一款商用虚拟机优秀与否的最关键的指标之一，

它是虚拟机中最核心且最能体现虚拟机技术水平的部分。在本章中，我们将走虚拟机的

内部，探索即时编译器的运作过程。

   由于java虚拟机规范没有具体的约束规则去限制及时比爱你以前应该如何实现，所以这部

分功能完全是与虚拟机具体实现相关的内容，如无特殊说明，

本章提及的编译器、及时编译器都是指hotspot虚拟机内的即时编译器,虚拟机也是特指

hotspot虚拟机。不过，本章的大部分内容是描述即时编译器的行为，设计编译器实现层面

的内容较少，而主流虚拟机中即时编译器的行为有有很多相似和相同之处，因此，对其他虚拟机

来说也具有较高的参考意义。



##### 11.2 HotSpot虚拟机内的即时编译器

   在本节中，我们将要了解HotSpot虚拟机内的即时编译器的运作过程，同时，还要解决

以下几个问题：

   为何hotspot虚拟机要使用解释器与编译器并存的架构

为何hotpot虚拟机要实现两个不同的即时编译器

程序何时使用解释器执行？何时使用编译器执行

那些程序代码会被编译为本地代码？如何编译为本地代码？

如何从外部观察即时编译器的编译过程和编译结果



通过解释器interpreter 进行执行

优化为本地代码

即时编译器 jit 编译器



###### 11.2.1 解释器与编译器

​    尽管并不是所有的java虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚

拟机，如hotspotj9等，都同事包含解释器与编译器。解释器与编译器两者个有优势：当

程序需要循序启动和执行的是，解释器可以寿险发挥作用，省区编译的是加你，立即执行。

在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码

之后，可以获取更高的执行效率。当程序运行环境中内存资源限制较大如部分嵌入式系统

中，可以使用解释器执行节约内存，反之可以使用编译执行来提升效率。同时，解释器还可以

座位编译器激进优化时的一个逃生门，让编译器根据改了选择一些大多数时候都能提升运

行速度的优化手段，当激进优化的假设不成立，如加载了辛磊后类型集成结构出现变化、出现

罕见陷阱uncommon trap时可以通过逆优化退回到解释状态继续

执行 部分没有解释器的虚拟机中也会采用不进行激进优化的C1编译器单人逃生门的

角色，因此，在整个虚拟机执行架构中，解释器与编译器经常配合工作 

  HotSpot虚拟机中内置了两个即时编译器，分别成为Client Compiler 和server Compiler

或者简称为C1编译器和C2编译器页脚OPTO编译器。目前主流的 HotSpot虚拟机Sun

系列JDK1.7及之前的版本的虚拟机中，默认采用解释器与其中一个编译器直接配合的方式

工作，程序使用那个编译器，取决于虚拟机运行的模式，hostpot虚拟机会根据自身版本与

宿主机器的硬件性能自动选择运行模式，用于也可以使用-client或server参数去强制

指定虚拟机运行在client模式或server模式

   无论采用的编译器是client compiler还是server compiler解释器与编译器搭配使用的方

式在虚拟机中成为混合模式mixed mode 用户可以使用参数-xint 强制虚拟机运行于

解释模式 interpreted mode,这时编译器完全不接入工作，全部代码都使用解释方式执行。

另外，也可以使用参数-xcomp 强制虚拟机运行于编译模式 compiled mode 这时

将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下接入执行过程，可

以通过虚拟机的-version命令的输出结果显示出这三种模式，如代码清单11-1所示，请注意黑体字部分

java -version  : mixed mode

java -Xint -version : interpreted mode

java -Xcomp -version : compiled mode

​    由于即时编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，

所花费的时间可能更长；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收

集性能呢监控信息，这对解释执行的速度也有影响。为了在程序启动响应速度与程序运行效率之间

达到最佳平衡，hotpot虚拟机还会主键启用分层编译Tiered Compilation 的策略，分层

编译的概念在JDK1.6时期出现，后来一直处于改进阶段，最终在JDK1.7的server模式虚

拟机中座位默认编译策略被开启。分层编译根据编译器编译、优化的规模与好事，划分出不同

的编译层次，其中包括：

第0层，程序解释执行，解释器不开启性能监控功能profilinig，可触发第一层编译。

第1层，也称为C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如有

必要将加入性能监控的逻辑。

第2层，也称为C2编译，也是将字节码编译为本地代码，但是会启用

一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可控的激进优化。

  实施分层编译后，Client Compiler和Server Compiler将会同时工作，许多代码都可能会

被多次编译，用Client Compiler 获取更高的编译速度，用Server Compiler来获取更好的编译

质量，在解释执行的时候也无须再承担收集性能监控信息的任务。

###### 11.2.2 编译对象与触发条件

   上文中提到过，在运行过程中会被即使编译器编译的热点代码有两类，即“

被多次调用的方法。

被多次执行的循环体。

前者很好理解，一个方法被调用得多了，方法体内代码执行的次数自然就多，它成为

热点代码是理所当然的。而后者则是为了解决一个方法只被调用过一次或少量几次，

但是方法体内部存在循环次数较多的循环体的问题，这样循环体的代码也被重复执行多次，

因此这些代码也应该认为是热点代码。

​    对于第一种情况，由于是由方法调用触发的编译，因此编译器理所当然地会以整个方

法作为编译对象，这种编译也是虚拟机中标准的JIT编译方式。而对于后一种情况，尽管编

译动作是由循环体所触发的，但编译器依然会以整个方法（而不是单独的循环体）座位编译

对象。

这种编译方式因为编译发生在方法执行过程之中，因此形象地称之为沾上替换Stack 

Replacement ,简称为OSR编译，及方法栈帧还在沾上，方法就被替换了。

​    读者可能还会有疑问，在上面的文字描述中，无论是多次执行的方法，还是多次

执行的代码块，所谓多次都不是一个具体，严谨的用于，那到底多少次才算多次

呢？还有一个问题，就是虚拟机如何统计一个方法或一段代码被执行过多少次呢？解决了这

两个问题，也就回答了即使编译被触发的条件.



  判断一段代码是不是热点代码，是不是需要触发及时编译，这样的行为成为热点探测

hot spot detection,其实进行热点探测并不一定要知道方法具体被调用了多少次，目前主

要的热点探测判断方式有两种，分别如下。

1.基于采样的热点探测Sample based hot spot detection 采用这种方法的虚拟机会

周期性地检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那这个

方法就是热点方法。基于采样的热点探测的好处是实现简单、高效，还可以很

容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精准地确认一个方法

的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。



2.基于计数器的热点探测Counter based hot spot detection:采用这种方法的虚拟机

会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超

过一定的阈值就认为他是热点方法。这种统计方法实现起来麻烦一些，需要为每个

方法加你并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果

相对来说更加精准和严谨。

  在hotspot虚拟机中使用的是第二种---基于计数器的热点探测方法，因此它为每个方法

准备了两类计数器：方法调用计数器（invocation Counter）和回边计数器(Back Edge counter)

​    在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈

值溢出了，就会触发JIT编译。

   我们首先来看看方法调用计数器。顾名思义,这个计数器就用于统计方法被调用的次

数，它的默认阈值在client模式下是1500次，在Server模式下是10000次，这个阈值可以

通过虚拟机参数-XX:CompileThreshold来认为设定。当一个方法被调用时，会先检查该

方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不

存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边

计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提

交一个该方法的代码编译请求。

  如果不做任何设置，执行引擎并不会同步等待编译请求完成，而是继续今日解释器按照

解释方法执行字节码，知道提交的请求被编译器编译完成。当编译工作完成之后，这个方法

的调用入口地址就会被系统自动改写成新的，下一次调用改方法时就会使用已编译的版本。

整个JIT编译的交互过程如图11-2所示。

![1557718279890](C:\Users\Administrator.CE-20160511RDFS\AppData\Roaming\Typora\typora-user-images\1557718279890.png)

​          如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相

对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调

用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，

这个过程称为方法调用计数器热度的衰减（Counter Decay）,而这段时间就称为此方法统计

的半衰周期(Counter half life time)。进行热度衰减的动作是在虚拟机进行垃圾收集时顺便

进行的，可以使用虚拟机参数-XX:-UseCounterDecay来关闭热度衰减，让方法计数器统计

方法调用的绝对次数，这样，只要系统运行时间足够从，绝大部分方法都会被编译成本地代码

。另外可以使用=XX:CounterHalfLifeTime参数设置绊摔周期的时间，单位是秒。

​    现在我们再来看看另外一个计数器---回边计数器，它的作用是统计一个方法中循环体

代码执行的次数，在字节码中遇到控制流向后跳转的指令成为回边back edge。先让，

建立回边计数器统计的目的就是为了触发OSR编译(栈上替换On Stack Replacement,方法栈帧还在栈上，方法就被替换了)。

   关于回边计数器的阈值，虽然HOTSpot虚拟机也提供了一个类似于方法调用计数器阈值

-XX:CompileThreshold的参数 --XX:BackEdgeThreshold供用户设置，但是当前的虚拟机

实际上并未使用此参数，因此我们需要设置另外一个参数-XX:OnstackReplacePercntage来

问接调整回边计数器的阈值，其计算公式如下。

- 虚拟机运行在Client模式下，回边计数器阈值计算公式为：

   方法调用计数器阈值（CompileThreshold）*OSR比率(OnstackReplacePercentage)/100

其中OnstackReplacePercentage默认值为933，如果都取默认值，那Client模式虚拟机

的回边计数器的阈值为13995。 1500*OSR933/100=13995

-   虚拟机运行在server模式下，回边计数器的阈值的计算公式为：

方法调用计数器阈值CompileThreshold*osr比率OnstackReplacePercentage-

解释器监控比率interpreterProfilePercentage/100

其中OnstackReplacePercentage默认值为140，InterpreterProfilePercentage默认值为33，

如果都取默认值，那Server模式虚拟机回边计数器的阈值为10700.

​    当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经变异好的版本，

如果有，它将会有限执行已变异的代码，否则就会吧回边计数器值加1，然后判断方法

调用计数器与回边计数器值之和是否超过回边计数器的阈值。当超过阈值的时候，将会提交

一个OSR编译请求，并且吧回边计数器的值降低一些，以便继续在解释器中执行循环，等

待编译器输出编译结果，整个执行过程如图11-3所示。（OSR On stack Replacement 方法栈帧还在栈上，方法就被替换了）

​    如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相

对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调

用次数仍然不足以让它提交给即使编译器编译，那这个方法的调用计数器就会被减少一半，

  与

![1557822378832](C:\Users\Administrator.CE-20160511RDFS\AppData\Roaming\Typora\typora-user-images\1557822378832.png)



  与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是

改方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出

状态，这样下次再进入该方法的是就会执行标准编译过程。

​    最后需要提醒 一点，图11-2和图11-3都仅仅描述了Clientvm的即时编译器方式，对于

serverVM来说，执行情况会比上面的描述更复杂一些。从理论上了解过编译对象和编译触发

条件后，我们再从hotspot虚拟机的源码中观察一下，在methodoop.hpp一个methodoop

对象代表了一个java方法中，定义了java方法在虚拟机中的内存布局，如下所示：



![1557822712820](C:\Users\Administrator.CE-20160511RDFS\AppData\Roaming\Typora\typora-user-images\1557822712820.png)

​    在这个内存布局中，一行长度为32bit，从中可以清楚地看到方法调用计数器和回边计数器

所在的位置和长度。。还有from_compiled_entry和from_interpreted_entry这两个方法的入口。

###### 11.2.3编译过程

  在默认设置下，无论是方法调用产品的即时编译请求，还是OSROSR编译请求，虚拟机在

代码编译器还未完成之前，都仍然将按照解释方式继续执行，而编译动作则在后台的编译线

程中进行。用户可以通过参数-XX：-BackgroundCompilation来禁止后台编译，在禁止后台

编译后，一看达到JIT的编译条件，执行线程向虚拟机提交编译请求后将会一直等待，直到

编译过程完成后再开始执行编译器输出的本地代码。

   那么在后台执行编译的过程中，编译器做了什么事情呢，serverCompiler和Client Compiler

两个编译器的编译过程是不一样的。对于Client Compiler来说，它是一个简单快速

的一段式编译器，主要的关注点在于局部性的优化，而方式了许多耗时较长的全局优化手段。

​    在第一个阶段，一个平台独立的前端将字节码构成一种高级中间代码标识High-

Level Intermediate Representaion HIR 。HIR使用静态单分配Static single Assignment,

SSA的形式来代表代码值，这可以使得一些在HIR的构造过程之中和之后进行的优化动作

更容易实现。再次之前编译器会在字节码上完成一部分基础优化，如方法内联、常量传播等

优化将会在字节码被构造成HIR之前完成。

​         在第二个阶段，一个平台相关的后端从HIR中产生低级中间代码表示Low-level

Intermediate representation LIR,而在此之前会在HIR上完成另外一些优化，如空值检查

消除、范围检查消除等，以便让HIR达到更高效的代码表示形式。

​       最后阶段是在平台相关的后端使用线性扫描算法Linear scan Register allocation

在LIR上分配寄存器，并在LIR上做Peephole 优化，然后产生机器代码。Client

Compiler的大致执行过程如图11-4所示。

字节码》方法内联》常量传播》其他优化

HIR（SSA形成）》其他优化》范围检查消除》空值检查消除》优化后的HIR》HIR到LLR转换

LTR》寄存器分配》窥孔优化》机器码生成》本地代码

   而server Compiler 则是专门面相服务端的典型应用并为服务端的性能配置特别调整过

的编译器，也是一个充分优化过的高级编译器，几乎能达到GNUc++编译器使用-O2参数

时的优化强度，它会执行所有经典的优化动作，如无用代码消除（Dead Code elimination）、

循环展开loop unrolling 、循环表达式外提loop expression hoisting、消除公共子表达

式common subexpression elimination、常量传播constant propagation、基本块重排序

basic block reordering 等，还会实时一些与java语言特性密切相关的优化技术，如范围

检查消除range-check elimination、控制检查消除null check elimination，不过并非所有

的控制检测消除都是依赖编译器优化的，有一些是在代码运行过程中自动优化了等。另

外，还可能根据解释器或ClientCompiler提供的性能监控信息，进行一些不稳定的激进优

化，如守护内联Guarded Inlinging、分支频率预测BranchFrequency Prediction等。本章

的下半部分将会挑选上述的一部分优化手段进行分析和讲解。

  Server Compiler的寄存器分配器是一个全局图着色分配器，它可以充分利用某些处理器
  架构如RISC上的大寄存器集合。以及时编译的标准来开，servercompiler无疑是比较缓
  慢的，但它的编译速度依然媛媛超过传统的静态优化编译器，而且它相对于Client compiler
  编译输出的代码质量有所提高，可以减少本地代码的执行时间，从而抵消了额外的编译时间
  开销，所以也有很多非服务的的应用选择使用server模式的虚拟机运行。
     在本节中，涉及了许多编译原理和代码优化中的概念名词，没有这方面基础的读者，阅
     读起来会感觉到抽象和理论化。有这种感觉并不奇怪，JIT编译过程本来就是一个虚拟机中
     最体现技术水平也是最复杂的部分，不可能以较短的篇幅就介绍得很详细，另外，这个过程
     对java开发来说是透明的，程序员平时无法感知它的存在，还好hotspot虚拟机提供了两个
     可视化的工具，让我们可以看见JIT编译器的优化过程，在稍后笔者将会演示这个过程。
     11.2.4查看以及分析即时编译结果
       一般来说，虚拟机的即时编译过程对用户程序是完全透明的，虚拟机通过解释执行代码
       还是编译执行代码，对于用户来说并没有什么影响（执行结果没有影响，速度上会有很大差
       别），在大多数情况下用户也没有必要知道。但是虚拟机也提供了一些参数用来输出即时编
       译和某些优化手段如方法内联的执行情况，本节将介绍如何从外部观察虚拟机的即时编译行为。
           本节中提到的运行参数有一部分需要debug或fastdebug版虚拟机的支持，Product版本
   的虚拟机无法使用这部分参数。如果读者使用的是根据本书第一章的内容自己编译的JDK，
注意将skip_debug_build或skip_fastdebug_build参数设置为false，也可以在
openJDK网站上直接下载fastdebug版的jdk从JDK6u25之后oracle官网就不再提供
fastdebugjdk下载了。注意，本节中所有的测试都基于代码清单11-2所示的java代码。
       首先运行这段代码，并且确认这段代码是否触发了即时编译，要知道某个方法是否被编
       译过，可以使用参数-XX：+PrintCompilation要求虚拟机在即时编译时将被编译成本地代码
        的方法名称打印出来，如代码清单11-3所示其中带有%的输出说明是由回边计数器触发
        的OSR编译。
        从代码清单11-3输出的确认信息中可以确认maincalcSum和doublevalue方法已经
被编译，我们还可以加上参数-XX:printInlining要求虚拟机输出方法内联信息，如代码
清单11-4所示
        从代码清单11-4的输出中可以看到方法doubleValue()被内敛编译到calcSum中，而
calcSum又被内联编译到方法main中，所以虚拟机再次执行main方法的时候举例而已
main方法并不会运行两次，calcsum和dubleValue方法都不会再被调用，它们的
代码逻辑都被直接内联到main方法中了。
    除了查看哪些方法被编译之外，还可以进一步查看即时编译器生成的机器码内容，不过
    如果虚拟机输出一串0和1，对于我们的阅读来说是没有意义的，机器码必须反汇编成基本
    的回边语言才能被阅读。虚拟机提供了一组通用的反汇编接口，可以介入各个平台下的
    反汇编适配器来使用，如使用32位80*86平台则选用hsdis-int86适配器，其余平台的适配
    器hsdis-amd64\hsdis-sparc和hsdis-sparcv9等，可以下载或自己编译出反汇编适配器，
    然后将其放置在jrebinclient或server目录下，只要与jvm.dll的路径相同即可被逊尼基调用
    在为虚拟机安装了反汇编适配器之后，就可以使用-xx:printAssembly参数要求虚拟机
    打印编译方法的汇编代码了，具体的操作可以参考本书4.2.7节
        如果没有HSDIS插件支持，也可以使用-xx:printOptoAssembly用于serverVM
        或-xx+printLIR用于clientvm来输出比较接近最终结果的中间代码标识，代码清单
11-2被编译后部分反汇编使用-xx+printOptoAssembly的输出结果如代码清单11-5所
示。从阅读角度来说，使用-XX:+printOptoAssembly参数输出的伪汇编结果包含了更多的
信息主要是注释，利于阅读并理解虚拟机JIT编译器的优化结果。
        前面提到的使用-XX：+printAssembly参数输出反汇编信息需要debug或者fastdebug
版的虚拟机才能直接支持，如果使用product版本的虚拟机，则需要加入参数-XX:unloclDiagnosticVMOptions
打开虚拟机诊断模式后才能使用。
    如果出了本地代码的生成结果外，还想进一步跟踪本地代码生成的具体请，那还可以
    使用参数-xx:+printCFGTofile或者-xx:PrintIdealGraphFile()使用
    servercompiler令虚拟机将编译过程中各个阶段的数据（例如，对C1编译器来说，包
    括字节码、HIR生成、LIR生成、寄存器分配过程、本地代码生产等数据）输出到文件中。
    然后使用java hostspotclient compiler visualizer用于分析cliencompiler或者idealgraph
    visualizer用于分析servercompiler打开这些数据文件进行分析。以servercompiler为例
    ，笔者分析一下jit编译器的代码生成过程。
        Server compiler的中间代码标识是一种名为ideal的SSA形式程序依赖图Program
        Dependence graph,在运行java程序的jvm参数中加入-xx:PrintIdealGraphLevel=2
        -XX:PrintIdealGraphFile=ideal.xml,编译后将产生一个名为ideal.xml的文件它包含了
        server Compiler编译代码的过程信息，可以使用ideal graphvisualizer 对这些信息进行分析。
        
P343
         Ideal Graph visualizer 加载idea.xml文件后，在outline面板上将显示程序运行过程中编译
         过的方法列表，如图11-5所示这里列出的方法
         是代码清单11-2中的测试代码，其中doublevalue
         方法出现了两次，这是由于该方法的编译结果存在
         标准编译和OSR编译两个版本。在代码清单11-2
         中笔者特别为dubblevalue方法增加了一个空循环，
         这个循环对方法的运算结果不会产生影响，但
         如果没有任何优化，执行空循环会占用CPU时间，
         到今天还有许多程序设计的入门教程吧空循环当作
         程序演示的手段来介绍，在java中这样的做饭真的
         能起到延时的作用吗
            展开方法根节点，可以看到下面罗列了方法优化
            过程的各个阶段根据优化措施的不同，每个方法所经过的阶段也会有所差别的ideal
            图，我们先打开afterrparsing这个阶段，上文提到，jit编译器在编译一个java方法时，
            寿险要吧字节码解析成某种中间标识形式，然后才可以继续做分析和优化，最终生成代码。
            afterparsing就是servercompiler刚完成解析，还没有做任何优化和分析，最终生成点。
            打开这个图后，读者会看到其中有很多有颜色的方块，如图11-6所示。每一个放款就代表了一个
            程序的基本快basicbloac，基本快内所有执行都会按照顺序仅执行一次。
            
            代码清单11-2的doublevalue方法虽然只有简单的两行字，但是按照基本块划分后，形
            成的图形结构要比想象中复杂得多，这一方面是要满足java语言所定义的安全需要入类型
            安全、空指针检查和java虚拟机的运作需要入safepoint轮训，另一方面是由于有些程
            序代码中一行语句就可能行程好几个基本块例如循环，对于例子中的dublleValue方法
            如果忽略语言安全检查的基本块，可以简单理解为按顺序执行了以下几件事情：
            1.程序入口，建立栈帧。
            2.设置j=0,进行safepoint轮训，挑战到4的条件检查。
            3.执行j++
            4.条件检查，如果j<10000跳转到3
            5.设置i=i*2,进行safepoint轮训，函数返回。
            
            以上几个步骤，反应到Ideal graph visualizer的图上，就是如图11-7所示的内容。这样
            我们要看空循环是否优化，或者合适优化，只要观察代表循环的基本块是否消除，或者何时
            消除就可以了。
        要观察到这一点，可以在outlin面板上右键点击difference to current graph,让软
        件自动分析制定阶段与当前打开的ideal图之间的差异，如果基本块被消除了，将会以红色
        显示。对于after parsing 和phaseIdeaiLoop 1阶段的ideal图进行差异分析，发现在
        phaseIdealLoop 1阶段循环操作被消除了，如图11-8所示，这也就说明空循环实际上是不
        会被执行的。
         
           从afterparsing 阶段开始，一直到最后的finalcode阶段可以看到doubleValue
           方法的ideal图从繁到简的变迁过程，这也是java虚拟机在尽力优化代码的过程。到了最后的
           finalcode阶段，不近空循环的开销消除了，许多语言安全和safepoint循序的操作也一起
           消除了，因为编译器判断即使不做这些安全保障，虚拟机也不会受到威胁。
           最后提醒一下读者，要输出CFG或者idealgraph文件，需要一个debug版或者fastdebug
           版本的虚拟机支持，product版的虚拟机无法输出这些文件。
           
### 11.3 编译优化技术
         java程序员有一个共识，以编译方式执行本地代码比解释方式更快，之所以有这样的
共识，除去虚拟机解释执行字节码时额外消耗时间的原因外，还有一个很重要的原因就是虚
拟机设计团队几乎把对代码的所有优化措施都集中在了即时编译器之宗（在jdk1.3
之后javac就祛除了-O选项，不会生成任何字节码级别的优化代码了）因此一般来说，及时编译
昌盛的本地代码会比javac产生的字节码更加优秀。下面，笔者将介绍一些hotspot虚拟机
的即时编译器在生成代码时采用的代码优化技术。

11.3.1 优化技术概览
     在sun官方的wiki上，hotspot虚拟机设计团队列出了一个相对比较全面的、在即时编译器
     中采用的优化技术里列表见表11-1 ，其中有不少经典编译器的优化手段，也有许多针对
     java语言准确第说是针对运行在java虚拟机上的所有语言本身进行的优化技术，本
     节将对这些技术进行概括性的介绍，在后面几节中，再挑选若干重要且经典的优化，与读者
     一起看看优化前后的代码缠身了怎样的变化。
     
     即时编译器优化技术一览
     
1.编译器策略（compiler tactics）
延迟编译(delayed compilation)
分层编译(tiered compilation)
栈上替换(on-stack replacement)
延迟优化(delayed reoptimization)
静态单赋值表示(static single assignment representation)

2.基于性能监控的优化技术(profile-based techniques)
乐观空值断言(optimistic nullnuess assertions)
乐观类型断言(optimistic type assertions)
乐观类型增强(optimistic type strengthening)
乐观数组长度增强（optimistic array length strengthening）
裁剪未被选择的分支（untaken branch pruning）
乐观的多态内联（optimistic N-morphic inlining）
分支频率预测（branch frequency prediction）
调用频率预测(call frequency prediction)


3.基于证据的优化技术(proof-based techniques)
精确类型推断(exact type inference)
内存值推断（memory value inference）
内存值跟踪（memory value tracking）
常量折叠（constant folding）
重组（reassociation）
操作符退化(operator strength reduction)
空值检查消除（null check elimination）
类型检测退化(type test strength reduction)
类型检测消除(type test climination)
代数简化(algebraic simplification)
公共子表达式消除(common subexpression elimination)




4.数据流敏感重写（flow-sensitive rewrites）
条件常量传播(conditional constant propagation)
基于流承载的类型缩减转换(flow-carried type narrowing)
无用代码消除(dead code elimination)


5.语言相关的优化技术(language-specific techniques)
类型继承关系分析(class hicrarchy analysis)
去虚拟化(devirtualization)
符号常量传播(symbolic constant propagation)
自动装箱消除(autobox elimination)
逃逸分析(escape analysis)
锁消除(lock elision)
锁膨胀(lock coarsening)
消除反射(de-reflection)


6.内存及代码位置变换(memory and placement transformation)
表达式提升(expression hoisting)
表达式下沉(expression sinking)
冗余存储消除(redundant store elimination)
相邻存储合并(adjacent store fusion)
交汇点分离(merge-point splitting)


7.循环变换(loop transformations)
循环展开（loop unrolling）
循环剥离(loop peeling)
安全点消除(safepoint elimination)
迭代范围分离(iteration range splitting)
范围检查消除(range check elimination)
循环向量化(loop vectorization)


8.全局代码调整（global code shaping）
内联(inlining)
全局代码外提(global code motion)
基于热度的代码布局(heat-based code layout)
Switch调整（switch balancing）

9.控制流图变换(control flow graph transformation)
本地代码编排(local code scheduling)
本地代码封包(local code bundling)
延迟槽填充(delay slot filling)
着色图寄存器分配(graph-coloring register allocation)
线性扫描寄存器分配(linear scan register allocation)
复写聚合(copy coalescing)
常量分裂(constant splitting)
复写移除(copy removal)
地址模式匹配(address mode matching)
指令窥空优化(instruction peepholing)
基于确定有限状态机的代码生成(DFA-based code generator)
        
上述的优化技术看起来很多，而且从名字看都显得有点高深莫测，虽然实现这些优化
也许确实有些难度，但大多数技术理解起来都并不困难。为了消除读者对这些优化技术的陌生感
，笔者举一个简单的例子，即通过大家熟悉的java代码变化来展示其中几种优化技术是如何发挥作用的
仅使用java代码表示而已。首先从原始代码开始，如代码清单11-6所示。

首先需要明确的是，这些代码优化变换是建立在代码的某种中间表示或机器码之上，绝
不是建立在java源码智商的，为了展示方便，笔者使用了java语言的语法来标识这些优化
技术所返回的作用。

代码清单11-6的代码已经非常简单了，但是仍有许多优化的余地。第一步进行方法内联
method inlining 方法内联的重要性要高于其他优化措施，他的主要目的有两个，1是去除
方法调用的成本，如建立栈帧等，二是为其他优化建立良好的基础，方法内联膨胀之后
可以便于在更大范围上采取后续的优化手段，从而获得更好的优化效果。因此，各种编译器
一般都会吧内联优化放在优化序列的最靠前位置。内联后的代码如代码清单11-7所示。
   第二步进行冗余访问消除redundant loads elimination 假设代码中间注释掉的do
   stuff 所代表的操作不会改变 b.value的值，那就可以把z=b.value替换为z=y,因为
   上一句y=b.value 已经保证了变量y与b.value是一致的，这样就可以不再去访问对象B
   的局部变量了。如果把b.value看做是一个表达式，那也可以吧这些优化看成是公共子表达式
   消除，优化后的代码如代码清单11-8所示
        第三部我们进行复写copy Propagation,因为在这段程序的逻辑中并没有必要使
        用一个额外的变量Z，他与变量Y完全相等的，因此可以使用y来代替在复写传播之后程序如代码
        所示
        
        第四部我们进行无用代码消除dead code elimination。无用代码可能是永远不会被执行的代码
        ，也可能是完全没有意义的代码，因此，又形象的成为deadcode，在代码清单11-9
        中yy是没有意义的，把它消除后的程序如代码清单11-10所示。
        经过四次哟花效果一致，但是前者比后者省略了许多语句，执行效率会更高。
        编译器的这些优化技术实现起来也许比较复杂，但是要理解他们的行为对于一个普通的程序员
        来说没有困难，接下来，我们将要继续查看如下的迹象最有代表性的优化技术是如何运作的，
        他们分别是：
        
        语言无关的经典优化技术之一:公共子表达式消除。
        语言相关的经典优化之一：数组范围检查消除。
        最重要的优化技术之一：方法内联
        最前沿的优化技术之一：逃逸分子。
        
        
        11.3.2 公共子表达式消除
           公共子表达式消除是一个普遍应用于各种编译器的经典优化技术，他的含义是：如果一
       个表达式E已经计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那
       么E的这次出现就称为了公共子表达式。对于这种表达式，没有必要花时间再对它进行计
       算，只需要直接用前面计算过的表达式结果代替E就可以了。如果这种优化仅限于程序的
       基本块内，便称为局部公共子表达式消除local common subexpression elimination如
       果这种优化的范围涵盖了多个基本块，那就称为全局公共子表达式消除global common
       subexpression elimination .举个简单的例子来说明它的优化过程
       int d=(c*b)*12+a+(a+b*c);
       如果这段代码交给javac编译器则不会进行任何优化，那生成的代码将如
       javac 不进行任何优化
       
          当这段代码进入到虚拟机即时编译器后，它将进行如下优化：编译器检测到c*b与b*c是一样的表达式，
          而且计算期间b与c的值是不变的。因此，这条表达式就可能被视为：
          int d=E*12+a+(a+E);
          
             这时，编译器还可能（取决于那种虚拟机的编译器以及具体的上下文而定）进行另外一
             种优化：代数化简(Algebraic simplification)吧表达式变为：
             int d=E*13 +a*2;
             表达式进行变换之后，再计算起来就可以节省一些时间了。如果读者还对其他的经典
             编译优化技术感兴趣，可以参考编译原理俗称龙书，推荐使用java的程序员阅读
             2006年版的紫龙书中的饿相关章节
             
        
        11.3.3 数组边界检查消除
            数组边界检查消除(Array Bounds Checking Elimination)是即时编译器中的一项语言
            相关的经典优化技术。我们知道java语言是一门动态安全的语言，对数组的读写访问也不像
            C、c++那样的本质上是裸指针操作。如果有一个数组foo【】，在java语言中访问数组元
            素foo【i】的时候系统将会自动进行上下界的范围检查，即检查I必须满足i>=0-&&i<foo.length
            这个条件，否则讲抛出一个运行时异常:java.lang.arrayIndexOutOfBoundsException.
            这对软件开发中来说是一件很好的事情，即使程序员没有专门编写防御代码，也可以避免
            大部分的溢出攻击。但是对于虚拟机的执行子系统来说，每次数组元素的读写都带来一次隐含
            的条件判定操作，对于拥有大量数组访问的程序代码，这无疑也是一种性能负担。
            
无论如何，为了安全，数组边间检查肯定是必须做的，但数组边界检查是不是必须在运行
行期间一次不漏检查则是可以商量的事情.例如下面这个简单的情况:数组下标是一个
常量,如foo3,只要在编译器根据数据流分析来确定foo.length的值,并判断下标3
没有越界,执行的时候就无需判断了.更加长假的情况是数据访问发生在循环之中,并且
使用循环变量来进行数组访问,如果编译器只要通过数据流分析就可以判定循环变量的取值范围
永远在区间0,foo.length之内,那在整个循环中就可以把数据的上下界检查消除,这
可以节省很多次的条件判断操作.
   将这个数据边界检查的例子放在更高的角度来看,大量的安全检查令编写java程序比
   编写c程序更容易很多,如数据越界会得到arrayindexoutofboundsexception异常,空指
   针访问会得到nullpointexception,除数为零会得到arithmeticException等,在C程序
   中出现类似的问题,一不小心就会出现segmentfault信号或者windows变长中常见的XX
   内存不能readwrite之类的提示,处理不好车呢供需就直接崩溃退出了.但这些安全检查也
   导致了相同的程序,java要比C做更多的事情,这些事情就称为一种
   隐式开销,如果处理不好它们,就很可能称为一个java语言比C更慢的因素.要消除
   这些隐式开销,除了如数组边界检查优化这种尽可能把运行期检查提到编译器完成的思路之外
   ,另外还有一种避免思路--隐式异常处理,java中空指针检测和算数运算中除数为零的
   检测都采用了这种思路.举个例子,例如程序中访问一个对象假设对象叫foo的某个属性
   假设属性叫value那java伪代码来标识虚拟机访问foo.value的过程如下
   if(foo!=null)
   return foo.value
   else
   throw new NUllpointexception
   虚拟机会注册一个segment fault 信号的异常处理器zhey 
   dang foo不为空的时候,对value的访问是不会额外消耗一次对foo判空的开销的.代价就是当
   foo真的为空时,必须转入到异常处理器中回复并抛出nullpointexception异常,这个过程必须
   兄用户态转到内核态中处理,结束后再回到用户态,速度远比一次判空检查慢.当foo极少为
   空的时候,隐式异常优化是值得的,但假如foo经常为空的话,这样的优化反而会让程序更慢,
   还好hotspot虚拟机足够聪明,它会根据运行期手机到的profile信息自动选择最优方案
与语言相关的其他消除操作还有不少,如自动装箱消除\安全点消除
消除反射等,笔者就不再一一介绍了.
11.3.4 方法内联inline
    在前面的讲解之中我们提到过方法内联，它是编译器最重要的优化手段之一，除了消除
    方法调用的成本之外，它更重要的意义是为其他优化手段建立良好的基础，如代码清单
    11-12所示的简单例子就揭示了内联对其他优化手段的意义：事实上testinline方法的内部
全部都是无用的代码，如果不做内联，后续即使进行了无用代码消除的优化，也无法发现任何
dead code 因为如果分开来看，foo和testinline两个方法里面的操作都可能是有意义的。
    方法内联的优化行为看起来很简单，不过是吧目标方法的代码复制到发起调用的方法
    之中，避免发生真实的方法调用而已。但实际上java虚拟机中的捏脸过程媛媛没有那么简单
    ，因为如果不是即时编译器做了一些特别的努力，按照经典编译原理的优化理论，大多数的
    java方法都无法进行内联。
      无法内联的原因其实在第八章中讲解java方法解析和分派调用的时候就已经介绍过。只有
      使用invokespecial指令调用的私有方法、实例构造器、父类方法以及使用invokestatic指令
      进行调用的静态方法才是在编译器进行解析的，除了上述4种方法之外，其他的java方法
      调用都需要在运行时进行方法接受者的多台选择，并且都有可能存在多余一个版本的方法接收者
      最多再出去被final修饰的方法这种特殊的情况，景观它使用vicokevirtual指令调用，但
      也是非虚方法，java语言规范中明确说明了这点，简而言之java语言中默认的实例方法
      是虚方法。
             对伊一个徐芳芳，编译器做内联的时候根本无法确定应该使用那个方法版本，如果已代码
             清中吧b.get内联为b.value为例的话，就是不依赖上下文就无法确定B
             的实际类型是什么。加入有parentB和subb两个具有继承关系的类，并且子类重写了父类
             的get方法那么要执行父类的get方法还是子类的get方法，需要在运行期才能确定
             编译器无法得出结论。
由于java语言提倡使用面相对象的变成方式进行变长，而java对象的方法默认就是虚方法
因此java简介鼓励了程序员使用大量的虚方法来完成逻辑。根据上面的分析，如果
内联与虚方法之间产生了锚段，那该怎么办呢，是不是为了提高执行性能，就要导出使用
final关键字去修饰方法呢
   为了解决虚方法的内敛问题，java虚拟机设计团队想了很多办法，寿险是引入了一种名为
   类型集成关系分析 class hierarchy analysis CHA的技术，这是一种基于整个应用
   程序的类型分析技术，它用于确定在目前已在家的类中，某个接口是否有多余一种的实现，
   某个类是否存在子类、子类是否为抽象类等信息。
        编译器在进行内联时，如果是非虚方法，那么直接进行内联就可以了，这时候的内联是
有稳定前提保障的。如果遇到虚方法，则会想CHA查询此方法在当前程序下是否有多个目标
版本可提供选择，如果查询结果只有一个版本，那也可进行内联，不过这种内联就属于基金
优化，需要预留一个逃生门guard条件不成立时slow path称为守护捏脸guarded inlinging如果程序
的后续执行过程中，虚拟机一直没有加载到会令这个方法的接受者的集成
关系发生变化的类，那这个内联优化的代码就可以一直使用下去。但如果加载了导致集成关系
发生变化的新类，那就需要抛弃已经编译的代码，退回到解释状态执行，或者重新进行编译。
     如果向CHA查询出来的结果是有多个版本的目标方法可供选择，则编译器还将会进行
最后一次努力，使用内联缓存inline cache来完成方法内联，这是一个简历在目标方法正常
入口之前的缓存，他的工作原理大志是：在未发生发放调用之前，内联缓存状态为空，当第一次
调用发生后，缓存积累下方法接受者的版本信息，并且每次进行方法调用时都比较接受者
版本，如果以后进来的每次调用的方法接受者辨别都是一样的，安这个内联还可以制止
用下去。如果发生了方法接受者不一致的情况，就说明程序真正使用了虚方法的多台特性，
这时才会取消内联，查找虚方法表进行方法分派。
  所以说，在许多情况下虚拟机进行的内联都是一种激进优化，激进优化的手段在高性能
  的商用虚拟机中很常见，除了内联之外，对于出现概率很小（通过经验数据或解释器收集到的
  性能监控信息确定概率大小）的隐式异常、使用概率很小的分支等都可以被激进优化移除
  ，如果真的出现了小概率事件，这时才会从逃生门回到解释状态重新执行。

11.3.5 逃逸分析
   逃逸分析escape analysis 是目前java虚拟机中比较前言的优化技术，它与类型集成
关系分析一样，并不是直接优化代码的手段，而是为其他优化手段提供依据的分析技术。
  逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能
被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸。甚至还有可能被
外部线程访问到，譬如复制给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。
   如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何
途径访问到这个对象，则可能为这个变量进行一些高效的优化，如下所示。
   1.栈上分配stack allocation:java虚拟机中，在java堆上分配创建对象的内存控件几乎
   是java程序员都清楚的常识了，java堆中的对象对于各个线程都是共享和课件的，
   只要支持这个对象的引用，就可以访问对重存储的对象数据。虚拟机的垃圾收集系统
   可以回收堆中不再使用的对象，但回收动作无论是帅选可回收对象，还是回收和整理
   内存都需要耗时间。如果确定一个对象不会逃逸出方法之外，那让这个对下你给在沾上
   分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。
   在一般应用中，不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量
   的对象就会随着方法的结束而自动销毁了，垃圾收集系统的压力将会小很多。
 
   2.同步消除 synchronization elimination 线程同步本身是一个相对耗时的过程，如果
   逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读
   写肯定就不会有竞争，对这个变量实时的同步措施也就可以消除掉。

    3.标量替换scalar replacement ：标量scalar 是指一个数据已经无法再分解成更小
    的数据来表示了，java虚拟机中的原始数据类型int long 等数值类型以及reference类型
    等都不能再进一步分析，他们就可以称为标量。相对的，如果一个数据可以继续
    分解，那它就称为聚合量aggregate,java中的对象就是最经典的聚合量。如果
    吧一个java对象拆散的话，那程序真正执行的时候将可能不创建这个对象，而改为直接创建
   它的若干个被这个方法使用到的成员变量来代替。将对象拆分后，除了可以让对象的成员
   变量在栈上（栈上存储的数据，有很大的概率会被虚拟机分配至物理机器的告诉寄存器中存储）
   分配和读写之外，还可以为后续进一步优化手段创建条件。

      关于逃逸分析的论文在1999年就已经发表，但知道sunjdk1.6才实现了逃逸分析，而且
      知道现在这项优化尚未足够成熟。扔有很大的改进余地。不成熟的原因主要是不能保证
      逃逸分析的性能收益必定高于它的消耗。如果要完全精准地判断一个对象是否会逃逸，需要
      进行数据流敏感的一系列复杂分析，从而确定程序各个分支执行时对此对象的影响。这是一
      个相对高耗时的过程，如果分析完后发现没有几个不逃逸的对象，那这些运行期耗用的时间
      就白白浪费了，所以目前虚拟机只能采用不那么精确，但时间压力相对较小的算法来完成
      逃逸分析。还有一点是，基于逃逸分析的一些优化手段，如上面提到的栈上分配，由于
      hotspot虚拟机目前的实现方式导致栈上分配实现起来比较负责，因此在hotport中暂时还
      没有做这项优化。
       在测试结果中，事实逃逸分析后的程序在microbenchmark中往往能运行处不错的成
       绩，但是在实际的应用程序，尤其是大型程序中反而发现实时逃逸分析可能出现效果不稳定
       的情况，或因分析过程耗时但却无法有判别出逃逸对象而导致性能及时编译的收益
       有所下井，所以在很长的一段时间里，及时是servercompiler也默认不开启逃逸分析，设置
       某些版本jdk1.6
        update18中还曾经短暂的完全禁止了这项优化。
        
           如果有需要，并且确认对程序运行有益，用户可以使用参数XX:+DoEscaptAnalysis
           来手动开启逃逸分析，开启之后可以通过参数-XX:+PrintEscapeAnalysis来查看分析结果。
有了逃逸分析支持之后，用户可以使用参数-XX:+EliminateAllocations来开启标量替换，使用
+XX:+EliminateLocks来开启同步消除，使用参数-XX:+PrintEliminateAllocations查看标量
的替换情况。

    尽管目前逃逸分析的技术仍不是十分成熟，但是他却是即时编译器优化技术的一个重要
    的发展方向，在今后的虚拟机中，逃逸分析技术肯定会支撑起一系列使用的有效的优化技术。

11.4 Java与c++的编译器对比
  大多数程序员都认为c++比java语言快,甚至觉得从java语言诞生以来执行速度
  缓慢的帽子就应当扣在他的头上,这种观点的出现是由于java刚出现的时候及时编译计数
  还不成熟,主要靠解释器执行的java语言性能确实比较底下.但目前及时编译计数已经
  十分成熟,java语言有可能在速度上与c++一争高下吗,要想知道这个问题的答案,让我们
  从两者的编译器谈起.
  jdk1.6 update23servercompiler中才默认开启逃逸分析.
  
  java与C的编译器对比实际上代表了最经典的即时编译器与静态编译器的对比,很大
  成都上也决定了java和c的性能对比的结果.因为无论是C还是JAVA代码,最终
  编译之后被机器执行的都是本地机器码,那种语言的性能更高,除了他们自身的API库
  实现的好坏以外,其余的比较就成了异常品编译器和拼输出代码指令的游戏.当然
  这种比较也是剔除了开发效率的片面对比,语言间孰优孰劣\谁快谁慢的问题都是很难有结果的
  争论,下面我们就回到正题,看看这两种语言的编译器有何种有事.
  
     java虚拟机的即时编译器与c的静态优化编译器相比,可能会由下列这些云因而
     导致输出的本地代码有一些劣势 下面列举的也包括一些虚拟机执行子系统的性能lueshi
     
     第一,因为即使编译器运行占用的是用户程序的运行时间,具有很大的时间压力,他能
 它能提供的优化手段也严重受制于编译成本.如果编译速度不能达到要求,那用户将在启动程序
 或程序的某部分察觉到重大延迟,这点使得即时编译器不敢随便引入大规模的优化技术,而
 编译的时间成本在静态优化编译器中并不是主要的关注点.
   第二,java语言是动态的类型安全语言,这就意味着需要由虚拟机来确保程序不会违反
语言语义或访问非结构化内存.从实现层上看,这就意味着虚拟机必须频繁地进行动态检
查,如实例方法访问时检查空指针\数组元素访问时检查上下界范围\类型转换时检查集成
关系等.对于这类程序代码没有明确写出的检查行为,尽管编译器会努力进行优化,但总体
上仍然要消耗不少的运行时间.
  第三,java语言中虽然没有virtual关键字,但是使用虚方法的频率却远远大于C语言,
这意味着运行时对方法接受者进行多台选择的频率要远远大于C语言,也意味着及时编译
在进行一些优化如方法内联时的难度要远大于C的静态优化编译器.
   第四,java语言是可以动态拓展的语言,运行时健在新的类可能改变程序类型的集成关系
,这是的很多全局的优化都难以进行,因为编译器无法看见程序的全貌,许多全局的优化
措施都只能以激进优化的方式来完成,编译器不得不时刻注意并随着类型的变化而在运行时
撤销或重新进行一些优化.

   第五,java语言中对象的内存分配都是堆上进行的,只有方法中的局部变量才能在栈上
分配.而C对象则有多种内存分配方式,极可能在堆上分配,又可能在栈上分配,
如果可以在栈上分配线程私有的对象,将减轻内存回收的压力.另外,C中主要由用户
程序代码来回收分配的内存,这就不存在无用对象筛选的过程,因此效率上仅指运行效率
,排除了开发效率也比垃圾收集机制要高.

  上面说了一大堆java语言相对C的lueshi,不是说java就真的不如C了,相信读者
也注意到了,java语言的这些性能上的掠视都是为了换取开发效率上的优势而付出的代价,
动态安全动态拓展\垃圾回收这些拖后腿的性能都为java语言开发效率做出很大贡献.
   何况,还有许多优化是java的即时编译器能做而C的静态优化编译器不能做或者
不好做的.例如,C中别名分析alias analyisi的难度就远高于java.java的
类型安全保证了在类似如下代码中,只要CA和B没有继承关系,那对象A和B
就绝不肯是同一个对象,及不会是同一块内存两个不同别名.

  确定了obja和b并发对方的别名后,许多与数据依赖相关的优化才可以进行重排序
  变量代还.具体到这个例子中,就是无需担心objb.y其实与X执行同一块内存
  这样就可以安全第一确定打印语句中的123
  
    java编译器另外一个红利就是它的动态性所带来的,由于jC编译器所有优化都在
编译期完成,以运行期性能监控为基础的优化措施他都无法进行,如调动频率预测call
frequency prediction 分支频率预测branch frequency prediction\剪切未被选择的分支
等,这些都会成为java语言的优势.
  11.5 小结
  
分别介绍了java程序从源码编译成字节码和从字节码编译成本地机器码
的过程,javac字节码编译器与虚拟机内的jit编译器的执行过程合并起来其实就等同于一个
传统编译器所执行的编译过程.
  本章中,我们着重了解了虚拟机的热点探测方法\hostspot的即时编译器\编译触发条件
  ,以及如何从虚拟机外部观察和分析JIT编译的数据和结果,还选择了集中常见的编译器
  优化技术进行讲解.对java编译器的深入了解,有助于在工作中分辨哪些代码是编译器可以
  帮我们处理的,哪些代码需要自己调节已变更适合编译器优化.





I.动态代理、字节码注入、Spring、AspectJ、JavaAssist、ASM

![RUNOOB 图标](https://github.com/dingsai88/SpringBootStudy/blob/master/img/AopAsmCglibAspectJ.png)
AOP 是一种编程思想，但是它的实现方式有很多，比如：AspectJ、JavaAssist、ASM 等。

jclasslib Bytecode viewer插件显示汇编



I.ASM:Assembly Language汇编语言
https://translate.googleusercontent.com/translate_f

https://asm.ow2.io/performance.html

1.简介

1.1 动机  ：生成，转换和分析已编译的Java类
处理已编译代码的好处是不需要源代码


•程序分析，范围从简单的语法分析到完整的语义分析，
可用于查找应用程序中的潜在错误，
检测未使用的代码，反向工程代码等。

•程序生成在编译器中使用。这包括传统的堆程序，
还有用于分布式程序的存根或骨架编译器-ming，
即时编译器等。

•程序转换可用于优化或混淆程序，将调试或性能监控代码插入应用程序中，
用于面向方面的编程等



ASM库提供了两个API，用于生成和转换已编译的classes




#子绮 fast Throw
http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/tip/src/share/vm/opto/graphKit.cpp

Modify options >add VM options > 增加 -server
 

开启 默认
-XX:+OmitStackTraceInFastThrow

关闭
-XX:-OmitStackTraceInFastThrow











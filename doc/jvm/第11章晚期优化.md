# 第10章（编译期）优化

   从计算机程序出现的第一天起，对效率的追求就是程序天生的坚定信仰，这个过程犹如一

场没有终点、永不停歇的F1方程式竞赛，程序员是车手，技术平台则是在赛道上飞车的赛车。

##### 10.1概述302

  java语言的编译期其实是一段不确定的操作过程，因为它可能是指一个前端编译

器（其实叫编译器的前端更准确一些）吧java文件转变成。class文件的过程；也可能是

指虚拟机的后端运行期编译器（jit编译器，justintime compiler）吧字节码转变成机器码的

过程；还可能是指使用静态提前编译器（AOT编译器，ahead of time compiler） 直接把*java

文件编译成本地机器代码的过程。下面列举了这三类编译过程中一些比较有代表性的编译器。

前端编译器:sum的javac、eclipsejdt中的增量式编译器ECJ

JIT编译器:hotspotVM的c1、c2编译器。

AOT编译器:GUN compiler for the javaGCJ ExcelsiorJET

​     这三类过程中最符合大家对java程序编译认知的应该是第一类，在本章的后续文字里，

笔者提到的编译期和编译器都仅限于第一类编译过程，把第二类编译过程留到下一

章中讨论。限制了编译范围后，我们对于优化二字的定义就需要宽松一些，因为javac

这类编译器对代码的运行效率几乎没有任何优化措施（在jdk1.3以后，javac的-O优化参

数就不再有意义）。虚拟机设计团队把对性能的优化集中到了后端的即时编译器重，这样可

以让那些不是由javac产生的class文件（如jruby\groovy等语言的class文件）也同样能

享受到编译器优化所带来的好处。但是javac做了许多针对java语言编码过程的优化错误来

改善程序员的编码风格和提高编码效率。相当多新生的java语法特性，都是靠编译器的语

法糖来实现，儿不是依赖虚拟机的底层改进来支持，可以说，java中即时编译器在运行期

的优化过程对于程序运行来说更重要，而前端编译器在编译期的优化过程对于程序编码来说

关系更加密切。



#### 10.2.2 解析与填充符号表

  解析步骤由图

- 准备过程：初始化插入式注解处理器
- I.解析与填充符号表-----------parseFiles
- 过程1.1：词法分析、语法分析
- 过程1.2：输入到符号表
- II.注解处理器-----------
- 过程2：执行注解处理
- III.语义分析与字节码生成------------
- 过程3：分析及字节码生成
- 过程3.1：标注
- 过程3.2：数据流分析
- 过程3.3：解语法糖
- 过程3.4：生成字节码

10.2.2解析与填充符号表

  解析步骤由图10-5中的parseFiles()方法(图10-5中的过程1.1)完成，解析步骤包括

了经典程序编译原理中的词法分析和语法分析两个过程。

 1.词法分析、语法分析

词法分析是将源代码的字符流转变为标记token即可，单个字符是编写过程的

最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为

标记，如int a=b+2这句代码包含了6个标记，分别是inta=b+2，虽然关键字

int由3个字符构成，但是它只是一个token，不可再拆分。在javac的源码中，词法分析过程

由com.sun.tools.javac.parser.Scanner类来实现。

​     语法分析是根据token序列构造抽象语法树的过程，抽象语法树abstract syntax tree ast

是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程

序代码中的一个语法结构construct例如包、类型、修饰符、运算符、接口、返回值甚

至代码注释等都可以是一个语法结构。

   图10-6 是根据elcipse ast view插件分析出来的某段代码的抽象语法树视图，读者可以

通过这张图对抽象语法树有一个直观的认识。在javac的源码中，语法分析过程由com.sun.

tools.javac.parser.parser类实现，这个阶段产出的抽象语法树由com.sun.tools.javac.treejctree

类表示，经过这个步骤之后，编译器就基本不会再对源码文件进行操作了，后续的操作都建

立在抽象语法树之上。

######    2.填充符号表

​     完成了语法分析和词法分析之后，下一步就是填充符号表的过程，也就是图10-5中

enterTrees方法所做的事情。符号表symbol table是由一组符号地址

和符号信息构成的表格，读者可以吧它想象成哈希表中k-v值对的形式实际上符

号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等。符号表中

所登记的信息在编译的不同阶段都要用到。在语义分析中，符号表所登记的内容将用于语义检查（如检查一个名字的使用和原先的说明是否一致）和产生中间代码。在目标代码生成阶

段，当对符号名进行地质分配时，符号表是地址分配的依据。

​    在javac源代码中，填充符号表的过程由com.sun.tools.java.comp.Enter类实现。此过程

的出口是一个待处理列表，包含了每一个编译单元的抽象语法树的顶级节点，

以及package-info的顶级节点。

#### 10.2.3 注解处理器

​    在jdk1.5之后，java语言提供了对注解annotation的支持，这些注解与普通的

java代码一样，是在运行期间发挥作用的。在jdk1.6中实现了jsr-269规范，提供了一组

出入式注解处理器的标准api在编译期间对注解进行处理，我们可以把它看做是一组编译器

的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件

在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直

到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个round，也

就是图10-4中的回环过程。

​    有了编译器注解处理的标准API后，我们的代码才有可能干涉编译器的行为，由于语法树

中的任意元素，设置包括代码注释都可以在插件之中访问到，所以通过插入值注解处理器实现的

插件在功能上有很大的发挥空间。只要有足够的创意，程序员可以使用插入式注解处理器实现

许多远门只能在编码中完成的事情，本章最后会给出一个使用插入式注解处理器的简单实战。

​       在javac源码中，插入式注解处理器的初始化过程是在initPorcessAnnotations()方

法中完成的，而它的执行过程则是在processAnnotations()方法中完成的，这个方法判

断是否还有新的注解处理器需要执行，如果有的话，通过com.sun.tools.javac.processing.

javaProcessingEnvironment里的doProcessing方法生成一个新的javaCompiler对象对编译

的后续步骤进行处理。

#### 10.2.4 语义分析与字节码生成

​    语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确

的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是对结构上正确

的源程序进行上下文有关的性质的审查，如进行类型审查。举个例子，假设有如下的三个变量

定义语句：

  int a=1;

boolean b=false;

char c=2;

后续可能出现的赋值运算：

int d=a+c;

int d=b+c;

char d=a+c;

后续代码中如果出现了如上三种赋值运算的话，那它们都能构成结构正确的语法树，但

是只有第一种的写法在语义上是没有问题的，能够通过编译，其余两种在java语言中是不合

逻辑的，无法编译(是否合乎语义逻辑必须限定在具体的语言与具体的上下文环境之中才有

意义。如在C语言中，a\b\c的上下文定义不变，第2、3种写法都是ikeyi正确编译)。

  1.标注检查

  javac的编译过程中，语义分析过程分为标注检查以及数据及控制流分析两个步骤，分别

由图10-5中所示的attribute和flow方法（分别对应图10-5中的过程3.1和过程3.2）完成。

​    标注检查步骤检查的内容包括诸如变量使用前是否已经被声明、变量与复制直接的数据类

型是否能够匹配等。在标注检查步骤中，还有一个重要的动作称为常量折叠，如果我们在代

码中写了如下定义：

  int a=1+2;

那么在语法树上仍然能看到字面量“1”，“2”以及操作符“+”，但是在经过常量折叠之后，他们将会被折叠为字面量3，如图10-7所示，这个插入式表达

式infix expression的值已经在语法树上标注出来了

（constantExpressionValue:3）。由于编译期间进

行了常量折叠，所以在代码里面定义“a=1+2”比起

直接定义"a=3",并不会增加程序运行期哪怕仅仅

一个CPU指令的运算。

  标注检查步骤在javac源码中的实现类是com.

sun.tools.javac.comp.Attr类和com.sun.tools.javac.comp.Check 类。

###### 2.数据以及控制类分析

数据以及控制类分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变

量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的的受查异常都被正确处理里等问题。编译事情的数据以及控制流分析与类加载时的数据以及控制类分析的目的基本上是一致的，但是校验范围有所区别，有一些校验项只有在编译期或运行期才能进行。下面举一个关于final修饰符的数据以及控制类分析的离职，见代码清单10-1.

public void foo(final int arg){

​    final int var=0;

//do somthing

}

public void foo(int arg){

   int var=0;

//do something

}

  在这两个foo（）方法中，第一种方法的参数和局部变量定义使用了final修饰符，而第

二种方法则没有，在代码编写时程序肯定会受到final修饰符的影响，不能再改变arg和var

变量的值，但是在两段代码编译器出来的class文件是没有任何一点区别的，通过第六章的讲

解我们已经知道，局部变量与字段（实例变量，类变量）是有区别的，它在常量池中没有

CONSTANT——fielref_inf的符号引用，自然就没有访问标志access_flags的信息,设置

可能连名称都不会保留下来（取决于编译时的选项），自然在class文件中不可能知道一个局

部比那里是不是声明为final了，因此，将局部变量声明为final，对于运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保障。在javac的源码中，数据以及控制类分析的入口是

图10-5中的flow方法com.sun.tools.javac.comp.Flow类来完成。

3.解语法糖

语法糖（Syntactic sugar）,也称为糖衣语法，是由英国计算机科学家彼得。约翰、兰大

peter j.landin发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能

并没有影响，但是更方便程序员使用。通常来说，使用语法糖能够增加程序的可读性，从而

减少程序代码出错的机会。

​     Java在现代编程语言之中属于“低糖语言”（相对于C#以及许多其他JVM语言来说），尤

其是JDK1.5之前的版本，“低糖”语法也是java语言被怀疑已经“落后”的一个表面理由。

java中最常用的语法糖主要是前面提到过的泛型（泛型并不一定都是语法糖实现，如C#的

泛型就是直接由CLR支持的）、变长参数、自动装箱、拆箱等，虚拟机运行时不支持这些语

法，它们在编译阶段还原回简单的基础语法结构，这个过程称为语法糖。java的这些语法

糖被接触后是什么样子，将在10.3节中详细讲述。

   在javac的源码中，解语法糖的过程由desugar方法触发，在com.sun.tools。javac。comp.TransTypes类和com.sun.tools.javac.comp.Lower类中完成。

###### 4.字节码生成

 字节码生产是javac编译过程的最后一个阶段，在javac源码里面由com.sun.tools.javac.

jvm.Gen类来完成。字节码生成阶段不仅仅是吧前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。

例如，前面章节中多次提到的实例构造器《init》方法和类构造器<clinit>方法就是

在这个阶段添加到语法树之中的（注意，这里的实力构造器并不是指默认构造函数，如果

用户代码中没有提供任何构造函数，这个工作在填充符号表阶段就已经完

成），这两个构造器的产生过程实际上是一个代码收敛的过程，编译器会把语句块（对于实

例构造器而言是｛｝块，对于类构造器而言是static块）、变量初始化（实例变量

和类变量）、调用父类的实力构造器（仅仅是实例构造器，《clinit》方法中经常会生成

调用java.lang.object的init方法的代码）等操作瘦脸到init和clinit方法之

中，并且保证一定是按照先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序

进行，上面所述的动作由Gen.normalizeDefs方法来实现。除了生产构造器以外，还有其他

的一些代码替换工作用语优化程序的实现逻辑，如吧字符串的加操作替换为stringbuffer或

stringbuilder取决于目标代码的版本是否大于等于1.5的appedn操作等。

##### 10.3 Java语法糖的味道

   几乎各种语言或多或少都提供过一些语法糖来方便程序员的代码开发，这些语法糖虽

然不会提供实质性的功能改进，但是他们或能提高效率，或能提升语法的严谨性，或能减少

编码出错的机会。不过也有一种观点认为语法糖并不一定都是有益的，大量添加和使用含糖

的语法，容易让程序员产生依赖，无法看清语法糖并不一定都是有益的，成

##### 10.3.1 泛型与类型擦除

​    泛型是JDK1.5的一项新增特性，它的本质是参数化类型parametersized type 的应

用，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法

的创建中，分别称为泛型类，泛型接口和泛型方法。

   泛型思想早在C++语言的模版template中就开始生根发芽，在java语言处于还没

有出现泛型的版本时，只能通过Object是所有类型的父类和类型强制转换两个特点的配合来

实现类型泛华。例如，在哈利表的存取中

·	······

  当初JDK设计团队为什么选择类型擦除的方式来实现java语言的反省支持呢，是因为

实现简单、兼容性考虑还是别的原因？我们已不得而知，但确实有不少人对java语言提供的

伪泛型颇有微词，当时甚至连thinking in java一书的作者bruce eckel也发飙了一篇文章

这不是泛型来批评jdk1.5中的泛型实现。

​    当时众多的批评之中，有一些是比较表面的，还有一些从性能上说泛型会由于强制转型

操作和运行期缺少针对类型的优化等从而导致比C#的泛型慢一些，则是完全偏离了方向，则是完全偏离了方向，姑且不论java泛型是不是真的会比C#泛型慢，选择从性能的角度上评价用于提升语义准确性的

泛型思想就不太恰当。但笔者也并非在为java的泛型辩护，它在某些场景下确实存在不足，

笔者认为通过擦除法来实现泛型丧失了一些泛型思想应用的优化，例如代码清单10-4的例子。

   请想一想，上面这段代码是否正确,能否编译执行？也许你已经有答案，这段代码是

不能被编译的，因为参数list integer和liststring编译之后都被擦除了，变成了一样的

原生类型LIST，擦除动作导致这两种方法的特征签名变得一模一样。初步看来，无法重

载的原因已经找到了，但真的就是如此吗？只能说，泛型擦除成相同的原生类型只是无法重

载的其中一部分原因，请再接着看一看代码清单内容



差别是两个method方法添加了不同的返回值，由于这

两个返回值的家人，方法重载居然成功了，即这段代码可以被编译和执行了。这是对java

语言中返回值不参与重载选择的基本认知的挑战吗?

  代码清单10-5中的重载当然不是根据返回值来确定的，之所以这次能编译和执行成功，

是因为两个method方法加入了不同的返回值后才能共存在一个class文件之中。第六章介

绍class文件方法表methodinfo的数据结构时曾经提到过，方法重载要求方法具备不同

的特征前面，返回值并不包含在方法的特征前面之中，所以返回值不参与重载选择，但是在

class文件格式之中，只要描述符不是完全一直的两个方法就可以共存。也就是说，两个方

法如果有相同的名称和特征签名，但返回值不同，那他们也是可以何方地工作在于一个class

文件中的。

​    由于java泛型的引入，各种场景虚拟机解析反射等下的方法调用都可能对原有的

基础产生影响和新的需求，如在泛型类中如何获取传入的参数和类型等。因此JCP组织对

虚拟机规范做出了响应的修改，引入诸如signature、localVariableTypeTable等新的属性用

于解决伴随泛型而来的参数类型的识别问题，signatrue是其中最重要的一项属性，他的作用

就是存储一个方法在字节码层面的特征签名，这个属性中报错的参数类型并不是原生类型，

而是包括了参数化类型的信息。修改后的虚拟机规范要求所有能识别49以上版本的class

文件的虚拟机都要能正确地识别signatrue参数。  

​    从上面的例子可以看到擦除法对实际编码带来的影响，由于list string和list integer

擦除后是同一个类型，我们只能添加两个并不需要实际使用到的返回值才能完成

重载，这是一种毫无优化和美感可言的解决方案，并且存在一定语义上的混乱，譬如上面

脚注中提到的，必须用SUNJDK1.6的javac才能编译通过，其他版本或者ECJ编译器都可

能拒绝编译。

​     另外，从Signature属性的出现我们还可以得出结论，擦除法所谓的擦除，紧紧是对方法的

code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能

通过反射手段取得参数和类型的根本依据。

##### 10.3.2  自动装箱、拆箱与遍历循环

​    从纯技术的角度来讲，自动装箱、自动拆箱与遍历循环foreach循环这些语法糖，无论

是实现上还是思想上都不能和上文介绍的泛型相比，两者的难度和深度都有很大差距。专门拿出

一届来讲解他们只有一个理由“毫无疑问”，他们是java语言里使用的最多的语法糖。我们通过

代码清单10-6和代码清单10-7中所示的代码来看这些语法糖在编译后会发生什么样的变化

​    代码清单10-6中一共包含了泛型、自动装箱、自动拆箱、遍历循环与变长参数5种语

法糖，代码清单10-7则展示了他们在编译后的变化。泛型就不比说了，自动装箱、拆箱在编

译之后被转换成了对应的包装和还原方法，如本例中的integer.valueOf与integer.iniValue

方法，而遍历循环则吧代码还原成了迭代器的实现，这也是为何遍历循环需要被遍历的类实

现iterable接口的原因。最后再看看变长参数，它在调用的时候变成了一个数组类型的参数，

在变长参数出现之前，程序员就是使用数组来完成类似功能的。

这些语法糖虽然看起来很简单，但也不见得就没有任何值得我们注意的地方，代码清单

10-8演示了自动装箱的一些错误用法。

这两个问题的答案可以很容易试验出来，

笔者就暂且略去答案，希望读者自己上机实践一下。无论读者的回答是正确，鉴于

包装类的==运算在不遇到算数运算的情况下不会自动拆箱，以及它们equals方法不处

理数据转型的关系，笔者建议在实际编码中进来避免这样使用自动装箱与拆箱。

##### 10.3.3 条件编译

   许多程序设计语言都提供了条件编译的途径，如C、C++中使用预处理器指示符

#ifdef来完成条件编译。C、C++的预处理器最初的任务是解决编译时的代码依赖关系（如

非常常用的#include预处理命令），而在java语言之中并没有使用预处理器，因为java语言

天热的编译方式（编译器并非一个各地编译java文件，而是将所有编译单元的语法树顶级节点

输入到待处理列表后再进行斌阿姨，因此各个文件之间能够互相提供符号信息）无须使用预

处理器。那java语言是否有版本实现条件编译呢？

​     Java语言当然也可以进行条件编译，方法就是使用条件为常量的if语句。如代码清单10-9

所示，此代码中的if语句不同于其他java代码，它在编译阶段就会被运行，生成的字节码

之中只包括system.out.printlnblock1 一条语句，并不会包含if语句以及另外一个分子中的

system.out.println block2



​      只能使用条件为常量的if语句才能达到上述效果，如果使用常量与其他带有条件判断能

力的语句搭配，则可能在控制类分析中提示错误，被拒绝编译。



​       java语言中条件编译的实现,也是java语言的一颗语法糖，根据布尔常量值的真假，

编译器将会吧分支中不成立的代码块消除掉，这一工作将在编译器接触语法糖阶段（com.sun.tools.javac.comp.Lower类中）完成。由于这种条件编译的实现方式使用了if语句，所以

它必须遵守最基本的java语法，只能卸载方法体内部，因此它只能实现语句基本块(Block)

级别的条件编译，而没有办法实现根据条件调整整个java类的结构。

 

​    除了本节中介绍的泛型、自动装箱、自动拆箱、编译循环、变长参数和条件编译之外，

java语言还有不少语法糖，如内部类、枚举类、断言语句、对枚举和字符串在JDK

1.7中支持的switch支持、try语句中定义和关闭资源等，读者可以通过跟踪javac源码、反编译class文件等方式了解他们的本质实现，鉴于篇幅，笔者就不一一

介绍了



#### 10.4 实战：插入式注解处理器

​    jdk编译优化部分在本书中并没有设置独立的实战章节，因为我们开发程序，考虑的主要

是程序会如何运行，很少会针对程序编译的需求。也因为这个原因，在jdk的编译子系统

里面，提供给用户直接控制的功能能相对较少，除了第11张会介绍虚拟机jit编译的几个

相关参数以外，我们就只有使用JSR-296中定义的插入式注解处理器API来对JDK编译子

系统的行为产生一些影响.

   但是笔者并不认为相对于前两部分介绍的内存管理子系统和字节码执行子系统，JDK的

编译子系统就不那么重要。一套编程语言中编译子系统的优劣，很大程序上决定了程序运行

性能的好坏和编码效率的高低、尤其在java语言中，运行期及时编译与虚拟机执行子系统非常

紧密地互相依赖、配合运作。了解JDK如何斌阿姨和优化

代码，有助于我们写出合适JDK自优化的程序。下面我们回到本章的实战中，看看插入式

注解处理器API能实现什么功能。

###### 10.4.1 实战目标

   通过阅读javac编译器的源码，我们知道编译器在吧java程序源码编译为字节码的

时候，会对java程序源码做各方面的检查校验。这些校验主要以程序写的对不对为

出发点，虽然也有各种WARNING的信息，但总体来讲还是较少去校验程序写的好不好。

。有鉴于此，业界出现了许多针对程序写的好不好的辅助校验工具，如checkstyle

findbugklocwork等。这些代码校验工具有一些是基于java的源码进行校验，还有一些是

通过扫描字节码来完成，在本节的实战中，我们将会使用注解处理器API来编写一款拥有自己

编码风格的校验工具：nameCheckprocessor.

   当然，由于我们的实战都是为了学习和演示技术原理，而不是为了做出一款能媲美

CheckStyle等工具的产品来，所以NameCheckProcessor的目标也仅定位对java程序命名进行

检查，根据java语言规范第三版中第6.8节的要求，java程序命名应当符合下列各

式的书写规范。

类或接口：符合驼式命名法，首字母大写。

方法：符合驼式命名法，首字母小写。

字段：

类或实例变量：符合驼式命名法，首字母小写。

常量：要求全部由大写字母或下划线构成，并且第一个字符不能是下划线。

   上文提到的驼式命名法camel case name,正如它的名称所标识的那样，是指混合使

用大小写字母来分割构成变量或函数的名字，犹如驼峰一般，这是当前java语言中流的命名

规范，我们的实战目标就是为javac编译器添加一个额外的功能，在编译程序时检测程序

名是否符合上述对类或接口方法字段的命名要求。

##### 10.4.2 代码实现

   要通过注解处理器API实现一个编译器插件，首先需要了解这组API的一些基本知识。

我们实现注解处理器的代码需要继承抽象类javax.annotation.processing.AbstractProcessor,

这个抽象类中只有一个必须覆盖的abstract方法：process它是javac编译器在执行

注解处理器代码时要调用的过程，我们可以从这个方法的第一个参数annotations中

获取到此注解处理器所要处理的注解集合，从第二个参数roundEnv中访问到当前这个

round中的语法树节点，每个语法树节点在这里表示为一个element在jdk1.6新增

的javax.lang.model包中定义了16类的elment，包括了java代码中国最常用的元素，如：

包package枚举enum类class、注解annotation_type接口interface枚举值enum_constant、字段field、参数parameter、本地变量、local_variable、异常exception_parameter、方法method、构造函数constructor、静态语句块static_init、实例语句块

instance_init、参数和类型type_parameter,既泛型尖括号内的类型

和未定义的其他语法树节点other.除了process方法的传入参数之外，还有一个很

常用的实例变量processingEnv它是abstractProcessor中的一个protected变量,在注解

处理器初始化的时候init方法执行的时候创建，集成了abstractProcessor的注解处理器

代码可以直接访问到它。它代表了注解处理器框架提供的一个上下文环境，要创建新的代码、

向编译器输出信息、获取其他工具类等都需要用到这个实例变量。

  注解处理器除了process方法以及其他阐述之外，还有一个很常用

的实例变量processingenv踏实abstractprocessor中的一个protectred变量，在注解

处理器初始化的时候init方法执行的时候创建，集成了abstractprocessor的注解处理器代码可以直接访问到它。它代表了注解处理器框架提供的一个上下文环境，要创建新的代码

向编译器输出信息、获取其他工具类等都需要用到这个实例变量。

   注解处理器除了process方法以及其他参数之外，还有两个可以配合使用的annotations

supportedAnnotationType和supportedSourceBersion,前者代表了这个注解处理器对那些

注解感兴趣，可以使用*座位通配符代表对所有的注解都感兴趣，后者支出这个注解处理器

可以处理那些版本的代码。

​    每一个注解处理器在运行的时候都是单例的，如果不需要改变或生成语法树的内容，

process方法就可以返回一个false的布尔值，通知编译器这个round中的代码未发生

变化，无需构造新的javacompiler实例，在这里实战的注解处理器中只对程序命名进行检查

，不需要改变语法树的内容，因此process方法的返回值都是false。关于注解处理器的

API，笔者就简单介绍这些，这个领域有兴趣的读者可以阅读相关的帮助文档。下面来

看看注解处理器NameCheckProcessor的具体代码

javax.lang.model.element.ElementKind

​    NameChecker的代码看起来有点长，但实际上注释占了很大一部分，其实即使

算上注释也不到190行。它通过一个继承与javax.lang.model.util.ElementScanner6的

NameCheckScanner类，以Vistor模式来完成对语法树的遍历，分别执行visitType()、

visitVariable和visitExecutalbe方法来访问类、字段和方法，这三个visit方法对各个的命

名规则做相应的检测，checkCamelCase与checkAllCaps方法则用于实现驼式命名法和全

大写命名规则的检查。

P326

​     整个注解处理器只需要NameCheckProcessor和NameChecker两个类就可以全部完成，为

了验证我们的实战成果，代码清单10-13中提供了一段命名规范的反面交代码



###### 10.4.3 运行与测试

​    我们可以通过javac命令的 -processor  参数来执行编译时需要附带的注解处理器，如

果有多个注解处理器的话，用都好分割。还可以使用-XprintRounds和-XprintProcessorInfo

参数来查看注解处理器的运作的详细信息，本次实战中的NameCheckProcessor的编译以及执行过程

10.4.4 其他应用案例

​    NameCheckProcessor的实战例子只演示了 JSR-269嵌入式注解处理器API中的一部分功

能，基于这组API支持的项目还有用于校验hibernate标签使用正确性的hibernate validator

Annotation Processor、自动为字段生成

getter和setter方法的Project Lombok等读者有兴趣的话可以参考他们官方站点的相关内容。

##### 10.5 本章小结

   本章中，我们从编译器源码实现的层次上了解了java源代码编译为字节码的过程，分析

了java语言中泛型、主动装箱拆箱、条件编译等多种语法糖的前因后果，并实战练习了

如何使用插入式注解处理器来完成一个检查程序命名规范的编译期插件。如本章概述所说

的那样，在前端编译器中，优化手段主要用于提升程序的编码效率，只所以吧javac这里

讲java代码砖面为字节码的编译器乘坐前端编译器，是因为它只完成了从程序到抽象语法

树活中间字节码的生产，而在此之后，还有一组内置于虚拟机内部的后端编译器完成

了从字节码生成本地机器码的过程，及前面多提提到的即时编译器或JIT编译器，这个编译

器的编译速度以及编译记过的优略，是横岭虚拟机性能一个很重要的指标。在第11章中，我们

将会介绍即使编译器的运作和优化过程。



#  第11章 晚期（运行期）优化

从计算机程序出现的第一天起，对效率的追求就是程序天生的坚定信仰，这个过程犹如一

场没有终点、用不停歇的F1方程式竞赛，程序员是车手，技术平台则是在赛道上飞驰的赛车。

### 11.1 概述

   在部分的商用虚拟机sun hotspot ibmj9中，java程序最初是通过解释器

interpreter 进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会吧

这些代码认定为热点代码hot spot code .为了提高热点代码的执行效率,在运行时，

虚拟机将会吧这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个

任务的编译器成为即时编译器just in time compiler 下文中简称jit编译器。

   即时编译器并不是虚拟机必须的部分，java虚拟机规范并没有规定java虚拟机内不许要

有即时编译器存在，更没有限定或知道即时编译器应该如何去实现。但是，即时编译器编译性能

的好坏、代码优化程度的高低确实衡量一款商用虚拟机优秀与否的最关键的指标之一，

它是虚拟机中最核心且最能体现虚拟机技术水平的部分。在本章中，我们将走虚拟机的

内部，探索即时编译器的运作过程。

   由于java虚拟机规范没有具体的约束规则去限制及时比爱你以前应该如何实现，所以这部

分功能完全是与虚拟机具体实现相关的内容，如无特殊说明，

本章提及的编译器、及时编译器都是指hotspot虚拟机内的即时编译器,虚拟机也是特指

hotspot虚拟机。不过，本章的大部分内容是描述即时编译器的行为，设计编译器实现层面

的内容较少，而主流虚拟机中即时编译器的行为有有很多相似和相同之处，因此，对其他虚拟机

来说也具有较高的参考意义。



##### 11.2 HotSpot虚拟机内的即时编译器

   在本节中，我们将要了解HotSpot虚拟机内的即时编译器的运作过程，同时，还要解决

以下几个问题：

   为何hotspot虚拟机要使用解释器与编译器并存的架构

为何hotpot虚拟机要实现两个不同的即时编译器

程序何时使用解释器执行？何时使用编译器执行

那些程序代码会被编译为本地代码？如何编译为本地代码？

如何从外部观察即时编译器的编译过程和编译结果



通过解释器interpreter 进行执行

优化为本地代码

即时编译器 jit 编译器



###### 11.2.1 解释器与编译器

​    尽管并不是所有的java虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚

拟机，如hotspotj9等，都同事包含解释器与编译器。解释器与编译器两者个有优势：当

程序需要循序启动和执行的是，解释器可以寿险发挥作用，省区编译的是加你，立即执行。

在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码

之后，可以获取更高的执行效率。当程序运行环境中内存资源限制较大如部分嵌入式系统

中，可以使用解释器执行节约内存，反之可以使用编译执行来提升效率。同时，解释器还可以

座位编译器激进优化时的一个逃生门，让编译器根据改了选择一些大多数时候都能提升运

行速度的优化手段，当激进优化的假设不成立，如加载了辛磊后类型集成结构出现变化、出现

罕见陷阱uncommon trap时可以通过逆优化退回到解释状态继续

执行 部分没有解释器的虚拟机中也会采用不进行激进优化的C1编译器单人逃生门的

角色，因此，在整个虚拟机执行架构中，解释器与编译器经常配合工作 

  HotSpot虚拟机中内置了两个即时编译器，分别成为Client Compiler 和server Compiler

或者简称为C1编译器和C2编译器页脚OPTO编译器。目前主流的 HotSpot虚拟机Sun

系列JDK1.7及之前的版本的虚拟机中，默认采用解释器与其中一个编译器直接配合的方式

工作，程序使用那个编译器，取决于虚拟机运行的模式，hostpot虚拟机会根据自身版本与

宿主机器的硬件性能自动选择运行模式，用于也可以使用-client或server参数去强制

指定虚拟机运行在client模式或server模式

   无论采用的编译器是client compiler还是server compiler解释器与编译器搭配使用的方

式在虚拟机中成为混合模式mixed mode 用户可以使用参数-xint 强制虚拟机运行于

解释模式 interpreted mode,这时编译器完全不接入工作，全部代码都使用解释方式执行。

另外，也可以使用参数-xcomp 强制虚拟机运行于编译模式 compiled mode 这时

将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下接入执行过程，可

以通过虚拟机的-version命令的输出结果显示出这三种模式，如代码清单11-1所示，请注意黑体字部分

java -version  : mixed mode

java -Xint -version : interpreted mode

java -Xcomp -version : compiled mode

​    由于即时编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，

所花费的时间可能更长；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收

集性能呢监控信息，这对解释执行的速度也有影响。为了在程序启动响应速度与程序运行效率之间

达到最佳平衡，hotpot虚拟机还会主键启用分层编译Tiered Compilation 的策略，分层

编译的概念在JDK1.6时期出现，后来一直处于改进阶段，最终在JDK1.7的server模式虚

拟机中座位默认编译策略被开启。分层编译根据编译器编译、优化的规模与好事，划分出不同

的编译层次，其中包括：

第0层，程序解释执行，解释器不开启性能监控功能profilinig，可触发第一层编译。

第1层，也称为C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如有

必要将加入性能监控的逻辑。

第2层，也称为C2编译，也是将字节码编译为本地代码，但是会启用

一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可控的激进优化。

  实施分层编译后，Client Compiler和Server Compiler将会同时工作，许多代码都可能会

被多次编译，用Client Compiler 获取更高的编译速度，用Server Compiler来获取更好的编译

质量，在解释执行的时候也无须再承担收集性能监控信息的任务。

###### 11.2.2 编译对象与触发条件

   上文中提到过，在运行过程中会被即使编译器编译的热点代码有两类，即“

被多次调用的方法。

被多次执行的循环体。

前者很好理解，一个方法被调用得多了，方法体内代码执行的次数自然就多，它成为

热点代码是理所当然的。而后者则是为了解决一个方法只被调用过一次或少量几次，

但是方法体内部存在循环次数较多的循环体的问题，这样循环体的代码也被重复执行多次，

因此这些代码也应该认为是热点代码。

​    对于第一种情况，由于是由方法调用触发的编译，因此编译器理所当然地会以整个方

法作为编译对象，这种编译也是虚拟机中标准的JIT编译方式。而对于后一种情况，尽管编

译动作是由循环体所触发的，但编译器依然会以整个方法（而不是单独的循环体）座位编译

对象。

这种编译方式因为编译发生在方法执行过程之中，因此形象地称之为沾上替换Stack 

Replacement ,简称为OSR编译，及方法栈帧还在沾上，方法就被替换了。

​    读者可能还会有疑问，在上面的文字描述中，无论是多次执行的方法，还是多次

执行的代码块，所谓多次都不是一个具体，严谨的用于，那到底多少次才算多次

呢？还有一个问题，就是虚拟机如何统计一个方法或一段代码被执行过多少次呢？解决了这

两个问题，也就回答了即使编译被触发的条件.



  判断一段代码是不是热点代码，是不是需要触发及时编译，这样的行为成为热点探测

hot spot detection,其实进行热点探测并不一定要知道方法具体被调用了多少次，目前主

要的热点探测判断方式有两种，分别如下。

1.基于采样的热点探测Sample based hot spot detection 采用这种方法的虚拟机会

周期性地检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那这个

方法就是热点方法。基于采样的热点探测的好处是实现简单、高效，还可以很

容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精准地确认一个方法

的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。



2.基于计数器的热点探测Counter based hot spot detection:采用这种方法的虚拟机

会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超

过一定的阈值就认为他是热点方法。这种统计方法实现起来麻烦一些，需要为每个

方法加你并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果

相对来说更加精准和严谨。

  在hotspot虚拟机中使用的是第二种---基于计数器的热点探测方法，因此它为每个方法

准备了两类计数器：方法调用计数器（invocation Counter）和回边计数器(Back Edge counter)

​    在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈

值溢出了，就会触发JIT编译。

   我们首先来看看方法调用计数器。顾名思义,这个计数器就用于统计方法被调用的次

数，它的默认阈值在client模式下是1500次，在Server模式下是10000次，这个阈值可以

通过虚拟机参数-XX:CompileThreshold来认为设定。当一个方法被调用时，会先检查该

方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不

存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边

计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提

交一个该方法的代码编译请求。

  如果不做任何设置，执行引擎并不会同步等待编译请求完成，而是继续今日解释器按照

解释方法执行字节码，知道提交的请求被编译器编译完成。当编译工作完成之后，这个方法

的调用入口地址就会被系统自动改写成新的，下一次调用改方法时就会使用已编译的版本。

整个JIT编译的交互过程如图11-2所示。

![1557718279890](C:\Users\Administrator.CE-20160511RDFS\AppData\Roaming\Typora\typora-user-images\1557718279890.png)

​          如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相

对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调

用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，

这个过程称为方法调用计数器热度的衰减（Counter Decay）,而这段时间就称为此方法统计

的半衰周期(Counter half life time)。进行热度衰减的动作是在虚拟机进行垃圾收集时顺便

进行的，可以使用虚拟机参数-XX:-UseCounterDecay来关闭热度衰减，让方法计数器统计

方法调用的绝对次数，这样，只要系统运行时间足够从，绝大部分方法都会被编译成本地代码

。另外可以使用=XX:CounterHalfLifeTime参数设置绊摔周期的时间，单位是秒。

​    现在我们再来看看另外一个计数器---回边计数器，它的作用是统计一个方法中循环体

代码执行的次数，在字节码中遇到控制流向后跳转的指令成为回边back edge。先让，

建立回边计数器统计的目的就是为了触发OSR编译(栈上替换On Stack Replacement,方法栈帧还在栈上，方法就被替换了)。

   关于回边计数器的阈值，虽然HOTSpot虚拟机也提供了一个类似于方法调用计数器阈值

-XX:CompileThreshold的参数 --XX:BackEdgeThreshold供用户设置，但是当前的虚拟机

实际上并未使用此参数，因此我们需要设置另外一个参数-XX:OnstackReplacePercntage来

问接调整回边计数器的阈值，其计算公式如下。

- 虚拟机运行在Client模式下，回边计数器阈值计算公式为：

   方法调用计数器阈值（CompileThreshold）*OSR比率(OnstackReplacePercentage)/100

其中OnstackReplacePercentage默认值为933，如果都取默认值，那Client模式虚拟机

的回边计数器的阈值为13995。 1500*OSR933/100=13995

-   虚拟机运行在server模式下，回边计数器的阈值的计算公式为：

方法调用计数器阈值CompileThreshold*osr比率OnstackReplacePercentage-

解释器监控比率interpreterProfilePercentage/100

其中OnstackReplacePercentage默认值为140，InterpreterProfilePercentage默认值为33，

如果都取默认值，那Server模式虚拟机回边计数器的阈值为10700.

​    当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经变异好的版本，

如果有，它将会有限执行已变异的代码，否则就会吧回边计数器值加1，然后判断方法

调用计数器与回边计数器值之和是否超过回边计数器的阈值。当超过阈值的时候，将会提交

一个OSR编译请求，并且吧回边计数器的值降低一些，以便继续在解释器中执行循环，等

待编译器输出编译结果，整个执行过程如图11-3所示。（OSR On stack Replacement 方法栈帧还在栈上，方法就被替换了）

​    如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相

对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调

用次数仍然不足以让它提交给即使编译器编译，那这个方法的调用计数器就会被减少一半，

  与

![1557822378832](C:\Users\Administrator.CE-20160511RDFS\AppData\Roaming\Typora\typora-user-images\1557822378832.png)



  与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是

改方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出

状态，这样下次再进入该方法的是就会执行标准编译过程。

​    最后需要提醒 一点，图11-2和图11-3都仅仅描述了Clientvm的即时编译器方式，对于

serverVM来说，执行情况会比上面的描述更复杂一些。从理论上了解过编译对象和编译触发

条件后，我们再从hotspot虚拟机的源码中观察一下，在methodoop.hpp一个methodoop

对象代表了一个java方法中，定义了java方法在虚拟机中的内存布局，如下所示：



![1557822712820](C:\Users\Administrator.CE-20160511RDFS\AppData\Roaming\Typora\typora-user-images\1557822712820.png)

​    在这个内存布局中，一行长度为32bit，从中可以清楚地看到方法调用计数器和回边计数器

所在的位置和长度。。还有from_compiled_entry和from_interpreted_entry这两个方法的入口。

###### 11.2.3编译过程

  在默认设置下，无论是方法调用产品的即时编译请求，还是OSROSR编译请求，虚拟机在

代码编译器还未完成之前，都仍然将按照解释方式继续执行，而编译动作则在后台的编译线

程中进行。用户可以通过参数-XX：-BackgroundCompilation来禁止后台编译，在禁止后台

编译后，一看达到JIT的编译条件，执行线程向虚拟机提交编译请求后将会一直等待，直到

编译过程完成后再开始执行编译器输出的本地代码。

   那么在后台执行编译的过程中，编译器做了什么事情呢，serverCompiler和Client Compiler

两个编译器的编译过程是不一样的。对于Client Compiler来说，它是一个简单快速

的一段式编译器，主要的关注点在于局部性的优化，而方式了许多耗时较长的全局优化手段。

​    在第一个阶段，一个平台独立的前端将字节码构成一种高级中间代码标识High-

Level Intermediate Representaion HIR 。HIR使用静态单分配Static single Assignment,

SSA的形式来代表代码值，这可以使得一些在HIR的构造过程之中和之后进行的优化动作

更容易实现。再次之前编译器会在字节码上完成一部分基础优化，如方法内联、常量传播等

优化将会在字节码被构造成HIR之前完成。

​         在第二个阶段，一个平台相关的后端从HIR中产生低级中间代码表示Low-level

Intermediate representation LIR,而在此之前会在HIR上完成另外一些优化，如空值检查

消除、范围检查消除等，以便让HIR达到更高效的代码表示形式。

​       最后阶段是在平台相关的后端使用线性扫描算法Linear scan Register allocation

在LIR上分配寄存器，并在LIR上做Peephole 优化，然后产生机器代码。Client

Compiler的大致执行过程如图11-4所示。

字节码》方法内联》常量传播》其他优化

HIR（SSA形成）》其他优化》范围检查消除》空值检查消除》优化后的HIR》HIR到LLR转换

LTR》寄存器分配》窥孔优化》机器码生成》本地代码

   而server Compiler 则是专门面相服务端的典型应用并为服务端的性能配置特别调整过

的编译器，也是一个充分优化过的高级编译器，几乎能达到GNUc++编译器使用-O2参数

时的优化强度，它会执行所有经典的优化动作，如无用代码消除（Dead Code elimination）、

循环展开loop unrolling 、循环表达式外提loop expression hoisting、消除公共子表达

式common subexpression elimination、常量传播constant propagation、基本块重排序

basic block reordering 等，还会实时一些与java语言特性密切相关的优化技术，如范围

检查消除range-check elimination、控制检查消除null check elimination，不过并非所有

的控制检测消除都是依赖编译器优化的，有一些是在代码运行过程中自动优化了等。另

外，还可能根据解释器或ClientCompiler提供的性能监控信息，进行一些不稳定的激进优

化，如守护内联Guarded Inlinging、分支频率预测BranchFrequency Prediction等。本章

的下半部分将会挑选上述的一部分优化手段进行分析和讲解。

  Server Compiler


































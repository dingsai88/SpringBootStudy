第三章 垃圾收集器与内存回收策略

java 与c++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的
想进去，墙里面的的人却想出来。

3.1 概述
    说起垃圾收集 Garbage collection GC，大部分人都把这项技术当作java语言的伴产物
。事实上，GC的历史比java久远，1960年诞生于MIT的LISP是第一面真正使用内存
动态分配和垃圾收集技术的语言。当lisp还在胚胎时期时，人民就在思考GC需要完成的三件事情：
I.那些内存需要回收
I.什么时候回收
I.如何回收
    经过半个多世纪的发展，目前内存的动态分配与内存回收技术已经相当成熟，一切看起
来都进入了自动化时代,那为什么我们还要去了解GC和内存分配呢？答案很简单：当
需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，
我们就需要对这些自动化的技术实施必要的监控和调节。
   把时间从半个多实际以前拨回到现在，回到我们熟悉的java语言。第二章介绍了java
内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈三个区域随线程而生
，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。
每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的 尽管在运行期会由jit
编译器进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译器可知的，
因此这几个区域的内存分配和回收都具备确定下，在这几个区域内就不需要过多考虑回收的
问题，因为方法结束或者线程结束时，内存自然就跟随者回收了。而java堆和方法区则不一
样，一个接口中的多个实现类需要的内存可能不一样，一个方法中多个分支需要的内存也
可能不一样，我们只有在程序处于运行期间时才能知道会创建那些对象，这部分内存的分配
和回收都是动态的，垃圾收集器所关注的是这部分内存，本章后续讨论中的内存分配与
回收也仅制这一部分内存。

程序计数器、虚拟机栈、本地方法栈 随线程而灭
java堆和方法区


3.2 对象已死吗  P62
   在堆里面存放着java时间中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件
事情就是要确定这些对象之中那些还存活着，那些已经死去即不可能再被任何
途径使用的对象。

3.2.1 引用计数算法
   很多教科书判断对象是否存活的算法是这样的：
















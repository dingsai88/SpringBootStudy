第三章 垃圾收集器与内存回收策略

java 与c++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的
想进去，墙里面的的人却想出来。

3.1 概述
    说起垃圾收集 Garbage collection GC，大部分人都把这项技术当作java语言的伴产物
。事实上，GC的历史比java久远，1960年诞生于MIT的LISP是第一面真正使用内存
动态分配和垃圾收集技术的语言。当lisp还在胚胎时期时，人民就在思考GC需要完成的三件事情：
I.那些内存需要回收
I.什么时候回收
I.如何回收
    经过半个多世纪的发展，目前内存的动态分配与内存回收技术已经相当成熟，一切看起
来都进入了自动化时代,那为什么我们还要去了解GC和内存分配呢？答案很简单：当
需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，
我们就需要对这些自动化的技术实施必要的监控和调节。
   把时间从半个多实际以前拨回到现在，回到我们熟悉的java语言。第二章介绍了java
内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈三个区域随线程而生
，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。
每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的 尽管在运行期会由jit
编译器进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译器可知的，
因此这几个区域的内存分配和回收都具备确定下，在这几个区域内就不需要过多考虑回收的
问题，因为方法结束或者线程结束时，内存自然就跟随者回收了。而java堆和方法区则不一
样，一个接口中的多个实现类需要的内存可能不一样，一个方法中多个分支需要的内存也
可能不一样，我们只有在程序处于运行期间时才能知道会创建那些对象，这部分内存的分配
和回收都是动态的，垃圾收集器所关注的是这部分内存，本章后续讨论中的内存分配与
回收也仅制这一部分内存。

程序计数器、虚拟机栈、本地方法栈 随线程而灭
java堆和方法区


3.2 对象已死吗  P62
   在堆里面存放着java时间中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件
事情就是要确定这些对象之中那些还存活着，那些已经死去即不可能再被任何
途径使用的对象。

3.2.1 引用计数算法
   很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有
一个地方引用它时，计数器值就加1：当引用失效时，计数器就减一；任何时刻计数器为0
的对象就是不可能再被使用的。作者面试过很多应届生和一些有多年工作经验的开发人员
，他们对于这个问题给予的都是这个答案。
   客观地说，引用计数器 Reference counting 的实现简单，判定效率也很高，在大
部分情况下他都是一个不错的算法，也有一些比较著名的应用案例，例如微软公司的COM
component object model 技术、使用actionscript3的flashPlayer、python语言和在游戏
脚本领域被广泛应用的squirrel中都使用了引用计数算法进行内存管理。但是至少主流的
java虚拟机里面没有选用引用计数算法来管理内存reference counting,其中最主要的原因是它很难解决对象之
间互相循环引用的问题。
  举个简单的例子，请看代码清单方法：对象objA和objB都有字段
instance，赋值令ojbA.instance=objB以及instance=objA，除此之外，这两个对象再无任
何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用者对方，导致他们
的引用计数reference Counting都不为0，于是引用计数算法无法通知GC收集器回收他们。
    从运行结果中可以清楚看到，GC日志中包含，意味着虚拟机并没有因为
这两个对象互相引用就不回收他们，这也从侧面说明虚拟机并不是通过引用计数算法来判断
对象是否存活的。
   3.2.2 可达性分析算法
   在主流的商用程序语言(java、c#，甚至包括前面提到的古老的lisp)的主流实现中，
都是称通过可达性分析 reachability analysis  reach到达 ability能力 analyisi分析 来判断对象是否存活的。这个算法的基本思
路就是通过一系列的成为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索
所走过的路径称为引用链 Reference chain,当一个对象到GC root没有任何引用链相连
用图论的话来说，就是从GC roots到这个对象不可达时，则证明此对象是不可用的。如
对象objc5\6\7虽然互相有关联，但是他们到GCroots是不可达的，所以它们将会被判定为是
可回收的对象。Garbage collection

 在java语言中，可作为 garbage collection roots的对象包括下面几种
 虚拟机栈（栈帧中的本地变量表）中引用的对象。
 方法区中类静态属性引用的对象。
 方法区中常量引用的对象。
 本地方法栈中jni （一般说的native方法）引用的对象
 
 3.2.3 再谈引用
  无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引
用链是否可达reference chain，判定对象是否存活都与引用有关。在jdk2以前，java中的引用的定
义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称
这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被
引用或者没有被引用两种状态，对于如何描述一些食之无味弃之可惜的对象就显得无能
为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果
内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合
这样的应用场景。
       在jdk1.2之后，java对引用的概念进行了扩充，将引用分为强引用 Strong reference
软引用 soft reference 弱引用 weak reference 虚引用 phantom reference 四种,这
四种引用强度依次逐渐减弱。
strong soft weak phantom 强软弱虚
1.强引用就是指在程序代码之中普遍存在的，类似object obj=new object 这类的
引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

2.软引用使用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统
将要发生内存溢出的异常之前，将会把这些对象裂锦回收范围之中进行第二层回收。如
果这次回收还没有足够的内存，才会抛出内存溢出异常。在jdk2之后，提供了
softereference 类来实现软引用。

3.弱引用weakreference也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用
关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当
前内存是否足够，都会回收掉只被弱引用关联的对象。jdk2之后，提供了weakreference类来实现弱yinyong。

4.虚引用也称为幽灵引用或者幻影引用，他是最弱的一种引用关系。一个对象是否有虚引用
的存在，完全不会对齐生存时间构成影响，也无法通过虚引用来取得一个对象实例
。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时手袋一个
系统通知。2之后，提供了phantom Reference类来实现虚引用。

3.2.4 生产还是死亡
    即使在可达性分析算法中不可达的对象，也并非是非死不可的，这时候他们暂时处、
于缓刑阶段，要真正宣告一个对象死亡，至少要经历两次标记过程： 如果对象在进行可
达性分析后发现没有与garbage collection roots相连接的引用链 chain ,那它将会被第一次标记并且进行一次筛
选，筛选的条件是此对象是否有必要执行finalize 方法。当对象没有覆盖finalize方法，或
者finalize方法已经被虚拟机调用过，虚拟机将这两种情况视为没有必要执行。
    如果这个对象被判定为有必要执行finalize 方法，那么这个对象将会放置在一个叫做
F-queue的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的finalizeer线程去执
行它。这里所谓的执行是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这
样做的原因是，如果一个对象在finalize方法中执行缓存，或者发生了死循环更极端的情况
，将会很可能会导致F-queue队列中其他对象永久处于等待，甚至导致整个内存回收系统
崩溃。finalize方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-queue中的对象
进行第二次小规模的标记，如果对象要在finalize中成功拯救自己-只要重新与引用链上
的任何一个对象建立关联即可，譬如把自己this关键字赋值给某个类的变量或对象的成
员变量，那在第二次标记时他将被移除出即将回收的集合；如果对象这时候还没有逃脱，
那基本上它就真的被回收了。从代码清单3-2中我们可以看到一个对象的finalize被执行，
但是它仍然可以存活。

  从代码清单3-2的运行结果可以看出，savehook对象finalize方法确实被GC收集器
触发过，并且在被收集前成功逃脱了。
  另外一个值得注意的地方是，代码中有两段完全一样的代码片段，执行结果确实一次逃脱
成功，一次失败，这是因为任何一个对象的finalize方法都只会被系统自动调用一次，如果对
象面临下一次回收，它的finalize方法不会被再次执行，因此第二段代码的自救行动失败了。
   需要特别说明的是，上面关于对象死亡时finalize方法描述可能带有悲情的一书色菜
，笔者并不鼓励大家使用这种方法来拯救对象。相反，笔者建议大家尽量避免使用它，因为
它不是C++中的析构函数（对立构造函数）,而是java刚诞生时为了使C++程序员更容易接受它所作
出的一个妥协。它的运行代价高昂，不确定性打，无法保证各个对象的调用顺序。有些教材
中描述它适合做关闭外部资源之类的工作，这完全是对这个方法用途的一种子午安慰。
finalize能做的所有工作，使用try finally或者其他方式都可以做的更好、更及时，所以笔者
建议大家完全可以忘掉java语言中有这个方法的存在。

3.2.5 回收方法区
   很多人认为方法区或者hotspot虚拟机中永久代是没有垃圾收集的，java虚拟机
规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的
性价比一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以
回收70%-95%的空间，而永久代的垃圾收集效率远低于此。
   永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收
java堆中的对象非常类似。以常量池中字面量的回收为例，加入一个字符串abc已经进入
了常量池中，但是当前系统没有任何一个string对象视角abc的换句话说，就是没有
任何string对象引用常量池中的abc常量，也没有其他地方引用了这个字面量，如果这
时发生内存回收，并且必要的话，这个abc常量就会被系统清理出常量池。常量池中的其他
类接口方法字段的符号引用也于此类似。
   判定一个常量是否是废弃常量比较简单,而要判断一个类是否是无用的类的条件
则相对苛刻许多。类需要同时满足下面3个条件才能算是无用的类；
 1.该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。
 2.加载该类的Classloader已经被回收。
 3.该类对应的java.lang.class对象没有任何地方被引用，无法在任何地方通过反射访问
 该类的方法。
   虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是可以，而并不是
和对象一样，不适用了就必然回收。是否对类进行回收，hotspot虚拟机提供了-Xnoclassgc参数
进行控制，还可以使用-verbose:class和-XX:+TraceClassLoading可以在product版的虚拟机中使
用，-XX:+TraceClassUnLoading参数需要Fastdebug版的虚拟机支持。
   在大量使用反射、动态代理、CGLIB等bytecode框架、动态生产JSP以及OSGI这类
频繁自定义classloader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。
https://www.cnblogs.com/mengdd/p/3594608.html

3.3 垃圾收集算法
   由于垃圾收集算法的实现设计大量的程序细节，而且各个平台的虚拟机操作内存的方法又
各不相同，因此本节不打算过多地讨论算法的实现，只是介绍几种算法的思想以及其发展过程。

3.3.1 标记-清除算法
   最基础的收集算法是 标记-清除 mark sweep 算法，如同它的名字一样，算法分为
标记和清除两个阶段：首先标记处所有需要回收的对象，在标记完成后统一回收
所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以
说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而
得到的。它的主要不足有两个：一是效率问题，标记和清除两个过程的效率都不高；另一个
是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后
在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次
垃圾收集动作。mark sweep 算法的执行过程如图

3.3.2 复制算法
    为了解决效率问题，一种称为复制copying的收集算法出现了，它将可用内存按
容量划分为大小相等的两块，每次指使用其中一块。当这一块的内存用完了，就将还存活
着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都
是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶
指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了
原来的一半，未免太高了一点。复制算法的执行过程如图3-3所示。
     现在的商业虚拟机都采用这种收集算法回收新生代，IBM公司的专门研究表明，新
生代中的对象98是朝生夕死的，所以并不需要按照1：1的比例来划分内存空间，而
是将内存分为一块较大的eden(伊甸园新生代)空间和两块较小的survivor(幸存者)空间,每次使用eden和其中一块
survivor。当回收时，将Eden和survivor中还存活着的对象一次性地复制到另外一块
survivor空间上，最后清理掉eden和刚才用过的survivor空间。hotspot虚拟机默认eden
和survivor的大小比例是8：1，也就是每次新生代中可用内存空间为整个新生代容量的90%
（80%+10%）,只有10%的内存会被浪费。当然，98%的对象可回收只是一般场景下的数据

我们没有办法保证每次回收都是只有不多于10%的对象存活，当survivor空间不够用时，
需要依赖其他内存（这里指老年代）进行分配担保 handle处理 promotion提升
   内存的分配担保就好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时
偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能
保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。内存的分配担保
也一样，如果另外一块suvivor空间没有足够空间存放上一次新生代手机下来的存活对象时
，这些对象将直接通过分配担保机制进入老年代。关于新生代进行分配担保的内容，在
本章稍后在讲解垃圾收集器执行规则时还会再详细讲解。

3.3.3 标记-整理算法
   复制手机算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的
是，如果不想浪费50%的控件，就需要有额外的空间进行分配担保，以应对被使用的内存中
所有对象都100存活的极端情况，所以在老年代一般不能直接选用这种算法。
   根据老年代的特点，有人提出了另外一种标记-整理 mark compact(压缩、紧致)算法，标记
过程仍然与标记清除sweep算法一样，但后续步骤不是直接对可回收对象进行清理，而是让
所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，标记整理算法
示意图3-4

3.3.4 分代收集算法
    当前商业虚拟机的垃圾收集都是采用分代收集 generational collection 算法，这种
算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是吧java
堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代
中，每次垃圾收集时都发现有大量对象死去，只有少量存活，那就选用复制算法，只需要付出
少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间
对它进行分配担保，就必须使用标记清理或者标记整理算法来进行回收。



















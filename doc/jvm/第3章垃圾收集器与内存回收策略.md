第三章 垃圾收集器与内存回收策略

java 与c++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的
想进去，墙里面的的人却想出来。

3.1 概述
    说起垃圾收集 Garbage collection GC，大部分人都把这项技术当作java语言的伴产物
。事实上，GC的历史比java久远，1960年诞生于MIT的LISP是第一面真正使用内存
动态分配和垃圾收集技术的语言。当lisp还在胚胎时期时，人民就在思考GC需要完成的三件事情：
I.那些内存需要回收
I.什么时候回收
I.如何回收
    经过半个多世纪的发展，目前内存的动态分配与内存回收技术已经相当成熟，一切看起
来都进入了自动化时代,那为什么我们还要去了解GC和内存分配呢？答案很简单：当
需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，
我们就需要对这些自动化的技术实施必要的监控和调节。
   把时间从半个多实际以前拨回到现在，回到我们熟悉的java语言。第二章介绍了java
内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈三个区域随线程而生
，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。
每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的 尽管在运行期会由jit
编译器进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译器可知的，
因此这几个区域的内存分配和回收都具备确定下，在这几个区域内就不需要过多考虑回收的
问题，因为方法结束或者线程结束时，内存自然就跟随者回收了。而java堆和方法区则不一
样，一个接口中的多个实现类需要的内存可能不一样，一个方法中多个分支需要的内存也
可能不一样，我们只有在程序处于运行期间时才能知道会创建那些对象，这部分内存的分配
和回收都是动态的，垃圾收集器所关注的是这部分内存，本章后续讨论中的内存分配与
回收也仅制这一部分内存。

程序计数器、虚拟机栈、本地方法栈 随线程而灭
java堆和方法区


3.2 对象已死吗  P62
   在堆里面存放着java时间中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件
事情就是要确定这些对象之中那些还存活着，那些已经死去即不可能再被任何
途径使用的对象。

3.2.1 引用计数算法
   很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有
一个地方引用它时，计数器值就加1：当引用失效时，计数器就减一；任何时刻计数器为0
的对象就是不可能再被使用的。作者面试过很多应届生和一些有多年工作经验的开发人员
，他们对于这个问题给予的都是这个答案。
   客观地说，引用计数器 Reference counting 的实现简单，判定效率也很高，在大
部分情况下他都是一个不错的算法，也有一些比较著名的应用案例，例如微软公司的COM
component object model 技术、使用actionscript3的flashPlayer、python语言和在游戏
脚本领域被广泛应用的squirrel中都使用了引用计数算法进行内存管理。但是至少主流的
java虚拟机里面没有选用引用计数算法来管理内存reference counting,其中最主要的原因是它很难解决对象之
间互相循环引用的问题。
  举个简单的例子，请看代码清单方法：对象objA和objB都有字段
instance，赋值令ojbA.instance=objB以及instance=objA
















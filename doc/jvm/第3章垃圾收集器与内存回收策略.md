第三章 垃圾收集器与内存回收策略

java 与c++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的
想进去，墙里面的的人却想出来。

3.1 概述
    说起垃圾收集 Garbage collection GC，大部分人都把这项技术当作java语言的伴产物
。事实上，GC的历史比java久远，1960年诞生于MIT的LISP是第一面真正使用内存
动态分配和垃圾收集技术的语言。当lisp还在胚胎时期时，人民就在思考GC需要完成的三件事情：
I.那些内存需要回收
I.什么时候回收
I.如何回收
    经过半个多世纪的发展，目前内存的动态分配与内存回收技术已经相当成熟，一切看起
来都进入了自动化时代,那为什么我们还要去了解GC和内存分配呢？答案很简单：当
需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，
我们就需要对这些自动化的技术实施必要的监控和调节。
   把时间从半个多实际以前拨回到现在，回到我们熟悉的java语言。第二章介绍了java
内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈三个区域随线程而生
，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。
每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的 尽管在运行期会由jit
编译器进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译器可知的，
因此这几个区域的内存分配和回收都具备确定下，在这几个区域内就不需要过多考虑回收的
问题，因为方法结束或者线程结束时，内存自然就跟随者回收了。而java堆和方法区则不一
样，一个接口中的多个实现类需要的内存可能不一样，一个方法中多个分支需要的内存也
可能不一样，我们只有在程序处于运行期间时才能知道会创建那些对象，这部分内存的分配
和回收都是动态的，垃圾收集器所关注的是这部分内存，本章后续讨论中的内存分配与
回收也仅制这一部分内存。

程序计数器、虚拟机栈、本地方法栈 随线程而灭
java堆和方法区


3.2 对象已死吗  P62
   在堆里面存放着java时间中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件
事情就是要确定这些对象之中那些还存活着，那些已经死去即不可能再被任何
途径使用的对象。

3.2.1 引用计数算法
   很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有
一个地方引用它时，计数器值就加1：当引用失效时，计数器就减一；任何时刻计数器为0
的对象就是不可能再被使用的。作者面试过很多应届生和一些有多年工作经验的开发人员
，他们对于这个问题给予的都是这个答案。
   客观地说，引用计数器 Reference counting 的实现简单，判定效率也很高，在大
部分情况下他都是一个不错的算法，也有一些比较著名的应用案例，例如微软公司的COM
component object model 技术、使用actionscript3的flashPlayer、python语言和在游戏
脚本领域被广泛应用的squirrel中都使用了引用计数算法进行内存管理。但是至少主流的
java虚拟机里面没有选用引用计数算法来管理内存reference counting,其中最主要的原因是它很难解决对象之
间互相循环引用的问题。
  举个简单的例子，请看代码清单方法：对象objA和objB都有字段
instance，赋值令ojbA.instance=objB以及instance=objA，除此之外，这两个对象再无任
何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用者对方，导致他们
的引用计数reference Counting都不为0，于是引用计数算法无法通知GC收集器回收他们。
    从运行结果中可以清楚看到，GC日志中包含，意味着虚拟机并没有因为
这两个对象互相引用就不回收他们，这也从侧面说明虚拟机并不是通过引用计数算法来判断
对象是否存活的。
   3.2.2 可达性分析算法
   在主流的商用程序语言(java、c#，甚至包括前面提到的古老的lisp)的主流实现中，
都是称通过可达性分析 reachability analysis  reach到达 ability能力 analyisi分析 来判断对象是否存活的。这个算法的基本思
路就是通过一系列的成为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索
所走过的路径称为引用链 Reference chain,当一个对象到GC root没有任何引用链相连
用图论的话来说，就是从GC roots到这个对象不可达时，则证明此对象是不可用的。如
对象objc5\6\7虽然互相有关联，但是他们到GCroots是不可达的，所以它们将会被判定为是
可回收的对象。Garbage collection

 在java语言中，可作为 garbage collection roots的对象包括下面几种
 虚拟机栈（栈帧中的本地变量表）中引用的对象。
 方法区中类静态属性引用的对象。
 方法区中常量引用的对象。
 本地方法栈中jni （一般说的native方法）引用的对象
 
 3.2.3 再谈引用
  无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引
用链是否可达reference chain，判定对象是否存活都与引用有关。在jdk2以前，java中的引用的定
义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称
这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被
引用或者没有被引用两种状态，对于如何描述一些食之无味弃之可惜的对象就显得无能
为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果
内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合
这样的应用场景。
       在jdk1.2之后，java对引用的概念进行了扩充，将引用分为强引用 Strong reference
软引用 soft reference 弱引用 weak reference 虚引用 phantom reference 四种,这
四种引用强度依次逐渐减弱。
strong soft weak phantom 强软弱虚
1.强引用就是指在程序代码之中普遍存在的，类似object obj=new object 这类的
引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

2.软引用使用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统
将要发生内存溢出的异常之前，将会把这些对象裂锦回收范围之中进行第二层回收。如
果这次回收还没有足够的内存，才会抛出内存溢出异常。在jdk2之后，提供了
softereference 类来实现软引用。

3.弱引用weakreference也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用
关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当
前内存是否足够，都会回收掉只被弱引用关联的对象。jdk2之后，提供了weakreference类来实现弱yinyong。

4.虚引用也称为幽灵引用或者幻影引用，他是最弱的一种引用关系。一个对象是否有虚引用
的存在，完全不会对齐生存时间构成影响，也无法通过虚引用来取得一个对象实例
。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时手袋一个
系统通知。2之后，提供了phantom Reference类来实现虚引用。

3.2.4 生产还是死亡
    即使在可达性分析算法中不可达的对象，也并非是非死不可的，这时候他们暂时处、
于缓刑阶段，要真正宣告一个对象死亡，至少要经历两次标记过程： 如果对象在进行可
达性分析后发现没有与garbage collection roots相连接的引用链 chain ,那它将会被第一次标记并且进行一次筛
选，筛选的条件是此对象是否有必要执行finalize 方法。当对象没有覆盖finalize方法，或
者finalize方法已经被虚拟机调用过，虚拟机将这两种情况视为没有必要执行。
    如果这个对象被判定为有必要执行finalize 方法，那么这个对象将会放置在一个叫做
F-queue的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的finalizeer线程去执
行它。这里所谓的执行是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这
样做的原因是，如果一个对象在finalize方法中执行缓存，或者发生了死循环更极端的情况
，将会很可能会导致F-queue队列中其他对象永久处于等待，甚至导致整个内存回收系统
崩溃。finalize方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-queue中的对象
进行第二次小规模的标记，如果对象要在finalize中成功拯救自己-只要重新与引用链上
的任何一个对象建立关联即可，譬如把自己this关键字赋值给某个类的变量或对象的成
员变量，那在第二次标记时他将被移除出即将回收的集合；如果对象这时候还没有逃脱，
那基本上它就真的被回收了。从代码清单3-2中我们可以看到一个对象的finalize被执行，
但是它仍然可以存活。

  从代码清单3-2的运行结果可以看出，savehook对象finalize方法确实被GC收集器
触发过，并且在被收集前成功逃脱了。
  另外一个值得注意的地方是，代码中有两段完全一样的代码片段，执行结果确实一次逃脱
成功，一次失败，这是因为任何一个对象的finalize方法都只会被系统自动调用一次，如果对
象面临下一次回收，它的finalize方法不会被再次执行，因此第二段代码的自救行动失败了。
   需要特别说明的是，上面关于对象死亡时finalize方法描述可能带有悲情的一书色菜
，笔者并不鼓励大家使用这种方法来拯救对象。相反，笔者建议大家尽量避免使用它，因为
它不是C++中的析构函数（对立构造函数）,而是java刚诞生时为了使C++程序员更容易接受它所作
出的一个妥协。它的运行代价高昂，不确定性打，无法保证各个对象的调用顺序。有些教材
中描述它适合做关闭外部资源之类的工作，这完全是对这个方法用途的一种子午安慰。
finalize能做的所有工作，使用try finally或者其他方式都可以做的更好、更及时，所以笔者
建议大家完全可以忘掉java语言中有这个方法的存在。

3.2.5 回收方法区
   很多人认为方法区或者hotspot虚拟机中永久代是没有垃圾收集的，java虚拟机
规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的
性价比一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以
回收70%-95%的空间，而永久代的垃圾收集效率远低于此。
   永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收
java堆中的对象非常类似。以常量池中字面量的回收为例，加入一个字符串abc已经进入
了常量池中，但是当前系统没有任何一个string对象视角abc的换句话说，就是没有
任何string对象引用常量池中的abc常量，也没有其他地方引用了这个字面量，如果这
时发生内存回收，并且必要的话，这个abc常量就会被系统清理出常量池。常量池中的其他
类接口方法字段的符号引用也于此类似。
   判定一个常量是否是废弃常量比较简单,而要判断一个类是否是无用的类的条件
则相对苛刻许多。类需要同时满足下面3个条件才能算是无用的类；
 1.该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。
 2.加载该类的Classloader已经被回收。
 3.该类对应的java.lang.class对象没有任何地方被引用，无法在任何地方通过反射访问
 该类的方法。
   虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是可以，而并不是
和对象一样，不适用了就必然回收。是否对类进行回收，hotspot虚拟机提供了-Xnoclassgc参数
进行控制，还可以使用-verbose:class和-XX:+TraceClassLoading可以在product版的虚拟机中使
用，-XX:+TraceClassUnLoading参数需要Fastdebug版的虚拟机支持。
   在大量使用反射、动态代理、CGLIB等bytecode框架、动态生产JSP以及OSGI这类
频繁自定义classloader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。
https://www.cnblogs.com/mengdd/p/3594608.html

3.3 垃圾收集算法
   由于垃圾收集算法的实现设计大量的程序细节，而且各个平台的虚拟机操作内存的方法又
各不相同，因此本节不打算过多地讨论算法的实现，只是介绍几种算法的思想以及其发展过程。

3.3.1 标记-清除算法
   最基础的收集算法是 标记-清除 mark sweep 算法，如同它的名字一样，算法分为
标记和清除两个阶段：首先标记处所有需要回收的对象，在标记完成后统一回收
所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以
说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而
得到的。它的主要不足有两个：一是效率问题，标记和清除两个过程的效率都不高；另一个
是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后
在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次
垃圾收集动作。mark sweep 算法的执行过程如图

3.3.2 复制算法
    为了解决效率问题，一种称为复制copying的收集算法出现了，它将可用内存按
容量划分为大小相等的两块，每次指使用其中一块。当这一块的内存用完了，就将还存活
着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都
是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶
指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了
原来的一半，未免太高了一点。复制算法的执行过程如图3-3所示。
     现在的商业虚拟机都采用这种收集算法回收新生代，IBM公司的专门研究表明，新
生代中的对象98是朝生夕死的，所以并不需要按照1：1的比例来划分内存空间，而
是将内存分为一块较大的eden(伊甸园新生代)空间和两块较小的survivor(幸存者)空间,每次使用eden和其中一块
survivor。当回收时，将Eden和survivor中还存活着的对象一次性地复制到另外一块
survivor空间上，最后清理掉eden和刚才用过的survivor空间。hotspot虚拟机默认eden
和survivor的大小比例是8：1，也就是每次新生代中可用内存空间为整个新生代容量的90%
（80%+10%）,只有10%的内存会被浪费。当然，98%的对象可回收只是一般场景下的数据

我们没有办法保证每次回收都是只有不多于10%的对象存活，当survivor空间不够用时，
需要依赖其他内存（这里指老年代）进行分配担保 handle处理 promotion提升
   内存的分配担保就好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时
偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能
保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。内存的分配担保
也一样，如果另外一块suvivor空间没有足够空间存放上一次新生代手机下来的存活对象时
，这些对象将直接通过分配担保机制进入老年代。关于新生代进行分配担保的内容，在
本章稍后在讲解垃圾收集器执行规则时还会再详细讲解。

3.3.3 标记-整理算法
   复制手机算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的
是，如果不想浪费50%的控件，就需要有额外的空间进行分配担保，以应对被使用的内存中
所有对象都100存活的极端情况，所以在老年代一般不能直接选用这种算法。
   根据老年代的特点，有人提出了另外一种标记-整理 mark compact(压缩、紧致)算法，标记
过程仍然与标记清除sweep算法一样，但后续步骤不是直接对可回收对象进行清理，而是让
所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，标记整理算法
示意图3-4

3.3.4 分代收集算法
    当前商业虚拟机的垃圾收集都是采用分代收集 generational collection 算法，这种
算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是吧java
堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代
中，每次垃圾收集时都发现有大量对象死去，只有少量存活，那就选用复制算法，只需要付出
少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间
对它进行分配担保，就必须使用标记清理或者标记整理算法来进行回收。

3.4 HotSpot的算法实现
   3.2节和3.3节从理论上介绍了对象存活判定算法和垃圾收集算法，而在hotspot虚拟机
上实现这些算法时，必须对算法的执行效率有严格的考量，才能保证虚拟机高效运行。

3.4.1 枚举根节点
    从可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要
在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，
现在很多应用仅仅方法区就有数百兆，如果要逐个检测这里面的引用，那么必然会消耗很多
时间。
   另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一
个能确保一致性的快照中进行--这里一致性的意思是指在整个分析期间整个执行系统
看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情
况，改点不满足的话分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有
java执行线程（sun将这件事情成为 stop the world）的其中一个重要原因，即使是在号
称几乎不会发生停顿的CMS concurrent mark sweep收集器中，枚举根节点时也是必须要停顿的。
    由于目前的主流java虚拟机使用的都是准确式GC 这个概念在第一章介绍exactVm
对classic vm的改进时讲过，所以当执行系统挺短下来后，并不需要一个不漏地检测完所
有执行上下文和全局的引用位置，虚拟机应当是有办法直接的值那些地方存放着对象引用。
在hotspot的实现中，是使用一组成为oopmap的数据结构来达到这个目的的，在类加载完
成的时候，hotspot就吧对象内什么偏移量上是什么类型的数据计算出来，在JIT 编译过程 just in time
中，也会在特定的位置记录下栈和寄存器中那些文职是引用。这样，GC在扫描时就可以直
接的值这些信息了。下面的代码清单3-3是hotspotclientvm生成的一段 string hashcode
方法的本地代码，可以看到call指令有oopmap记录，它志明了EBX寄
存器和栈中偏移量为16的内存区域中各有一个普通对象指针ordinary object pointer的引
用，有效范围从call指令开始知道 指令流的起始位置 oopmap记录
的偏移量  即hlt指令为止。

3.4.2 安全点
   在oopmap的协助下，hotspot可以快速且准确地完成GC roots枚举，但一个很显示的问
题随之而来；可能导致引用关系变化，或者活oopmap内容变量的指令非常多，如果未每一条
指令都生成对应的oopmap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。
   实际上，hotspot也的却没有未每条指令都生成oopmap，前面已经提到，只是在特定
定的位置记录了这些信息，这些位置成为安全点。safepoint,即程序执行时并非在所有
地方都能停顿下来开始GC，只有在达到安全点时才能展厅。safepoint的选定既不能太少以至于
让GC等待时间太长，也不能过于频繁以至于过分增大运行时的负荷。所以安全点的
选定基本上是以程序是否具有让程序长时间执行的特征为标准进行选定的，因为每条
指令执行的时间都非常短暂，程序不太可能因为执行指令流长度太长这个原因而过程时间运行，
长时间执行的最明显特征就是指令序列复用，例如方法调用、循环跳转，异常跳转等
所以具有这些功能的指令才会产生safepoint
  对于safepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行
行JNI调用的线程  ）都跑到最近的安全点上再停顿下来。这里有两种方案可供选择：抢
先式中断 preemptive suspension 和主动式中断 voluntary suspension 其中抢先式中断
不需要线程的执行代码主动去配合，在GC发生时，首先吧所有线程全部中断，如果发现有
线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上。现在几乎没有虚拟机
实现采用抢先式中断来暂停线程从而响应GC事件。
   而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置
一个标志，各个线程执行时主动去轮训这个标志，发现中断标志位真时就自己中断挂起。
轮训标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。下面代码清单
3-4中的test指令是hotspot生成的轮训指令，当需要暂停线程时，虚拟机吧的
内存页设置为不可读，线程执行到test指令时就会产生一个自陷异常信号，在预先注册的异常
处理器中暂停线程实现等待，这样一条汇编指令便完成安全点轮训和触发线程中断。

3.4.3 安全区域
   使用safepoint似乎已经万美地解决了如何进入GC的问题，但实际情况却并不一定。
safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的safepoint。但
是，程序不执行的时候？所以的程序不执行就是没有分配CPU时间，典型的例子就是
线程处于sleep状态或blocked状态，这时候线程无法影响JVM的中断情况，走到
安全的地方去中断挂起，jvm也线程不太可能等待线程重新被分配CPU时间，这对于这种情况
就需要安全区域safe region 来解决。
    安全区域是指在一段点之中，引用关系不会发生变化。在这个区域中的任意地方
开始GC都是安全的，我们也可以吧safe region看做是被拓展了的safepoint。
   在线程执行到safe region中的代码时，寿险标识自己已经进入了saferegion，那样，当在
这段时间里jvm要发起GC时，就不用管标识自己为safe fegion状态的线程了。在线程要离开saferegion时候
他要检测系统是否已经完成了根节点枚举，或者整个GC过程，如果完成了
那线程就继续执行，否则他就不许等待直到收到可以安全离开saferegion的信号为止。
  到此，笔者简要地介绍了hotspot虚拟机如何去发起内存回收的问题，但是虚拟机如何具
体地进行内存回收动作仍然未涉及，因为内存回收如何进行是虚拟机所采用的GC收集器决定的
，而通常虚拟机中往往不止有一种GC收集器。下面继续看hotspot中有哪些GC收集器。

3.5 垃圾收集器
    如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。java
虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同的版本的虚
拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应
用特点和要求组合出各个年代所使用的收集器。这里讨论的收集器基于jdk7之后的
hotspot虚拟机，在这个版本中正式提供了商用的G1收集器，之前G1处于试验状态，
这个虚拟机包含的所有收集器如图3-5所示。
young generation 年轻代
serial 连续的 
parnew 年轻代收集器 复制算法
parallel
tenured generation 老年代
图3-5 展示了7种作用域不同分带的收集器，如果两个收集器之间存在连线，就说明它们
可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器.接
下来笔者将逐一介绍这些收集器的特性、基本原理和使用场景，并重点分析CMS和G1这两款
相对复杂的收集器，了解他们的部分运作细节
  在介绍这些收集器各自的特性之前，我们先来明确一个观点：虽然我们是在对各个收集器
进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有最好的收集器
出现，更加没有万能的收集器，所以我们选择的只是对具体应用最适合的收集器。这点不需要
多加解释就能证明：如果有一种放之四海皆准、任何场景下都使用的万美收集器存在，那
hotspot虚拟机就没有必要实现那么多不同的收集器了。
3.5.1 serial 连续的收集器
   serial收集器是最基本、发展历史最悠久的收集器，曾经是虚拟机
新生代收集的唯一选择。大家看名字就会知道，这个收集器是一个单线程的收集器，但它的
单线程的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作。
更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。stop
theworld 这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的
在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难
以接受的。读者不妨试想一下，要是你的计算机每运行一个小时就会暂停5分钟，你会
有什么样的心情？图 serial/serialold收集器的运行过程

  对于stop the world 带来用户的不良体验，虚拟机的设计者们标识完全理解，但也表示
非常委屈：你妈妈在给你打扫房间的时候，肯定也会让你老实的在椅子上待着
如果她一遍打扫，一遍乱扔。这确实是一个合情合
理的矛盾，虽然垃圾收集这项工作听起来和打扫房间属于一个性质的，但实际上肯定还要比
打扫房间复杂得多啊
   从jdk3开始，一直到现在最新的jdk7，hotspot虚拟机开发团队为消除或减
少工作线程因存储回收而导致停顿的努力一直在进行着，从serial收集器到 parallel 相似 收集器
再到concurrent mark sweep cms 当前标记清除收集器那只GC收集器的最前沿成功 garbage  first G1收集
first
器，
serial 连续、parnew\ parallel 相似、 concurrent mark sweep CMS、 garbage first G1
我们看到一个个越来越优秀的收集器的出现，用户线程的停顿时间在不断
缩短，但是让人没有办法完全消除 这里暂不包括rtsj 中的收集器。寻找更优秀的
垃圾收集器的工作仍在继续。

 写到这里，笔者似乎已经吧serial 收集器描述成一个老面无用食之无味弃之可惜
的鸡肋了，但实际上到现在为止，它依然是虚拟机运行在client模式下的默认新生代收集器
。它也有着优于其他收集器的地方：简单而高效 与其他收集器的单线程比  对于限定
单个CPU的环境来说，erial收集器优于没有线程交互的开销，专心做垃圾收集自然可以
获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说
不会很大，收集十几兆甚至一两百兆的新生代 仅仅是新生代使用的内存，桌面应用基本上
不会再大了，停顿时间完全可以控制唉几十毫秒最多一秒多毫秒内，只要不是频繁发生，
这点停顿是可以接受的。所以，serial 连续收集器对于运行在client模式下的虚拟机来说是一个
很好的选择。

3.5.2 parnew（par面值） 新式收集器
    parnew 收集器其实就是serial 收集器的多线程版本，除了使用多线程进行垃圾收集
之外，其余行为包括serial收集器可用的所有控制参数例如 -XX:SurivorRatio、
-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等、收集算法、stop the world
对象分配规则、回收策略等都与serial收集器完全一样，在实现上，这两种收集器也共用了
相当多的代码。narnew收集器的工作过程如图
    parnew 收集器除了多线程手机之外，其他与serial收集器相比没有太多创新之处，
但它却是许多运行在server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关
但很重要的原因是，除了serial收集器外，目前只有他能与CMS 收集器配合工作。在JDK
1.5时期，hotspot退出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器
CMS收集器concurrent mark sweep 。这款收集器是
hotsport虚拟机中第一款真正意义上的并发concurrent 收集器，它第一次实现了让垃圾收集
线程与用户线程基本上同时工作，用前面那个例子的话来说，就是做大了在你的妈妈
打扫房间的是你还能一边王迪桑扔纸屑。
    不幸的是，CMS作为老年代的收集器，却无法与4中已存在的新生代收集器
parallel平行 scavenge  拾荒配合工作。所以在5中使用CMS来收集老年代的时候，新生代只能选择
parnew 或者 serial收集器中的一个。parnew 收集器也是使用-XX:+UseConcMarkSweepGC
选项后的默认新生代收集器，也可以使用-XX:UseParNewGC选项来强制指定它。
   parnew收集器在单cpu的环境中绝对不会有比serial收集器更好的效果，甚至由于
存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分
之百地保证可以超越serial收集器。当然，随着可以使用的CPU的数量的增加，它对于
GC时系统资源的有效利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同
，在CPU非常多譬如32个，现在CPU冻着就是4核加超线程，服务器超过32个逻辑
CPU的情况越来越多了的环境下，可以使用-XX:ParallelGCThreads参数来现在垃圾收集
的线程数。

注意  从parnew 收集器开始，后面还会接触到几款并发和并行的收集器。在大家可能产生
疑惑之前，有必要先解释两个名词：并发和并行。这两个名词都是并发变长中的概念，在谈
轮垃圾收集器的上下文语境中，它们可以解释如下。
并行 parallel 指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
并发 concurrent:指用户线程与垃圾收集线程同时执行 但不一定是并行的，可能会交替执行
用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。
http://blogs.sun.com/jonthecollector/entry/ourcollections

3.5.3 parallel scavenge 平行打扫 收集器
   parallel scavenge 收集器是一个新生代收集器，它也是使用赋值算法的收集器，又是并行
的多线程收集器  看上去的parnew都一样，那它有什么特别之处呢？
  parallel scavenge 收集器的特点是它的关注点与其他收集器不同，CMS等收集器的
关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而parallel scavenge收集器的目
标则是达到一个可控制的吞吐量  throughput 。所谓吞吐量就是CPU用于运行用户代码
的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/ 运行用户代码时间+垃圾收集时间
；虚拟机总共运行了100分钟，其中垃圾收集花费掉了1分钟，那吞吐量就是99%
  停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高
吞吐则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而
不需要太多交互的任务。
   parallel scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集
停顿时间的-XX:maxgcpausemillis 参数以及直接设置吞吐量大小的-xx:gctimeRatio参数。
   maxgcpausemillis参数允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回
收划分的时间不超过设定值。不过大家不要认为如果吧这个参数的值设置得稍小一地啊你就能使
得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的；
系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾
收集发生得更频繁一些，原来10秒收集一次、每次替你高顿100毫秒，现在变成5秒收集一次、
每次停顿70毫秒。停顿时间的却在下降，但吞吐量也降下来了。
  GCTimeratio参数的值应当是一个大于0且小于100的整数，也就是垃圾收集时间占总
时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19，那允许的最大GC时间就占
总时间5% ，默认值为99，就是允许最大1%的垃圾收集时间
  由于吞吐量关系密切，parallel scavenge 收集器也经常成为吞吐量优先收集器。
除了上述两个参数之外，parallel savenge收集器还有一个参数-xx:useAdaptiveSizePolicy
值得关注。这是一个开关参数，当一个参数打开之后，就不需要手工指定新生代的大小
-Xmn eden与survivor区的比例-xx:survivorratio 晋升来年代对象年龄
-xx:pretenure size threshold 等细节参数了，虚拟机会根据当前系统的运行情况手机性能监控
信息,动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式成为
GC自适应的调节策略 GC ergonomics 如果读者对于收集器运作原来不太了解，手工
优化存在困难的时候，使用 parallel scavenge 收集器配合自适应调节策略，吧内存管理的调优
任务交给虚拟机去完成讲师一个不错的选择。只需要吧基本的内存数据设置好如-xmx
设置最大堆，然后使用maxgcpausemillis参数 最大停顿时间 或者GCTIMEration 吞吐量
参数给虚拟机设立一个优化目标，那具体细节参数的调整功能就由虚拟机
完成了。自适应调节策略也是parallel scavenge 收集器与parnew 收集器的一个重要区别。
  
3.5.4 Serial Old 收集器 连续
   serial old 是serial收集器的老年代版本，它同样是一个单线程收集器，使用 标记
整理算法。这个收集器的主要意义也是在于给client模式下的虚拟机使用。如果在server
模式下，那么它主要还有两大用途:一种用途是在jdk1.5以及之前的版本中雨parallel
scavenge 收集器搭配使用，另一种用途就是作为CMS收集器的后预案，在并发手机发生
concurrent mode failure时使用。这两点都将在后面的内容中详细讲解。serial old收集器的
工作过程如图3-8所示。
download.oracle.com/javase/1.5.0/docs/guide/vm/gc-ergonomics.html
3.5.5 parallel old 收集器 平行
   parallel old 是parallel scavenge 收集器的老年代版本，使用多线程和标记整理算
法。这个收集器是在JDK6中才开始提供的，再次之前，新生代的 parallel scavenge 收集
器一直处于比较刚的状态。原因是，如果新生代选择了 parallel scavenge收集器，老年代
除了serial old ps marksweep 收集器外别无选择（还记得上面说过parallel scavenge 收集
器无法与CMS收集器配合工作吗）。由于老年代serial old 收集器在服务端应用性能上的
拖累，使用了parallel scavenge 收集器也未必能再整体应用上获得吞吐量最大的效果。
由于单线程的老年代手机中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件
比较高级的环境中，这种组合吞吐量甚至还不一定有parnew+cms的组合给力 concurrent mark sweep
  直到 parallel old 收集出现后，吞吐量优先收集器终于有了比较名副其实的应用组
合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑parallel savenge 家parallel old
收集器。parallel old 收集器的工作过程突入
  3.5.6 CMS 收集器
     cms concurrent mark sweep 收集器是一种以获取最短回收停顿时间未目标的收集器。
目前很大一部分的java应用集中在互联网站或者B S系统的服务端上，这类应用尤其重视服
务的响应速度，希望系统停顿时间最短，以给用户带来比较好的体验。CMS收集器就非常服符合
这类应用的需求。
  从名字包含mark sweep 上就可以看出，CMS收集器是基于标记清楚算法
实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤。
包括:
     初始标记 cms initial mark
     并发标记 cms concurrent mark
     重新标记 cms remark
     并发清除 cms concurrent sweep
     其中，初始标记、重新标记这两个步骤仍然需要 stop the world 初始标记
   是标记一下GC roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC roots
tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标
记产生变动的那一部分对象的标记积累，这个阶段的停顿时间一般会比出事标记阶段少上一些，
但远比并发标记的时间段。
    由于整个过程中耗时最长的并发标记和并发清楚收集器线程都可以与用户线程一起
工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。通过
图3-10可以比较清楚第看到CMS收集器的运作步骤中并发和需要停顿的时间。
   concurrent mark sweep 
初始标记(中断) 并发标记(并行)  重新标记(中断)  并发清理 (并行)  重置线程(并行)
  
  CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低
停顿，sun公司的一些官方文档中也称之为并发地停顿收集器 concurrent low pause 
collector .但是CMS还远达不到万美的程度，它有以下三个明显的缺点：
   cms收集器对CPU资源非常敏感。其实，面向并发设计的程序都对CPU资源比较
   敏感。在并发阶段，他虽然不会导致用户线程停顿，但是会因为占用了一部分线程
   或者说CPU资源 而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收
   线程数CPU数量+3除以4，也就是当CPU在4ge以上时，并发回收时垃圾汇集线
   程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4
   个譬如两个时，CMS对用户程序的影响就可能变得很大，如果本来CPU负载就
   比较大，还分出一般的运算能力去执行收集器线程，就可能导致用户程序的执行速度
   忽然降低了50%，其实也让人无法接受。为了应付这种情况，虚拟机提供了一种称为
   增量式并发收集器incremental consurrent mark sweep-cms的CMS收集器变
   种，锁座的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思想
   一样，就是在并发标记、清理的时候让GC线程、用户线程交替运行，尽量减少GC
   线程的独占资源时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会
   闲的少一些，也就是速度下降没有那么明显。实践证明，增量时的cms收集器效果
   很一般，在目前版本中，cms已经被声明为 deprecated ,即不再提倡用户使用。
    
     CMS收集器无法处理浮动垃圾 floating garbage ，可能出现 concurrent mode
     failure 失败而导致另一次 full GC的产生。由于cms并发清理阶段用户线程还在
     运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现杂标记过
     程之后，CMS无法在当此手机中处理掉它们，只要留待下一次GC时再清理掉。这一
     部分垃圾就称为浮动垃圾。也是由于在垃圾手机阶段用户线程还需要运行，那
     也就还需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器
     那样等到老年代几乎完全被填满了再进行收集，需要预留一部分孔家你提供并发收集
     时的程序运作使用。1.5默认设置下，CMS收集器当老年代使用68 %
     的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，
     可以适当跳高参数 -xx:xmsInitiatingOccupancyFraction的值来提高触发百分比，以
     便降低内存回收次数从而获取更好的性能，6中，CMS收集器的启动阈值
     已经提升至92%。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次
     concurrent mode failure失败，这时虚拟机将启动后备远：临时起送serial odl
     收集器来重新进行老年代的垃圾收集，这样停顿时间就更长了。所以说参数-xx:cm
     SinitiatingOccupancyFraction设置得太高容易导致大量 concurrent mode failure
     失败，性能反而降低。
     
      还有最后一个缺点，在本章开头说过，CMS是一款基于标记清除算法实现的
      收集器，如果读者对前面这种算法介绍还有印象的话，就可能想到这意味着手机结束
      时会有大量空间碎片产生。孔家你碎片过多时，将会给大对象分配带来很大麻烦，往往
      会出现老年代还有很大空间剩余，但是无法赵傲足够大的连续空间来分配当前对象
      ，不得不提前触发一次FULL GC。为了解决这个问题，CMS收集器提供了一个-XX
      use层面上聪明怕catfullcollection开关参数默认是开启的，用于在CMS收集器
      顶不住要进行FULLgc时候开启内测碎片的合并过程，内存整理的过程是无法并发的
      空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个
      参数-xxcmsfullgcsbeforeCompaction这个参数是用于设置执行多少次不压缩的
      FULL GC后，跟着来一次带压缩的 默认值为0，标识每次进入fullgc时候都进行碎片整理

  3.5.7 G1收集器
   G1 garbage first 收集器是当今收集器技术发张的最前沿成果之一，早在JDK7刚刚
确立项目目标，sun公司给出的jdk7 roadmap里面，他就被视为jkk7中hotspot
迅疾的一个重要优化特征。从jdk6中开始就有early access 版本的g1收集器供开发
人员实验、试用，由此开始G1收集器的 experimental  状态持续了数年时间，直至JKD
7 sun公司才认为它达到足够成熟的商用程序，移除了 experi mental 的标识 实验思想,
  G1是一款面相服务端应用的垃圾收集器。hotspot开发团队赋予它的使命是在比较长
  期的 未来可以替换掉5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点。
1.并行与并发：G1能充分利用多CPU 、多核环境下的硬件优势，使用多个CPU
来缩短stoptheworld停顿的时间，部分其他收集器原标需要停顿
java线程执行的GC动作，G1收集器仍然尅通过并发的方式让java程序继续执行。

2.分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要
其他收集器配合就能独立管理整个GC堆，但他能够采用不同的方式去处理新创建
的对象和已存活了一段时间、熬过多次Gc的就对象以获得根号的收集效果。
  
3.空间整合：与CMS的标记清理算法不同，G1从整体来看是基于标记-整理
算法实现的收集器，从局部两个 region 之间 上来看是基于复制算法实现的，
但无卵如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供
规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到
连续内存空间而提前触发下一次GC
  
4.可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共
同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用
者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过
N毫秒，这几乎已经是实时java的垃圾收集器的特征了。
  
   在G1之前的其他收集器进行收集的范围都是整个新生代或老年代，而G1不再是这
样。使用G1收集器时，java堆的内存布局就与其他收集有很大差别，它将整个java堆划
分为多个大小相等的独立区域 region ，虽然还保留有新生代和老年代的概念，但新生代和
老年代不再是屋里隔离的了，他们都是一部分 region 不需要连续的集合。
  G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个
java堆中进行全区域的垃圾收集。G1跟踪各个 region里面的垃圾堆积的价值大小 回收
所获得的空间大小以及回收所需时间的经验值，在后台维护一个优先列表，每次根据允许
的手机时间，优先回收价值最大的region  这样就是 garbage firest名称的来由。这种使用
region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在优先的时间内可以
获取尽可能高的收集效率.
    G1吧内存化整为零的思路，理解起来似乎很容易，但其中的实现细节却远远没有
想象中的那样简单，否则也不会从2004年sun实验室发飙第一偏G1的论文开始直到今天将近
10年时间才开发出G1的商用版。笔者以一个细节为例：吧java堆分为多个region
后，垃圾收集是否就真的能以 region为单位进行了？听起来顺利成章，再仔细想想就很容易
发现问题所在：region不可能是鼓励的。一个对象分配在某个region中，他并非只能被
本region中的其他对象引用，而是可以与整个java堆任意的对象发生引用关系。那在做可达性
判定确实对象是否存活的时候，岂不是还得扫描整个java堆才能保证准确性？这个问题其实并非在
G1中才有，只是在G1中更加突出而已。在以前的分带收集中，新生代的规模一般
都比老年代要小许多，新生代的手机也比老年代要频繁许多，那回收新生代中的对象时也
面临相同的问题，如果回收新生代也不得不同事扫描老年代的话，那么minor gc的效率可能下降不少
  在G1收集器中，region之间的对象引用以及其他收集器中的新生代与老年代之间的对象
引用，虚拟机都是使用remembered set来避免全堆扫描的。G1中每一个region都有一个与
之对应的remembered set ，虚拟机发现程序在对reference 类型的数据信息写操作时，会产
生一个writebarrier展厅中断写操作，检测reference引用的对象是否处于不同的region之
中（在分带的例子中就是检测是否老年代中的对象引用了新生代中的对象），如果是，便通
过cardtable把相关引用信息记录到被引用对象所属的region的remembered set之中。当
进行内存回收时，在GC根节点的枚举范围中加入remembered set 即可保证部队全堆扫描也
不会有遗漏。
    如果不计算维护remembered set 的操作，G1收集器的运作大志可划分为以下几个步骤：
    初始标记 initial marking
    并发标记 concurrent marking
    最终标记  final marking
    筛选回收  live data counting and evacuation
   对于cms收集器运作过程熟悉的读者，一定已经发现G1的前几个步骤的运作过程和
CMS有很多相似之处。出事标记阶段仅仅只是标记以下GC root能直接关联到的对象，并且
修改TAMS next top at mark start 的值，让狭义阶段用户程序并发运行时，能在正确可
用的region中创建新对象，这阶段需要停顿线程，但好事很短。并发标记阶段是从GCroot
开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发
执行。而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动
的那一部分标记积累，虚拟机将这段时间对象变化积累在线程 rememberedsetlogs里面
最终标记阶段需要吧rememberedset logs的数据合并到rememberedset中，这阶段需要停顿
线程，但是可并行执行。最后在筛选回收阶段首先对各个region的回收价值和成本进行排
序，根据用户锁期望的GC停顿时间来执行回收计划，从SUN公司透出来的信息来看，这个
阶段其实也可以做到与用户程序以前并发执行，但是因为只回收一部分region，时间是用
户可控制的，而且停顿用户线程将大幅提高手机效率。通过图可以比较清楚第看到G1
收集器的运作步骤中并发和需要停顿的阶段。
   由于目前G1成熟版本的发布时间还很短，G1收集器几乎可以说还没有经过实际应用
的考验，网络上关于G1收集器的性能测试也非常贫乏，到目前为止，笔者还没有搜索到
有关的生产环境下的性能测试报告。强调生产环境下的测试报告是因为对于垃圾收集器
来说，仅仅通过简单的java代码写个mirobenchmark 程序来创建、移除java对象，再
用-XX:+PrintGCDetails等参数来查看GC日志是很难做到准确衡量其性能的。因此，关于
G1收集器的性能部分，笔者引用了SUN实验室的论文 grabage-First garbage Collection 中
的一段测试数据。
   sun给出的 benchmark 的执行硬件为sun V880服务器
执行软件有两个，分别为specjbb模拟商业数据
库应用，堆中存活对象约为165MB ，结果反映吞吐量和最长事务处理时间和telo模拟电话
应答服务应用，堆中存活对象约100MB，结果反映系统能支持的最大吞吐量。为了便于
对比，还手机了一组使用parnew cms收集器的测试数据。所有测试都皮遏止为与CPU数量
相同的8条GC线程。
   在反映停顿时间的软实时目标soft real time goal 测试中，横向是两个测试软件的
时间片段配置，单位是毫秒，以XY的形式标识，代表在Y毫秒内最大循序GC时间为
X毫秒 对于CMS收集器，无法直接指定这个目标，通过调整分带大小的方式大志模拟
纵向是两个软件在对应配置和不同的java堆容量下的测试结果，V avg wv分别
代表的含义如下。
V:标识测试过程中，软实时目标失败概率，软实时目标失败即某个时间片段中实际
GC时间超过了允许的最大GC时间。

avgV:标识在所有实际GC时间超标的时间片段里，实际GC时间超过最大GC时间
的平均百分比 (实际GC时间减去允许最大GC时间，再除以总时间片段)。

Wv：表示在测试结果最差的时间片段里，实际GC时间占用执行时间的百分比。
  对于teleo来说，软实时目标失败的概率控制在0%-0&
之间，SPECJBB就要差一些，但也控制在2%-5% 之间，概率随着X、Y的比值减小而增
加。另方面，失败时超出允许GC时间的比值随着总时间片段增加而变小（分母变大了），
在100、200\512MB的配置下，G1收集器出现了某些时间片段下100时间在进行GC的
最坏情况，而相比之下，CMS收集器的测试结果就要差很多，3种java堆容量下都出现了
100时间进行GC的情况。
  在吞吐量测试总，测试数据取3次specjbb和15次telco的平均结果如图3-12所示。
在SPECJBB的应用下，各种配置下的G1收集器表现出了一直的行为，吞吐量看起来只与允
许最大GC时间成正比关系，而在TELOC的应用中，不同配置对吞吐量的影响则想的很微弱。
与CMS收集器的吞吐量对比可以看到，在SPECJBB测试中，在堆容量超过768MB时，CMS
收集器有5%-10%的优势，而在telco测试中，cms的优势则要小一些，只有34
左右。
   在更大规模的生产环境下，笔者引用一段在stackOverflow.com上看到的经验与读者分享
我在一个真实的、较大规模的应用程序中使用过G1：大约分配6-70G内存，存活
对象大约在20-50G之间。服务器运行linux操作系统，jdk版本为，G1与PS
psold相比，最大的好处是停顿时间更加可控、可预测，如果在PS中设置一个很低的最大
允许GC时间，譬如期望50毫秒完成GC -XX:MaxGCPauseMillis=50，但在65G的
java堆下有可能得到的直接结果是依次长达30秒至2分钟的漫长的stop the world过程;
而G1与cms相比，虽然它们都立足于底停顿时间，CMS仍然是我现在的选择，但是随着
oracle对G1的持续改进，我们相信G1会是最终的胜利者。如果你现在采用的收集器没有出
现问题，那就没有任何理由现在去选择G1，如果你的应用追求低停顿，那G1现在已经可
以作为一个可尝试的选择，如果你的应用追求吞吐量，那G1并不会为你带来什么特别的
好处。


3.5.8 理解GC日志
   阅读GC日志是处理java虚拟机内存问题的基础技能，它只是一些人为确定的规则，没有
太多技术含量。在本书的第一版中没有专门讲解如何阅读GC日志，为次作者收到许多
读者来信，反映对此感到困惑，因此专门增加本节内容来境界如何理解GC日志。
   每一种收集器的日志形式都是由他们自身的实现所决定的，换而言之，每个收集器的日
志格式都可以不一样。但虚拟机设计者为了方便用户阅读，将各个收集器的日志都维持一定的
共性，例如以下两段经典的GC日志。
33.125 GC DefNew 
       Full GC
    最前面的数字33和100 :代表了GC发生的时间，这个数字的含义是从
java虚拟机启动以来经过的秒数。
    GC日志开头的GC和FULL GC说明了这次垃圾收集的停顿类型，而不是用来区分
新生代GC还是老年代GC的。如果有FULL说明这次GC是发生了 STW  stoptheworld的
例如下面这段新生代收集器parnew的日志也会出现FULLGC 这一般是因为出现了分配
担保失败之类的问题，所以才导致STW。如果是调用system.gc方法所触发的收集，那么
在这里将显示FULLgc SYSTEM
  Full GC 283.736 parnew
     接下来的defnew tenured perm 表示GC发生的区域，这里显示的区域名
称与使用的GC收集器是密切相关的，例如上面样例所使用的serial收集器中的新生代名称为

defualt new generation 所以显示defNew .如果是parnew收集器，新生代名称
就会变为parnew ,意为 parallel new Generation .如果采用parallel scavenge收集器。
那它配套的新生代称为psyounggen 老年代和永久代同理，名称也是由收集器决定的。
 后面方括号内部的哈你是GC前该内存区域已用容量- GC后该内存区域已使用容量。
 而在方括号之外的
标识 GC钱堆已使用容量 GC后java堆已使用容量 java堆总容量。
  再往后，表示该内存区域GC所占用的时间，单位是秒。有的收集器
会给出更具体的时间数据如 times use0.01 sys0 real0.02 这里面的
use sys real 与linux的time命令所输出的时间含义一直，分别代表用户态小号的CPU
时间 内核态小号的CPU事件和操作从开始到结束所经过的抢种时间 wall clock itme
cpu时间与抢种时间的区别是，抢种时间包括各种非运算的等待耗时，例如等待磁盘
等待线程阻塞，而CPU时间不包括这些耗时，但当系统多CPU或者多和的话，多线程操作
会叠加这些CPU时间，所以读者看到use或sys时间超过real时间是完全正常的。

3.5.9 垃圾收集器参数总结
   jdk1.7 中的各种垃圾收集器到此已全部介绍完毕，在描述过程中提到了很多虚拟机非
稳定的运行参数，在表3-2中整理了这些参数实践

UseSerialGC  虚拟机运行在client模式下的默认值，打开此开关后，使用serial+serial old 的收集器组合进行内存回收。

UserParNewGC 打开此开关后，使用ParNew+Serial Old的收集器组合进程内存回收

UseConcMarkSweepGC 打开此开关后，使用ParNew+CMS+Serial Old的收集器组合进行内存回收
                    SerialOld收集器将作为CMS收集器出现ConcurrentModeFailure失败后的后备收集器使用。
                    
UserParallelGC    虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge +SerialOld (MarkSweep)的收集器组合进行内存回收

SurivorRatio    新生代中eden区域与survivor区域的容量壁纸默认是8，代表eden:survivor =8:1

PretenureSizeThreshold  直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象
                        将直接在老年代分配。
                        
MaxTenuringThreshold    晋升到老年代的对象年龄，每个对象在坚持过一次minor GC之后，年龄就增加1，当超过这个参数就进入老年代

UseAdaptiveSizePolicy   动态调整JAVA堆中各个区域的大小以及进入老年代的年龄

HandlePromotionFailure   是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个
                         eden和survivor区的所有对象都存活的极端情况
                         
ParallelGCThreads         设置并行GC时进行内存回收的线程数量

GTTimeRatio               GC时间占总时间的比率，默认值为99，允许1%的GC时间。仅在使用parallel scavengt收集器时生效。

MaxGCPauseMillis           设置GC的最大停顿时间。仅在使用Parallel Scavenge 收集器时生效

CMSinitiatingOccupancyFraction  设置CMS收集器在老年代控件被使用多少后出发垃圾收集。默认值为
                                 68，仅在使用CMS收集器时生效

UseCMSCompactAtFullCollection   设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效

CMSFullGCsBeforeCompaction        设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。 仅在CMS生效。


3.6 内存分配与回收策略
    java 技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对
象分配内存以及回收分配给对象的内存。关于回收内存这一点，我们已经使用了大量篇幅去
介绍虚拟机中的垃圾收集器体系以及运作原理，现在我们再一起来探讨一下给对象分配内存
的那点事儿。
    对象的内存分配，往大方向讲，就是在堆上分配但也可能经过JIT编译后背拆散为标量类型
并间接地栈上分配，对象主要分配在新生代的eden区上，如果启动了本地线程分配
缓存，将按线程有限在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的
规则并不是百分之百的固定，其细节取决于当前使用的是那一种垃圾收集器组合，还有虚拟机
中雨内存相关的参数的设置。
      接下来我们将会讲解几条最普遍的内存分配规则，并通过代码去验证这些规则。本节下
面的代码在测试时使用client模式虚拟机运行，没有手工指定收集器组合，换句话说，验证
的是在使用serial serial old parnewserifial 收集器组合的规则也基本一致
的内存分配和回收的策略。读者不妨根据自己项目中使用的收集器歇一歇城区验证一下使用其他
集中收集器的内存分配策略。

3.6.1 对象优先在eden分配
      大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚
拟机将发生一次Minor 发@ GC。
     虚拟机提供了-XX+printGCdetails这个收集器日志参数，告诉虚拟机在发生垃圾收集
行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。在实际
应用中，内存回收日志一般是打印到文件后通过日志工具进行分析，不过本实验的日志并不
多，直接阅读就能看得很清楚。
    代码清单中尝试分配3个2mb大小和1个4MB大小的喜爱那个，在运行时通过xms20M -xmx20M
xmn10M这三个参数限制了java堆大小为20MB
不可扩展，其中10MB分配给新生代，剩下的10MB分给老年代。XXSurvivorRatio8决
定了新生代中Eden区与一个Survivor区域比例8：1，从输出的结果也可以清晰地看到
den space 8 form space 1024 to space 1024的信息，新生代总可用空间为
9216K
      发生一次minor GC 新生代6651变为147KB ，而总内存占用量则几乎没有减少因为
虚拟机几乎没找到可回收的对象。GC发生的愿意是给4分配内存的是发现EDEN已经被占6M剩余空间不足以
分配4mb内存，因此发生Minorgc GC期间虚拟机又发现已有的
3个2MB大小的对象无法全部放入 survivor幸存者控件，所以只好通过
分配担保机制提前转义到老年代去。
   分配结束后 den占用4MB 是4  survivor空 老年代6MB 1、2、3占用
   新生代GC minor GC 
    老年代GC major  GC FullGC:
3.6.2 大对象直接进入老年代
   所谓的大对象是指，需要大量连续内存空间的java对象，最经典的大对象就是那种很长
的字符串以及数组笔者列出的例子中byte数组就是经典的大对象。大对象对虚拟机的
内存分配来说就是一个坏消息（替java虚拟机抱怨一句，比遇到一个大对象更加坏的消息就
是遇到一群朝生夕死的短命大对象，写程序的时候应当避免）经常出现大对象容易
导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来安智他们。
    虚拟机提供了一个xxpretenuresizethreshold参数，令大于这个设置值的对象直接在老
年代分配。这样做的目的是避免在eden区以及两个survivor区之间发生大量的内存复制复
习一下：新生代采用复制算法收集内存。
    执行代码清单3-6中的testPretenureSizeThreshold方法后，我们看到eden空间机会没有
被使用，而老年代的10MB控件被使用了40%，也就是4MB的allocation对象直接就分配
在老年代中，这是因为pretenureSizeThreshold被设置为3MB这个参数不想像xmx之类的参数一致直接写3M
因此超过3MB的对象都会直接在老年代进行分配。

3.6.3 长期存活的对象将进入老年代
   既然虚拟机采用了分带收集的思想来管理内存，那么内存回收时就必须能识别哪些
对象应放再新生代，哪些独享应放在老年代。为了做到这点，虚拟机给每个对象定义
了一个对象年龄Age计数器。如果对象在eden出生并经过一次minorGC后仍然存活
，并且能被survivor容纳的话，将被移动到survivor空间中，并且对象年龄设为1.对
象在survivor区中每熬过一次minorGC ，年龄就增加一岁，当它的年龄增加到一定程
度默认15岁，就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数
MaxTenuringThreshold设置。
   读者可以试试分别MaxTenuring延长Threshold门槛 ,此方法中对象需要256k内存
survivor控件可以容纳。当maxTenuringThreshold=1,allocation对象
在第二次GC发时进入老年代，新生代已经使用的内存GC后非常感觉地变长了0.而
张勇400k

3.6.4 动态对象年龄判定
   为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到
了MaxTenuringThreshold才能晋升老年代，如果在survivor空间中相同年龄所有对象大小的
综合大于survivor空间的一半，年龄大于或等于改年龄的对象就可以直接进入老年代，无需等到
maxTenuringThreshold中要求的年龄。
  执行代码清单方法，并设置MaxTenuringThreshold=15,
  会发现运行结果中surivor的空间占用仍然Wie0%，而老年代比预想增增加6%，也就是说
  1 2 对象直接进入了老年代，儿没有等到15岁的临界年。因为这两个
  对象加起来已经达到了512K，并且他们是同年的，满足同年对象达到survivor空间的
  半规则。我们只要注释掉其中一个对象的new操作，就会发现另外一个就不会晋升到老年代中去了

3.6.5 空间分配担保
   在发生minor gc之前，虚拟机会先检测老年代最大可用的连续控件是否大于新生
代所有对象总空间，如果这个条件成立，那么minorGC可以确保是安全的。如果不成
立，则虚拟机会查看handlePromotionFailure设置值是否允许担保失败。如果允许，那么
会继续检测老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果
大于，将尝试着进行一次MINORgc，尽管这次minorGC是有风险的，如果小于，或者
handlePromotionFailure设置不允许毛线，那这时也要改为进行一次FUllGC。
   下面解释一下冒险是冒什么风险，前面提到过，新生代使用复制手机算法，但
为了内存利用率，只使用其中一个survivor控件来座位轮转备份，因此当出现大量对象在
minor GC后仍然存活的情况，最极端的情况就是内存回收后新生代所有对象都存活，就
需要老年代进行分配打包，吧survivor无法容纳的对象直接进入老年代。与生活中的贷款到包类
，老年代要进行这样的担保，前提是老年代本身还有熔断这些对象的剩余空间，一共
有多少对象会活下来在实际完成内存回收之前是无法明确的，所以只好取之前每一次回
收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是
否进行fullGC来让老年代腾出更多空间。
   取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次minorgc存活
后的对象突增，媛媛高于平均值的话，依然会导致担保失败handle promotion failure
如果出现了handlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。虽然
担保失败时绕的圈子是最大的，但大部分情况下都还是会将handlePromotionFailure开关打
开，避免Full GC过于频繁，

jdk 6update 24之后，这个测试结果会有差异，handlePromotionFailure参数不会再
影响到虚拟机的空间分配担保策略，观察Openkjdk中的源码变化虽然
源码中还定义了handlePromotionFailure参数，但是在代码中已经不会再使用它。jdk624
之后的规则变为只要老年代的连续空间大于新生代UI想大小或者历次晋升的平均大小
就会进行minor gc 否则讲进行Fullgc

本章小结
   本章介绍了垃圾收集的算法、几款JDK7中提供的垃圾收集器特点以及运作原理。通
过代码实例验证了java虚拟机中自动内存分配以及回收的主要规则。
   内存回收与垃圾收集器在很多时候都是影响系统性能、并发能力的主要因素之一，虚拟机
之所以提供多种不同的收集器以及提供大量的调节参数， 是因为只有根据实际需求、
  实现方式选择最优的收集方式才能获取最高的性能。没有固定收集器、参数组合，也没有最
  优的调优方法，虚拟机也就没有什么必然的内存回收行为。因此，学习虚拟机内存只是，如
  果要到实践调优阶段，那么必须了解每个具体收集器的行为、优势和掠视、调节参数。在
  接下来的两章中，作者将会介绍内存分析工具的调优的一些具体案例。


















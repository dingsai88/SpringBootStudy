
第13章 线程安全与锁优化

   并发处理的广泛应用是使得amdahl定律代替摩尔定律成为计算机性能发展源动力的根
本原因，也是人类压榨计算机运算能力的最有力武器。
 
13.1 概述
   在软件业发展的初期，程序编写都是以算法为核心的，程序员会把数据和过程分别作为
独立的部分来考虑，数据代表问题空间中的客体，程序代码则用于处理这些数据，这种思维
方式直接站在计算机的角度去抽象问题和解决问题，成为面向过程的编程思想。与此相对的
是，面相对象的编程思想是站在现实世界的角度去抽象和解决问题，它把数据和行为都看做
是对象的一部分，这样可以让程序员能以符合现实世界的思维方式来编写和组织程序。
  面相过程的编程思想极大地提升了现代软件开发的生产效率和软件可以达到的规模，但
是现实世界与计算机世界之间不可避免地存在一些差异。例如，人们很难想像现实中的对象
在一项工作进行期间，会被不停地中断和切换，对象的属性数据可能会在中断期间被修
改和变脏，而这些事件在计算机世界中则是很正常的事情。有时候，良好的设计原则不
得不向现实做出一些让步，我们必须让程序在计算机中正确无误地运行，然后再考虑如何将
代码组织得很好，让程序运行得更快。对于这部分的主体高效并发来讲，首先需要保证
并发的正确性，然后在此基础上实现高效。本章先从如何保证并发的正确性和如何实现线程
安全讲起。

13.2 线程安全
   线程安全这个名称，相信稍有经验的程序员都会听说过，甚至在代码编写和走查的
时候可能还会经常挂在嘴边，但是如何找到一个不太绕口的概念来定义线程安全却不是一件
容易的事情，笔者尝试在google中搜索它的概念，找到的是类似于如果一个对象可以安
全地被多个线程同时使用，那它就是线程安全的 这样的定义 并不能说它不正确，但是
人们无法从中获取到任何有用的信息。
    笔者认为java concurrency in practive 的作者briangoetz对线程安全有一个比较
恰当的定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度
和交替执行，也不需要额外的同步，或者在调用方进行任何其他的协调操作，调用这个
对象的行为都可以获得正确的结果，那这个对象是线程安全的。
   这个定义比较严谨，它要求线程安全的代码都必须具备一个特征：代码本身封装了所有
必要的正确性保障手段如互斥同步等，令调用者无须关心多线程的问题，更无须自己采取
任何措施来保证多线程的正确调用。这些听起来简单，但其实并不容易做到，在大多数场景
中，我们都会将这个定义弱化一些，如果把调用这个对象的行为限定为单次调用
这个定义的其他描述也能够成立的话，我们就可以程他是线程安全了，为什么要弱化这个定义
现在战且放下，稍后再详细探讨；

13.2.1 Java语言中的线程安全
   我们已经有了线程安全的一个抽象定义，那接下来就讨论一下在java语言中，线程安全
具体是如何体现的？有哪些操作是线程安全的？我们这里讨论的线程安全，就限定于多个线
程直接存在共享数据访问这个前提，因为如何一段代码根本不会与其他线程共享数据，那么
从线程安全的角度来看，程序是串行执行还是多线程执行对它来说是完全没有区别的。
   为了更加深入地理解线程安全，在这里我们可以不把线程安全当做一个非真即假的二元
排他选项来看待，按照线程安全的安全程度由强至弱来排序，我们可以将java语言中
各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线
程对立。
   1.不可变
   在java语言中特指jdk1.5以后，及java内存模型被修正之后的java语言，不可
变immutable的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不
需要再采取任何线程安全保障措施，在第12章我们谈到final关键字带来的可见性时曾经
提到过这一点，只要一个不可变的对象被正确地构建出来 没有发生this引用逃逸的情况
那其外部的可见状态永远也不会改变，永远也不会看到它在多个线程之中处于不一致的状
态。不可变带来的安全性是最简单和最纯粹的。
    java语言中，如果共享数据是一个基本数据类型，那么只要在定义时使用final关键字
修饰它就可以保证它是不可变的。如果共享数据是一个对象，那就需要保证对象的行为不会
对其他状态产生任何影响才行，如果读者还没想明白这句话。不妨想一想java.lang.string类的
对象，它是一个典型的不可变对象，我们调用它的substringreplace和concat这些方法
都不会影响他原来的值，只会返回一个新构造的字符串对象。
   保证对象行为不影响自己状态的途径有很多种，其中最简单的就是把对象中带有状态
   的变量都声明为final，这样在构造函数结束之后，它就是不可变的，例如代码清单中
java.lang.interger构造函数所示的，它通过将内部状态变量value定义为final来保障状态不变。


   在Java API中符合不可变要求的类型，除了上面提到的String之外，常用的还有枚举类
型，以及java.lang.number的部分子类，如long和double等数值包装类型，Bigintger和
bigdecimal等大数据类型：但同为number的子类型的原子类atomicinterger和atomiclong
则并非不可变的，读者不妨看看这两个原子类的源码，想一想为什么。

   2.绝对线程安全
   绝对的线程安全完全满足brian goetz给出的线程安全的定义，这个定义其实是很严格
的，一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”通常需要
付出很大的，设置有时候是不切实际的代价。在javaapi中标注自己是线程安全的类，大多数
都不是绝对的线程安全。我们可以通过javaAPI 中一个不是绝对线程安全的线程安全
类来看看这里的绝对是什么意思。vector
  如果说java.util.vector是一个线程安全的容器，相信所有的java程序员对此都不会有异
议，因为他的add、get（）和size这类方法都是被synchronized修饰的，尽管这样效率很低
但确实是安全的。但是，及时它所有的方法都被修饰成同步，也不意味着调用它的时候永远
都不再需要同步手段了，请看一下代码清单13-2中的测试代码。

   很明显，尽管这里使用到的vector的getremove和size方法都是同步的，但是在
多线程的环境中，如果不再方法调用点做额外的同步措施的话，使用这段代码仍然是不安全的
，因为如果另一个线程恰好在错误的时间删除了一个元素，导致序号I已经不再可用的话
，再用I访问数组就会抛出一个arrayindexoutofboundsexception。如果要保证这段代码
能正确执行下去，我们不得不把removethread和printthread的定义改成如代码清单所示的样子

3.相对线程安全
    先对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的
操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的
连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。上面代码清单
就是相对线程安全的明显案例。
   在java语言中，大部分的线程安全类都属于这种类型，例如vector、hashtable、collectionss、
   synchronizedCollection方法包装的集合等。
4.线程兼容
    线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段
来保证对象在并发环境中可以安全的使用，我们平常说的一个类不是线程安全的，绝大多数
时候是指的是一种情况。javaapi中大部分的类都是属于线程兼容的，如与签名的vector和
hashtable相对应的结合类arraylist和hashmap等。

5.线程对立
   线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码
。由于java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，
而且通常都是有害的，应当尽量避免。
   一个线程对立的例子就是thread类的suspend（）和resume方法,如果有两个线程同时持
有一个线程对象，一个常识去中断线程，另一个尝试去恢复线程，如果并发进行的话，无论
调用时是否进行了同步，目标线程都是存在死锁风险的，如果suspend中断的线程就是即
将要执行resume的那个线程，那就肯定要产生死锁了。也正式由于这个原因，suspend和
resume方法已经呗jdk声明废弃 deprecated 了。常见的线程对立操作还有System.setin()
System.setout 和system.runfinalizersOnexit()等。

13.2.2 线程安全的实现方法
    了解了什么是线程安全之后，紧接着的一个问题就是我们应该如何实现线程安全，这听
起来似乎是一件由代码如何编写来决定的事情，确实，如何实现线程安全与代码编写有很大
的关系，但虚拟机提供的同步和锁机制也起到了非常重要的作用。本节中，代码编写如何实现
线程安全和虚拟机如何实现同步与锁这两者都会有所设计，相对而言更偏重后者一些，只要
读者了解了虚拟机线程安全手段的运作过程，自己去思考代码如何编写并不是一件困难的
事情。
     1.互斥同步
     互斥同步 mutuaExclusion&synchronization 是常见的一种并发正确性保障手段。
同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个或者是
一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（critical
Section）、互斥量mutex和信号量semaphore 都是主要的互斥实现方式。因此，在这
四个字里面，互斥是因，同步是过：互斥是方法，同步是目的。
    在java中，最基本的互斥同步手段就是synchronized关键字，synchronized关键字经过
编译以后，会在同步块的前后分别行程 monitor enter 和monitro exit 两个字节码指令，这两
个字节码都需要一个reference类型的参数来志明要锁定和解锁的对象。如果java程序中的
synchronized明确制定了对象参数，那就是这个对象的reference:如果没有明确指定，那就是根据
synchronized修饰的是实例方法还是类方法，去去对应的实例或class对象来作为
锁对象。
   根据虚拟机规范的要求，在执行monitor enter 指令，首先要尝试获取对象的锁。如果
这个对象没被锁定，或者当前线程已经拥有了那个对象的所，，吧锁的计数器家1，响应的
在执行monitor exit 指令时会将锁计数器减一，当计数器为0时，锁就被释放。如果获取对象
锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。
   在虚拟机规范对monitor enter和moniter exit的行为描述中，有两个是需要特别注意的。
首先，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。
其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。第12章讲过，java
的线程是映射到操作系统的原生线程智商的，如果要阻塞或唤醒一个线程，都需要操作系
统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间
。对于代码简单的同步块（如被synchronized修饰的getter()或setter()方法），状态转换消
耗的时间有肯呢个比用户代码执行的时间还要常。所以synchronized是java语言中一个重量级
Heavyweight的操作,有经验的程序员都会在确实必要的情况下才使用这种操作。而虚拟
机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，避免
频繁地切入到核心态之中。
   除了synchronized之外，我们还可以使用java.util.concurrent下文称为JUC包中的重
入锁(ReentrantLock)来实现同步，在基本用上，Reentrant lock于synchronized很相似，
他们都具备一样的线程重入特征，只是代码写法上有点区别，一个表现为API层面的互斥锁
lock和unlock方法配合try finally语句块来完成，另一个表现为原生语法层面的互斥锁
。不过相比synchronized，reentrantLock增加了一些高级功能，主要有以下三项：等待
可中断、可实现公平锁，以及所可以绑定多个条件。
   
   等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择
   放弃等待，改为处理其他事情，可中断特定对处理执行时间非常长的同步块很有
   帮助。
   
   公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来一次获得锁；
   而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得
   锁。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以
   通过带布尔值的构造函数要求使用公平锁。

    锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个condition(状态)对象，而
    在synchronized中，锁对象的wait和notify或notifyall方法可以实现一个隐含
    的条件，如果要和多余一个的条件关联的时候，就不得不额外地添加一个锁，而
    ReentrantLock则无须这样做，只需要多次调用newCondition方法即可。
    
  如果需要使用上述功能，选用ReentrantLock是一个很好的选择，那如果是基于性能考虑
呢？关于synchronized和reentrantlock的性能问题，Brian goetz对这两种锁在jdk1.5与
单核处理器，以及jdk5与双xeon处理器环境下作了一组吞吐量对比的实现。结果如下

P393
  从图可以看出，多线程环境下synchronized的吞吐量下降得非常严重,
而ReentrantLock则能基本保持在同一个比较稳定的水平上。与其说reentrantlock性能好，
还不如说synchronized还有非常大的优化余地。后续的技术发展也证明了这一点，.6
中加入了很多针对锁的优化措施，jdk发布之后
人民就发现synchronized和reentrantlock性能基本上是完全持平了。因此如果读者的程
序是6以上部署的话，性能因素就不再是选择renntrantlock的理由了，虚拟机
在未来的性能改进中肯定也会更加偏向原生synchronzied,所以还是提倡在synchronized
能实现需求的情况下，优先考虑使用synchronized来进行同步

   2.非阻塞同步
   互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称
为阻塞同步blicking synchronization.从处理问题的方式上说，互斥同步属于一种悲观
的并发策略，总是认为只要不去做正确的同步措施例如加锁，那就肯定会出现问题，无
论共享数据是否真的会出现竞争，他都要进行加锁这里讨论的是概念模型，实际上虚拟机
会优化掉很大一部分不必要的加锁、用户态核心态转换、维护锁计数器和检查是否有被阻
塞的线程需要唤醒等操作。随着硬件指令集的发展，我们有了另外一个选择：基于冲突检测
的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程征用共享数据，那操作就
成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施
就是不断地重试，直到成功为止，这种乐观的并发策略的许多实现都不需要把线程官气，
因此这种同步操作称为非阻塞同步non blocking synchronization.
   为什么笔者说使用乐观并发策略需要硬件指令集的发展才能进行呢，因为我们需要
操作和冲突检测这两个步骤局部原子性，靠什么来保证呢，如果这里再使用互斥同步来保证
就是去意义了，所以我们只能靠硬件来完成这件事情，硬件保证一个从语义上看起来需要多
次操作的行为只通过一条处理器指令就能完成，这类指令常用的 有

     1.测试并设置 test and set
     2.获取并增加 fetch and increment
     3.交换swap
     4.比较并交换 compare and swap 下文程 CAS
     5.加载链接 条件存储 load linked / stroe conditional  下文称LL/SC

      其中，前面的3条是 20实际就已经存在于大多数指令集之中的处理器指令，后面的两
条是现代处理器新增的，而且这两条指令的目的和功能是类似的。在1a64 x86指令集中有
cmpxchg指令完成CAS功能，在sparc tso也有casa 指令实现，而在arm和powerpc框架
下，则需要使用一堆ldrex  strex 指令来完成LL SC 的功能。
     CAS指令需要有三个操作数，分别是内存位置 在java中可以简单理解为变量的内存
地址用V表示、 就得预期值用A表示 和新值用B表示。 cas指令执行时，当且
仅当V符合旧预期值A时，处理器用新值B更新V的值，否则他就不执行更新，但是如论
是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作。
     jdk5之后，javachengxu中才可以使用CAS compare and swap 比较并替换操作，该操作由于unsafe类里面
的compareAndSwapInt和compareAndSwapLong等几个方法包装提供，虚拟机在内部对
这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器 compare And swap 指令，没有
方法调用的过程，或者可以认为是无条件内联进去了。
    由于unsafe类不是提供给用户程序调用的类unsafe.getUnsafe的代码中限制了只有
启动类加载器bootstrap classloader加载的class才能访问它，因此如果不再用反射
手段，我们只能通过其他的javaapi来简介使用它，如juc包里面的整数原子类，其中的
compareandset和getandincrement等方法都使用了unsafe类的compareAnd swap操作。
   我们复方那一段么有解决的问题代码来看看如何使用compare and swap操作来避免阻塞
同步，代码如代码所示，我们曾经通过这段20个线程自增1000次的代码来证明
volatile变量不具备原则，那么如何才能让它具备原子性呢  吧race++活increase 
方法用同步块包括起来当然是一个方法，效率会提升 atomic
  
   使用atomicInteger代替int后，程序输出了正确的结果，一切都要归功于incrementAndGet
方法的原子性。它的实现其实非常简单，
    incrementAndGet方法在一个无限循环中，不断尝试将一个比当前值大1的新值赋给自己。
如果失败，那说明在执行获取设置操作的时候值已经有了修改，于是再次循环
进行下一次操作，知道设置成功未知。
   尽管compareAndSwap看起来很美，但先让这种操作无法涵盖互斥同步的所有使用场景，并且compareAndSwap
从语义上来说并不是完美的，存在这样的一个逻辑漏洞：如果一个变量V初次读取的时候是
A值，并且在准备复制的时候检查到它仍然为A值，那我们就能说它的值没有被其他线程改
变过了吗？如果在这段期间它的值曾经被改成了B，后来又被改回A，那CAS操作就会误认
为它从来没有被改变过吗。这个漏洞称为CAS操作的ABA问题。JUC包为了解决这个问题
，提供了一个带有标记的原子引用类atomicstampedReference，它可以通过控制变量值
的版本来保证CAS的正确性。不过目前来说这个类比较鸡肋，大部分情况下ABA问题
不会影响程序并发的正确性，如果需要解决ABa问题，改用传统的互斥同步可能会比原子类更高效。

  3.无同步方案
   要保证线程安全，并不是一定要进行同步，两者没有因果关系。同步只是保证共享数据
争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无需任何同步
措施去保证正确性，因此会有一些代码天生就是线程安全的，笔者简单地介绍其中的两类。
    可重入代码 Reentrant code:这种代码也叫做纯代码purecode，可以在代码执行
的任何时刻中断它，转而去执行另外一段代码包括递归本身，而在控制权返回后，
原来的程序不会出现任何错误。相对线程安全的，但是并非所有的线程安全的代码都是可
重入的。
     可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和共用的系统资源、用到
的状态量都由参数中传入、不调用非可重入的方法等。我们可以通过一个简单的原则来判断
代码是否具备可重入性：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据
，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。
     线程本地存储 thread local storage ：如果一段点钟所需要的数据必须与其他代码共
享,那就看看这些共享数据代码是否能保证在同一个线程中执行？如果能保证，我们就可以
把共享数据的可见范围限制在同一个线程之内，这样，无需同步也能保证线程之间不出现数据
征用的问题。
     符合这种特点的应用并不少见，大部分使用消费队列的架构如生产者消费者模式
都会将产品的消费过程尽量在一个线程中消费完，其中最重要的一个应用实例就是
最经典web交互模型中的一个请求对应一个服务器线程thread per request的处方式
，这种处理方式的广泛应用使得很多web服务端应用都可以使用线程本地存储来解决线程安全问题。

   java 语言中，如果一个变量要被多线程访问，可以使用volatile关键字声明它为易变的
的;如果一个变量要被某个线程独享，java中就没有类似CC__中的这样的关键字
不过还是可以通过threadlocl类来实现线程本地存储的功能。每一个
线程的thread对象中都有一个threadlocalmap对象，这个对象存储了一组以threadlocal
threadlocalhsahcode为键值，以本地线程变量位置的KV值对，threadlocal对象就是当前
线程的threadlocalmap的访问入口，每一个threadlocal对象都包含了一个独一无二的
threadlocalhashcode值，使用这个值就可以在线程KV值对重找回对应的本地线程变量。

13.3锁优化
   高效并发是从JDK1.5到jdk1.6的一个重要改进,Hotspot虚拟机开发团队在这个版
本上花费了大量的精力去实现各种锁优化技术，如适应性自旋 adaptive spinning 、锁消除
Lock Elimination 、锁粗化 Lock coarsening 、轻量级锁 lightweight locking 和偏向锁
biased locking 等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，
从而提高程序的执行效率。

13.3.1 自旋锁与自适应自旋
   前面我们讨论互斥同步的时候，提到了互斥同步对性能最大的影响是阻塞的实现，挂
起线程和恢复线程的操作都需要转入内核态完成，这些操作给系统的并发性能带来了很大
的压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很
短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理
器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个小城稍等一下
，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等
待，我们只需让线程执行忙循环 （自旋），这项技术就是所谓的自旋锁。
  自旋锁在jdk1.4.2中就已经引入，只不过默认是关闭的，可以使用-XX:+UseSpinning
参数来开启，在JDK1.6中就阴茎改为默认开启了。自旋等待不能代替阻塞，且先不说对处
理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，
因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间
很长，那么自旋的线程智慧白白消耗处理器自旋，而不会做任何有用的工作，反而会带来性
能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然
没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是10次用户
可以使用参数-XX:PreBlockSping来更改。
   在jdk1.6中引用了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前
一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等
待刚刚成功获得过锁，并且持有锁的线程在运行中，那么虚拟机就会认为这次自旋也很有
可能再次成功，今儿他将允许自旋等待持续相对更长的时间，比如100个循环。另外，如果
对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避
免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对
程序锁的状况预测就会越来越准确，虚拟机就会变得越来越聪明了。

   13.3.2 锁消除
   锁消除是指虚拟机及时编译器在运行时，对一些代码上要求同步，但是被检测到不可能
存在共享数据竞争的锁进行消除。锁消除的主要判断依据来源于逃逸分析的数据支持
，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而
被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步锁
自然就无需进行。
    也许读者会有疑问，变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是
程序员自己应该是很清楚的，怎么会在明知道不存在数据征用的情况下要求同步呢？答案是
有许多同步措施并不是程序员自己加入的，同步的代码在java程序中普遍成都也许超过了
大部分读者的想象。我们来看看代码清单13-6中的例子，这段非常简单的代码仅仅是输出3个
字符串相加的结果，无论是源码字面还是程序语义上都没有同步。
    我们也知道，由于string是一个不可变的类，对字符串的连接操作总是通过生成新
的string对象来进行的，因此javac编译器会对string连接做自动优化。在jdk1.5之前
会转化为stringbuffer对象的连续append操作，在jdk1.5以及以后的版本中，会转换为
stringbuilder对象的连续append操作，即代码清单中可能会
  现在大家还认为这段点没有涉及同步吗每个stringbuffer。append方法中都有一个同步块
锁就是sb对象。虚拟机观察变量SB很快就会发现它的动态作用域被限制在
concatstring方法内部。也就是说，sb的所有引用永远不会逃逸到concatstring 方法
之外，其他线程无法访问到它，因此虽然这里有锁，但是可以被安全第消除掉，在即使编译
之后，这段代码就会忽略掉所有的同步而直接执行了。
13.3.3 锁粗化
   原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小--只在
共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如
果存在锁竞争，那等待的线程也能尽快拿到锁。
  大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复
加锁和解锁，甚至加锁操作是出现在循环体中，那即使没有线程竞争，频繁地进行互斥
同步操作也会导致不必要的性能损耗。
   代码清单13-7中连续的append方法就属于这类情况。如果虚拟机探测到有这样一串
零碎的操作都对同一个对象加锁，将会把加锁同步的范围拓展粗话到整个操作序列的外部
，以代码清单13-7为例，就是拓展到第一个append操作之前直至最后一个append操作
之后，这样只需要加锁一次就可以了。

   13.3.4 轻量级锁
   轻量级锁是jdk6之中加入的新型锁机制，它名字中的轻量级是相对于使用操作
系统互斥量来实现的传统锁而言的，因此传统的锁机制就称为重量级锁。首先需要强调
一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，
减少传统的重量级锁使用操作系统互斥量产生的性能消耗。
   要理解轻量级锁，以及后面将会降到的偏向锁的原理和运作过程，必须从hotspot虚拟机
的对象对象头部分的内存布局开始介绍。hostspot虚拟机的对象头 object header 分为两部分信息。
第一部分用于存储对象自身的运行时数据，如哈希吗hashcode\gC分代
年龄generational GC age等，这部分数据的长度在32位和64位虚拟机中分别为32bit
和64bit，官方称它为mark word,它是实现轻量级锁和偏向锁的关键。另外一部分用于
存储指向方法区对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分用于存储
数组长度。
   对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，
Mark word 被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的信息，他会根
据对象的状态复用自己的存储空间。例如，在32位的hostspot虚拟机中独享未被锁定的状态
下，markword的32bit控件中的25bit用于存储对象哈希吗hashcode，4bit用于存储对
象分带年龄，2bit用于存储锁标志位，1bit固定为0，其他状态轻量级锁定，重量级锁定
GC标记、可偏向下对象的存储内容课件表13-1

HotSpot虚拟机对象头MarkWord

存储内容  标志位  状态
对象哈希码对象分带年龄   01 未锁定
指向锁记录的指针   00  轻量级锁定
指向重量级锁的指针  10  膨胀 重量级锁定
空，不需要记录细腻系  11  GC标记
偏向线程ID 偏向时间戳 对象分代年龄  01 可偏向
 
 简单地介绍了对象的内存布局后，我们把话题返回到轻量级锁的执行过程上。在代码
进入同步块的时候，如果此同步对象没有被锁定 锁标志位为01状态 虚拟机首先将
在当前线程的栈帧中建立一个名为锁记录lock record的控件，用于储存锁对象目前的
mark word的拷贝（官方把这份拷贝加了一个 displaced 前缀，即displaced mark word），这
时候线程堆栈与对象头的状态如图13-3 所示。
   然后，虚拟机将使用CAS  compare and swap操作尝试将对象的mark word 更新为指向lock record的指针
。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象markword的
锁标志位mark word 的最后2bit 将转变为00 ,即表示此对象处于轻量级锁定状态，这
时候线程堆栈与对象头的状态如图13-4所示。

   如果这个更新操作失败了，虚拟机首先会检查对象mark word是否指向当前线程的栈帧
，如果只说明当前线程已经拥有了这个对象的锁，那就可以直接今日同步块继续执行，否
则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级
锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为10 ，markword中存储的就是指向
重量级锁互斥量的指针，后面等待锁的线程也要今日阻塞状态。
   上面描述的是轻量级锁的加锁过程，它的解锁过程也是通过CAS操作来进行的 compare and swap如果
对象的markword仍然执行着线程的锁积累，那就用cas操作吧对象当前的markword和
线程中复制的displaced mark word替换回来，如果替换成功，整个同步过程就完成了。如果
替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒呗挂起的线程。
  轻量级锁能提升程序同步性能的依据是对于绝大部分的锁，在整个同步周期内都是不
存在竞争的，这是一个经验数据。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥
量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了cas操作，因此在有
竞争的情况下，轻量级锁会比传统的重量级锁更慢。
 
13.3.5 偏向锁
   偏向锁也是jdk6中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步
原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去
消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作
都不做了。
   偏向锁的偏，就是偏心的偏，偏袒的偏，它的意思是这个锁会偏向于第一个
获得他的线程，如果在接下来的执行过程中，改所没有被其他线程获取，则持有偏向锁的
线程将永远不需要再进行同步。
   如果读者读懂了前面轻量级锁中关于对象头mark word与线程之间的操作过程
，那偏向锁的原理理解起来就会很简单。假设当前虚拟机启用了偏向锁 启用参数
-XX:++UseBiasedLocking,这是JDK6的默认值，那么，当锁对象第一次被线程获取的
时候，虚拟机将会吧对象头中的标志位设为01，即偏向模式。同时使用CAS操作吧获取
到这个锁的线程的ID记录在对象的markword之中如果cas操作成功，持有偏向锁
的线程以每次今日这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作 例如
locking unlocking 以及对mark word 的update等

   当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否处
于被锁定的状态，撤销偏向revoke bias后恢复到未锁定 标志位为01 或轻量级锁定
标志位为00 的状态，后续的同步操作就如上面介绍的轻量级锁那样执行。偏向锁
轻量级锁的状态转化以及对象markword的关系如图13-5所示
  偏向锁可以提高带有同步但无竞争的程序性能。它同样是一个带有效益权衡trade -off
性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中大部分的锁总是
被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用
参数-xx:-UseBiasedLocking来禁止偏向锁优化反而可以提升性能。
  13.4 本章小结
  本章介绍了线程安全所涉及的概念和分类、同步实现的方式以及虚拟机的底层运作原理，
并且介绍了虚拟机为了实现高效并发所采取的一系列锁优化措施。
   许多资深的程序员都说过，能够写出高伸缩性的并发程序是一门艺术，而了解并发在
系统底层是如何实现的，则是掌握这么艺术的前提条件，也是成长为高级程序员的必备知识
之一。






被阻塞的线程1
"http-nio-8080-exec-119" - Thread t@256
**java.lang.Thread.State: BLOCKED**
at java.util.zip.ZipFile$ZipFileInputStream.read(ZipFile.java:702)
**- waiting to lock <72d6b3ba> (a sun.net.www.protocol.jar.URLJarFile) owned by "http-nio-8080-exec-118" t@255**
at java.util.zip.ZipFile$ZipFileInputStream.read(ZipFile.java:732)
at java.io.FilterInputStream.read(FilterInputStream.java:83)
at java.io.DataInputStream.readUnsignedShort(DataInputStream.java:337)
at java.io.DataInputStream.readUTF(DataInputStream.java:589)
at java.io.DataInputStream.readUTF(DataInputStream.java:564)
at com.sun.xml.internal.bind.v2.bytecode.ClassTailor.tailor(ClassTailor.java:131)
at com.sun.xml.internal.bind.v2.runtime.reflect.opt.AccessorInjector.tailor(AccessorInjector.java:107)

  被阻塞的线程2
  "http-nio-8080-exec-190" - Thread t@327
  **java.lang.Thread.State: BLOCKED**
  at java.util.zip.ZipFile$ZipFileInputStream.close(ZipFile.java:764)
  **- waiting to lock <72d6b3ba> (a sun.net.www.protocol.jar.URLJarFile) owned by "http-nio-8080-exec-118" t@255**
  at java.util.zip.ZipFile$ZipFileInputStream.read(ZipFile.java:725)
  at java.io.FilterInputStream.read(FilterInputStream.java:133)
  at java.io.DataInputStream.read(DataInputStream.java:100)
  at com.sun.xml.internal.bind.v2.bytecode.ClassTailor.tailor(ClassTailor.java:176)
  at com.sun.xml.internal.bind.v2.runtime.reflect.opt.AccessorInjector.tailor(AccessorInjector.java:107)


**被72d6b3ba  http-nio-8080-exec-118线程阻塞**
waiting to lock <72d6b3ba> owned by "http-nio-8080-exec-118"

使用的线程

"http-nio-8080-exec-118" - Thread t@255
java.lang.Thread.State: RUNNABLE
at java.util.zip.ZipFile.read(Native Method)
at java.util.zip.ZipFile.access$1400(ZipFile.java:60)
at java.util.zip.ZipFile$ZipFileInputStream.read(ZipFile.java:717)
- locked <72d6b3ba> (a sun.net.www.protocol.jar.URLJarFile)
at java.util.zip.ZipFile$ZipFileInputStream.read(ZipFile.java:732)
at java.io.FilterInputStream.read(FilterInputStream.java:83)
at java.io.DataInputStream.readUnsignedShort(DataInputStream.java:338)
at java.io.DataInputStream.readUTF(DataInputStream.java:589)
at java.io.DataInputStream.readUTF(DataInputStream.java:564)
at com.sun.xml.internal.bind.v2.bytecode.ClassTailor.tailor(ClassTailor.java:131)
at com.sun.xml.internal.bind.v2.runtime.reflect.opt.AccessorInjector.tailor(AccessorInjector.java:107)
at com.sun.xml.internal.bind.v2.runtime.reflect.opt.AccessorInjector.prepare(AccessorInjector.java:68)





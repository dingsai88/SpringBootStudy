 34|worker thread模式:如何避免重复创建线程
 
 在上一篇文章中，我们介绍了一种最简单的分工模式--threadpermessage模式，对
应到现实世界，其实就是委托代办。这种分工模式如果用java thread实现，频繁地创建、销毁
线程非常影响性能，同时无限制地创建线程还可能导致OOM，所以在java领域使用场景
就受限制了。

要想有效避免线程的频繁创建、销毁以及OOM问题，就不得不提今天我们要细聊的，也是
java领域使用最多的worker thread模式。

 Worker thread模式以及其实现
 
 worker thread 模式可以类比显示世界里车间的工作模式：车间里的工人，有活儿了，大家
 一起干，没活了就聊聊天等着。你可以参考下面的示意图来理解，workerthread模式中
 workerthread对应到显示世界里，其实指的就是车间里的工人。不过这里需要注意的是，
 车间里的工人数量往往是确定的。
 
 那在编程领域该如何模拟车间的这种工作模式呢？或者说如何去实现workerthread模式呢
 ？通过上面的图，你很容易就能想到阻塞队列做任务池，然后创建固定数量的线程消费阻塞
 队列中的任务。其实你仔细想会发现，这个方案就是java语言提供的线程池。
 
 
 线程池有很多优点，例如能够避免重复创建、销毁线程，同时能够限制创建线程饿的上限等等。
 学习完上一篇文章后你已经知道，用java的thread实现threadpermessage模式难以应对
 高并发常军，原因就在于频繁创建销毁java线程的成本有点高，而且无限制地创建线程
 还可能导致应用OOM。线程池，则恰好能解决这些问题。
 
 
 那我们还是以echo程序为例，看看如何用线程池来实现。
 
 下面的实例代码是用线程池实现的echo服务端，相比于threadpermessage模式的实现，
 改动非常少，仅仅是创建了一个最多线程数为500的线程池es，然后通过es。execute
 方法将请求处理的任务提交给线程池处理。
 
 正确地创建线程池
 
 java的线程池既能够避免无限制地创建线程导致OOM ，也能避免无限制地接收任务导致
 OOM。只不过后者经常容易被我们忽略，例如在上面的实现中，就被我们忽略了。所以强烈
 建议你用创建有界的队列来接受任务。
 
 当请求量大于有界队列的容量时，就需要合理地拒绝请求。如何合理地拒绝呢？这需要你结合
 具体的业务场景来制定，即便线程池默认的拒接策略能够满足你的需求，也同样建议你在创建
 线程池时，清晰地志明拒绝策略。
 
 同时，为了便于调试和诊断问题，我也强烈建议你在实际工作中给线程赋予一个业务相关的名字
 。
 综合以上三点建议，echo程序中创建线程可以使用下面实例代码。
 
 
 避免线程死锁
 
 使用线程池过程中，还要注意一种线程死锁的场景。如果提交到相同线程池的任务不是互相独立
 的，而是有依赖关系的，那么就有可能导致线程死锁。实际工作中，我就亲历过这种线程死锁
 的场景。具体现象是应用每运行一段时间偶尔就会处于无响应的状态，监控数据看上去一切
 都正常，但是实际上已经不能正常工作了。
 
 这个出问题的应用，相关的逻辑精简之后，如下图所示，该应用将一个大型的计算任务分成两个
阶段，第一个阶段的任务会等待第二阶段的子任务完成。在这个应用里，每一个阶段都使用
了线程池，而且两个阶段使用的还是同一个线程池。

 我们可以用下面的示例代码来模拟该应用，如果你执行下面的这段代码，会发现它永远执行不到
 最后一行。执行过程中没有任何异常，但事应用已经停止响应了
 
 当应用出现类似问题时，首选的诊断方法是查看线程栈。下图是上面实例代码停止响应后的
 线程栈，你会发现线程池中的两个线程全部都阻塞在l2.awati这行代码上，也及时说
 线程池里所有的线程都在等待L2阶段的任务执行完，那L2阶段的子任务什么时候能够执行完呢
 永远都没有那一天，为什么因为线程池里的线程都阻塞了，没有空闲的线程执行L2阶段的任务了。
 
 原因找到了，那如何解决就简单了，最简单粗暴的办法就是将线程池的最大线程数调大，如果
 能够确定任务的数量不是非常多的话，这个办法也是可行的，否则这个办法就行不通了。其实
 这种问题通用的解决方案是为不同的任务创建不同的线程池。对于上面的这个应用，L2阶段
 的任务和L2阶段的任务如果各自都有自己的线程池，就不会出现这种问题了。
 
 
 最后再次强调一下：提交到相同线程池中的任务一定是互相独立的，否则就一定要慎重。
 
 总结
 
 我们曾经说过，解决并发变成里的分工问题，最好的办法是和显示世界做对比。对比现实世界
 构建变成领域的模型，能够让模型更容易理解。上一篇我们介绍的thread per message模式
 ，类似于现实世界里的委托他人办理，而今天介绍的workerthread模式则类似于车间里
 人工的工作模式。如果你在设计阶段，发现对业务模型建模之后，模型非常类似于车间里的工作
 模式，那基本上就能确定可以在实现阶段采用worker thread模式来实现。
 
 worker thread模式和thread permessage模式的区别有哪些呢？从现实世界的角度看
 你委托代办人做事，往往是和代办人直接沟通的；对应到变成领域，其实现也是住线程直接创建
 了一个子线程，主子线程之间是可以通信的；对应到编程领域，其实现也是主线程直接创建
 了一个子线程，主子线程之间是可以直接通信的。而车间工人的工作方式则是完全围绕任务
 展开的，一个具体的任务被那个工人执行，预先是无法知道的；对应到编程领域，则是主线程
 任务提交到线程池，但主线程并不关心任务被那个线程执行。
 
 worker thread模式能避免线程频繁创建、销毁的问题，而且能够限制线程的最大数量。
 java语言里可以直接使用线程池来实现worker thread模式，线程池是一个非常基础和优秀
 的工具类，甚至有些大肠的编码规范都不允许用 new Thread来创建线程的，必须使用线程池。
 
不过使用线程池还是需要格外谨慎的，除了今天重点降到的如何正确创建线程池，如果避免线程斯诺问题
，还需要注意前面我们曾经提到的threadlocal内存泄漏问题。同事对于提交到线程池
的任务，还要做好异常处理，避免异常的任务从眼前溜走，从业务角度看，有时没有
发现异常的任务后果往往都很严重。


35|两阶段终止模式：如何优雅地终止线程？
前面两篇文章我们讲述的内容，从纯技术的角度看，都是启动多线程去执行一个异步任务。既
启动，那又该如何终止呢？今天咱们就从技术的角度聊聊如何优雅地终止线程，正所谓有始有终
。

在09 java线程：java线程的生命周期中，我们曾讲过：线程执行完或出现异常
就会进入终止状态。这样看，终止一个线程看上去很简单啊！一个线程执行完自己的任务，
自己进入终止状态，这的确很简单。不过我今天谈到的优雅地终止线程，不是自己终止
自己，而是在一个线程T1中终止线程T2；这里所谓的优雅，指的是给T2一个机会料理后事，
而不是被一剑封口。

java语言的thread类中曾经提供了一个stop方法，用来终止线程，可是早已不建议使用了
。原因是这个方法用的就是一剑封口的做法，被终止的的线程没有机会料理后事。 

既然不建议使用stop方法，那在java领域，我们又该如何优雅地终止线程呢

如何理解两个阶段终止模式
前辈们经过认真对比分析，已经总结出了一套成熟的方案，叫做两阶段终止模式。顾名思义
就是将终止过程分成两个阶段，其中第一个阶段主要是线程T1向线程T2发送终止指令，而第二阶段
则是线程T2响应终止指令。

 interrupte
 
那在java语言里，终止指令是什么呢，这个要从java线程状态转换过程说起。我们在
中曾经提到过java线程状态转换图，如下图所示。
 
从这个图里你会发现，java线程进入终止的前提是线程进入runnable装填，而实际上
线程也可能处在休眠状态，也就是说，我们想终止一个线程，首先要把线程的状态从休眠状态
转换到runnable状态。

线程转换到runnable状态之后，我们如何再将其终止呢？runnable状态转换到终止状态
，优雅的方式是让java咸亨自己执行完run方法，所以一般我采用的方法是设置一个
标志位，然后线程会在何时的时机检测这个标志位，如果发现符合终止条件，则自动退出
run方法。这个过程其实就是我们前面提到的第二阶段：响应终止指令。

综合上面这两点，我们能总结出终止指令，其实包括方面内容：inerrupt方法和线程终止
的标志位。


理解了两阶段终止模式之后，下面我们看一个实际工作中的案例。

用两阶段终止模式终止监控操作

实际工作中，有些监控系统需要动态地采集一些数据，一般都是监控系统发送采集指令给被监控
系统的监控搭理，监控代理接收到指令之后，从监控目标收集数据，然后回传给监控系统，
详细过程如下图所示。处于都ixingn的考虑，有些监控项对系统性能影响很大，所以不能一直持续
监控，动态采集功能一般都会有终止操作。


下面的示例代码是监控代理简化之后的实现，start方法会启动一个新的线程rptthread来
执行监控数据采集和回传功能，stop方法需要优雅地终止线程rptthread那stop相关
功能该如何实现呢？

按照两阶段终止模式，我寿险需要做的就是线程rptThread状态转换到runnable，做法
很简单，只需要在调用rptThread.interrupt就可以了。线程rptThread的状态转换
到runnable之后，如何优雅地终止呢？下面的实例代码中，我们选择的标志位是线程的中断
状态:Thread.currentThread.isInterrupted，需要注意的是，我们在捕获
thread。sleep的中断异常之后，通过thread。currentThread。interrrupte重新设置
了线程的中断状态，因为JVM的异常处理会清除线程的中断状态。

上面的实例代码的确能够解决当前的问题，但是建议你在实际工作中谨慎使用。原因在于我们
很可能在线程的run方法中调用第三方类库提供的方法，而我们没有办法保证第三方类库正确
处理了线程的中断异常，例如第三方类库在捕获到threadsleep方法抛出的中断异常后，
没有重新设置线程的中断状态，那么就会导致线程不能够正常终止。所以强烈建议你设置自己
的线程终止标志位，例如在下面的代码中，使用isTerminated座位线程终止标志位，此时
无论是否正确处理线程的中断异常，都不会影响线程的优化地终止。

如何优雅地终止线程池
java领域用的最多的还是线程池，而不是手动地创建线程。那我们该如何优雅地终止线程池呢

线程池提供了两个方法：shutdown和shutdownNow。这两个方法有什么区别呢？要了解
他们的区别，就先需要了解线程池的实现原理。

我们曾经讲过，java线程池是生产者消费者模式的一种实现，提交给线程池的任务，寿险是
进入一个阻塞队列中，之后线程池中的线程从阻塞队列中取出任务执行。

shutdown方法是一宗很保守的关闭线程池的方法。线程池执行shutdown后，就会拒绝
接收新的任务，但是会等待线程池中正在执行的任务和已经进入阻塞队列的任务都执行完之后
才最终关闭线程池。

而shutdownNow方法，相对就激进一些了，线程池执行shutdownNow后，会拒绝
接收新的任务，同时还会中断线程池中正在执行的任务，已经进入阻塞队列的任务也被剥夺了执行
的机会，不过这些剥夺执行机会的任务会座位shutdownnow方法的返回值返回。因为
shutdownnow方法会中断正在执行的线程，所以提交到线程池的任务，如果需要优雅地
结束，就需要正确地处理线程中断。

如果提交到线程池的任务不允许取消，那就不能使用shutdownnow方法终止线程池，不过
㘝提交到线程池的任务允许后续补偿的方法重新执行，也是可以使用
shutdownnow方法终止线程池的。java并发变成实战这本书第七章取消与关闭
的shutdownnow的局限性一节中，提到一种将已提交但尚未开始执行的任务以及已经
取消的正在执行的任务报错起来，以便后续重新执行的方案，你可以参考一下，方法很简单
，这里就不详细介绍了。

其实分析完shutdown和shotdownnow方法你会发现，他们实质上使用的也是两阶段终止模式
，只是终止指令的范围不同而已，前者只影响阻塞队列接受任务，后者范围扩大到线程池
中所有的任务。

总结
两阶段终止模式是一种应用很广泛的并发设计模式，在java语言中使用两阶段终止模式来优雅地
终止线程内，需要注意两个关键点：一个是仅检查终止标志位是不够的，因为线程的状态可能
处于休眠态；另一个仅检查线程的中断状态也是不够的，因为我们依赖的第三方类库很可能
没有正确处理中断异常。

当你使用java的线程池来管理线程的时候，需要依赖线程池提供的shutdown和
shutdownnoe方法来终止线程池。只不过在使用需要注意他们的应用常军，尤其是在使用
shutdownnoew的时候一定要谨慎。


课后思考，本文的示例代码中，线程终止标志位siterminatef被声明为volatile，你觉得是否有必要呢





https://www.cnblogs.com/aigeileshei/articles/9984420.html




36|生产者-消费者模式：用流水线思想提高效率
前面我们在34worker thread模式：如何避免重复创建线程中讲到，worker thread模式
类比的是工厂里车间工人的工作模式。但其实在现实世界，工厂里还有一种流水线
的工作模式，类比到变成领域，就是生产者-消费者模式。

生产者-消费者模式在变长领域的应用也非常广泛，签名我们曾经提到，java线程池本质上就是
用生产者-消费者模式实现的，所以每当使用线程池的是，其实就是izai应用生产者-消费者模式

当然除了在线程池中的应用，为了提升性能，并发变长领域很多地方也都用到了生产者-消费者
模式，例如咯gj2中异步Appedner内部也用到了生产者-消费者模式。所以今天我们
就来深入地聊聊生产者-消费者模式，看看他具体有哪些优点，以及如何提升系统的性能。

生产者-消费者模式的优点
生产者-消费者模式里核心是一个任务队列，生产者线程生产任务，并将任务天骄到任务队列
中，而消费者线程从任务队列中获取任务并执行。下面是生产者-消费者模式的一个示意图，
你可以结合它来理解。

从架构设计的角度来看，生产者-消费者模式有一个很重要的优点，就是解耦。解耦对于大型
系统的设计非常重要，而解耦的一个关键就是组件之间的依赖关系和通细腻方式必须受限。在生产者
消费者模式中，生产者和消费者没有任何依赖关系，他们彼此之间的通信只能通过任务队列，
所以生产者-消费者模式是一个不错的解耦方案。

除了架构设计上的优点之外，生产者-消费者模式还有一个重点的优点就是支持异步，并且neng
够平衡生产者和消费者的速度差异。在正常-消费者模式中，生产者线程只需要将任务添加
到任务队列而无需等待任务被消费者线程执行完，也就是说任务的生产和消费是异步的，这是与
传统的方法之间调用的本质区别，传统的方法之间调用是同步的。

你或许会有这样的疑问，异步化处理最简单的方式就是创建一个新的线程去处理，那中间增加
一个任务队列究竟有什么用呢？我觉得主要还是用于平衡生产者和消费者的速度差异。我们
假设生产者的速率很慢，而消费的速率很高，比如是1：3，如果生产者有3个线程，采用
创建新的线程的方式，那么会创建三个子线程，而采用生产者消费者模式，消费线程只需要
一个就够了。java语言里，java线程和操作系统线程是一一对应的，创建线程太多，
会增加上下文切换的成本，所以java线程不是越多越好，适量即可。而生产者-消费者模式恰好
能支持你用适量的线程。

支持批量执行以提高性能

前面我们在threadpermessage模式最简单使用的分工方法中讲过轻量级的
线程，如果使用轻量级线程，就没有必要平衡生产者和消费者的速度差异了，因为清零及线程
本身就是廉价的，那是否意味着生产者-消费者模式在性能优化方面就无用武之地了呢？当然不是
有一类并发常军应用生产者-消费者模式就有奇效，那就是批量执行任务。

例如，我们要在数据库里insert1000条数据，有两种方法：第一种方案是用1000个线程
并发执行，每个线程insert一条数据；第二种方案是用1个线程，执行一个批量的SQL，
一次性吧1000条数据数据insert进去。这两种方案，先让是第二种方案效率更高，其实这样的
应用场景就是我们上面提到的批量执行场景。

在35两阶段终止模式：如何优雅地终止线程文章中，我们提到一个监控系统动态采集
的案例，其实最终回传的监控数据还是要存入数据库的。但被监控系统往往有很多
，如果每一条回传数据都直接insert到数据库，那么这个方案就是上面提到的第一种方案：
每个线程insert一条数据。很现场，更好的方案是批量执行SQL，那如何实现呢这就要
用到生产者-消费者模式了。

立勇生产者-消费者模式实现批量执行SQL非常简单：将原来直接insert数据到数据库的
线程座位生产者线程，生产者线程只需将数据添加到任务队列，然后消费者线程负责将任务从
任务队列中批量取出并批量执行。

在下面的实例代码中，我们创建了5个消费者负责批量执行SQL，这5个消费者线程以
whileture循环方式批量地获取任务并批量地执行。需要注意的是，从任务队列中获取
批量任务的方案polltasks中，首先是以阻塞方式获取任务中的一条任务，而后则是以
非阻塞的方式获取任务；之所以首先采用阻塞方式，是因为如果任务队列中没有任务，这样的
方式能够避免无谓的循环。


支持分阶段提交以提升性能
立勇生产者-消费者模式还可以轻松地支持一宗分阶段提交的应用场景。我们知道些文件如果
同步刷盘性能会很慢，所以对于不是很重要的数据，我们往往采取异步刷盘的方式。我曾经参与
过一个项目，其中的日志组价你是自己实现的，采用的就是异步刷盘方式，刷盘的时机是：

1.error级别的日志需要立即刷盘；
2.数据累积到500条需要立即刷盘；
3.存在为刷盘数据，且5秒钟内未曾刷盘，需要立即刷盘。


这个日志组件的异步刷盘操作本质上其实就是一种分阶段提交。下面我们具体看看用生产者-
消费者模式如何实现。在下面的实例代码中，可以通过调用info和error方法写入日志，
这两个方法都是创建了一个日志任务logmsg，并添加到阻塞队列中，调动info和
error方法的线程是生产；而真正将日志写入文件的消费者线程，在logger这个类中
，我们只创建1个消费者线程，在这个消费者线程中，会根据刷盘规则进行刷盘曹组，逻辑
很简单，这里就不赘述了。

总结
java语言提供的线程池本身就是一种生产者-消费者模式的实现，但是线程池中的线程每次只能
从任务队列中消费一个任务来执行，对于大部分并发场景这种策略没有问题，但是有些场景
还是需要自己来实现，例如需要批量执行以及分阶段提交的场景。

生产者-消费者模式在分布式计算中的应用也非常广泛。在分布式场景下，你可以 借助分布式
消息队列MQ来实现生产者消费者模式。mq一般都会支持两种消息模型，一种是点对点模型，
一宗是发布订阅模型。这两种模型的区别在于，点对点模型里一个消息只会被一个消费者消费，
和java的线程池非常类似，java线程池的任务也只会被一个线程执行；而发布
订阅模型里一个消息被多个消费者消费，本质上是一种消息的广播，在多线程编程领域，你
可以结合观察者模式实现广播功能。


https://www.cnblogs.com/aigeileshei/articles/9984420.html


37|设计模式模块热点问题答疑
多线程设计模式是前人解决并发问题的经验总结，当我们试图解决一个并发问题时，首选方案
往往是使用匹配的设计模式，这样能避免走弯路。同时，由于大家都熟悉设计模式，所以使用
设计模式还能提升方案和代码的可理解性。

在这个模块，我们总共介绍了9种常见的多线程设计模式。下面我们就对这9种设计模式做
个分类和总结，同时也对前面各章的课后思考题做个答疑。

避免共享的设计模式

Immutability模式 copy on write模式和线程本地存储模式本质上都是为了避免共享，
只是实现手段不同而已。这三种设计模式的实现都很简单，但是实现过程中有些细节还是需要
格外注意的。例如，使用immutability模式需要注意对象属性的不可变性，使用copyone
write模式需要注意性能问题，使用线程本地存储模式需要注意异步执行问题。所以，每篇文章
最后我设置的课后思考题的目的就是提醒你注意这些细节。

28|immutablility模式：如何利用不变性解决并发问题的课后思考题是讨论
account这个类是不是具备不可变性。这个类初看上去属于不可变对象的中规中矩实现，而实质
上这个实现是有问题的，原因在于stringbuffer不同于string stringbuffer不具备
不可变性，通过getuser方法获取user之后，是可以修改user的。一个简单的解决方案是让
getUser方法返回string对象。

29|copy on write模式不是延时策略的COW的课后思考题是讨论javasdk中为什么
没有提供copyOnwriteLinedList这是一个开放性的问题，没有标准答案，但是性能
问题一定是其中一个重要的原因，毕竟完整地复制linkedlist性能开销太大了。

30|线程本地存储模式：没有共享，就没有伤害的课后思考题是在异步场景中，是否可以
使用spring的事务管理器。答案先让是不能的，spring使用threadlocal来传递事务信息
，因此这个事务信息是不能跨线程共享的。实际工作中有很多类库都是用Threadlocal传递
上下文信息的，这种常军下如果有异步操作，一定要注意上下文信息是不能跨越线程共享的。

多线程版本IF的设计模式

guarded suspension模式和balking模式可以简单地理解为多线程版本的if，但它们
的区别在于前者会等待if条件变为真，而后者则不需要等待。

Guarded Suspension模式的经典实现是使用管程，很多初学者会简单地用线程sleep的方式
实现，比如guarded suspension模式：等待唤醒机制的规范实现的思考题就是用
线程sleep方式实现的。但不推荐你使用这种方式，最重要的原因是性能，如果sleep的时间
太长，会影响响应时间，sleep的时间太短，会导致线程频繁地被唤醒，消耗系统资源。

同时，实例代码的实现也有问题：由于obj不是volatile变量，所以即便obj被设置了正确的
值，执行while的线程也有肯呢个看不到，从而导致更长的时间的sleep

实现balking模式最容易忽视的就是竞态条件问题。比如，balking模式再谈线程
安全的单例模式的思考题就存在竞态条件问题。因此，在多线程场景中使用if语句时，一定
要多问自己一遍：是否存在竞态条件。

三种最简单的分工模式

thread per message模式，worker thread模式和生产者-消费者模式是三种最简单使用
的多线程分工方法。虽说简单，但也还是有许多细节需要你多家小心和注意。

Thread per message 模式在实现的时候需要注意是否存在线程的频繁床架牛晓辉以及是否可能
导致OOM。在33threadpermessage模式最简答使用的分工方法文章中，最后
的思考题就是关于如何快速解决OOM问题的。在高并发场景中，最简单的办法其实是限流
当然，限流方案也并不局限于解决threadpermessage模式中的OOM问题。


Worker thread模式的实现，需要注意潜在的线程死锁问题。worker thread模式
如何避免重复创建线程？思考题中的实例代码就存在线程死锁。有名叫vector的同学
关于这道题的浏览，我觉得描述的很贴切和形象：工厂里只有一个工人，他的工作就是
同步地等待工厂里其他人给他提供东西，然而并没有其他人，他将等到天荒地老，海枯石烂
因此，共享线程池虽然能够提供线程池的使用效率，但一定要保证一个前天，那就是
任务之间没有依赖关系。

Java线程池本身就是一种生产者-消费者模式的实现，所以大部分常军你都不需要自己实现，
直接使用java的线程池就可以了。但若能自己灵活地实现生产者-消费者模式会更好，比如
可以实现批量执行和分阶段提交，不过这个过程中还需要注意如何优雅地终止线程，生产者-消费者
模式：用流水线思想提高效率的思考题就是关于此的。


如何优雅地终止线程？我们在两阶段终止模式：如何优雅地终止线程有过详细介绍
，两阶段终止模式是一种通用的解决方案。但其实终止生产者-消费者服务还有一种更简单
的方案，叫做毒丸对象。 java并发编程实战第7章的7.2.3节对毒丸对象有
过详细的介绍。简单来讲，毒丸对象是生产者生产的一条特殊任务，然后当消费者线程读到
毒丸对象时，会立即终止自身的执行。

下面是用毒丸对象终止写日志线程的具体实现，整体的实现过程还是很简单的：类
logger中声明一个毒丸对象posionPill,当消费者线程从阻塞队列bq中取出一条
logMsg后，先判断是否是毒丸对象，如果是，则breakwhile循环，从而终止自己的执行。


总结：




































 
 
 
 34|worker thread模式:如何避免重复创建线程
 
 在上一篇文章中，我们介绍了一种最简单的分工模式--threadpermessage模式，对
应到现实世界，其实就是委托代办。这种分工模式如果用java thread实现，频繁地创建、销毁
线程非常影响性能，同时无限制地创建线程还可能导致OOM，所以在java领域使用场景
就受限制了。

要想有效避免线程的频繁创建、销毁以及OOM问题，就不得不提今天我们要细聊的，也是
java领域使用最多的worker thread模式。

 Worker thread模式以及其实现
 
 worker thread 模式可以类比显示世界里车间的工作模式：车间里的工人，有活儿了，大家
 一起干，没活了就聊聊天等着。你可以参考下面的示意图来理解，workerthread模式中
 workerthread对应到显示世界里，其实指的就是车间里的工人。不过这里需要注意的是，
 车间里的工人数量往往是确定的。
 
 那在编程领域该如何模拟车间的这种工作模式呢？或者说如何去实现workerthread模式呢
 ？通过上面的图，你很容易就能想到阻塞队列做任务池，然后创建固定数量的线程消费阻塞
 队列中的任务。其实你仔细想会发现，这个方案就是java语言提供的线程池。
 
 
 线程池有很多优点，例如能够避免重复创建、销毁线程，同时能够限制创建线程饿的上限等等。
 学习完上一篇文章后你已经知道，用java的thread实现threadpermessage模式难以应对
 高并发常军，原因就在于频繁创建销毁java线程的成本有点高，而且无限制地创建线程
 还可能导致应用OOM。线程池，则恰好能解决这些问题。
 
 
 那我们还是以echo程序为例，看看如何用线程池来实现。
 
 下面的实例代码是用线程池实现的echo服务端，相比于threadpermessage模式的实现，
 改动非常少，仅仅是创建了一个最多线程数为500的线程池es，然后通过es。execute
 方法将请求处理的任务提交给线程池处理。
 
 正确地创建线程池
 
 java的线程池既能够避免无限制地创建线程导致OOM ，也能避免无限制地接收任务导致
 OOM。只不过后者经常容易被我们忽略，例如在上面的实现中，就被我们忽略了。所以强烈
 建议你用创建有界的队列来接受任务。
 
 当请求量大于有界队列的容量时，就需要合理地拒绝请求。如何合理地拒绝呢？这需要你结合
 具体的业务场景来制定，即便线程池默认的拒接策略能够满足你的需求，也同样建议你在创建
 线程池时，清晰地志明拒绝策略。
 
 同时，为了便于调试和诊断问题，我也强烈建议你在实际工作中给线程赋予一个业务相关的名字
 。
 综合以上三点建议，echo程序中创建线程可以使用下面实例代码。
 
 
 避免线程死锁
 
 使用线程池过程中，还要注意一种线程死锁的场景。如果提交到相同线程池的任务不是互相独立
 的，而是有依赖关系的，那么就有可能导致线程死锁。实际工作中，我就亲历过这种线程死锁
 的场景。具体现象是应用每运行一段时间偶尔就会处于无响应的状态，监控数据看上去一切
 都正常，但是实际上已经不能正常工作了。
 
 这个出问题的应用，相关的逻辑精简之后，如下图所示，该应用将一个大型的计算任务分成两个
阶段，第一个阶段的任务会等待第二阶段的子任务完成。在这个应用里，每一个阶段都使用
了线程池，而且两个阶段使用的还是同一个线程池。

 我们可以用下面的示例代码来模拟该应用，如果你执行下面的这段代码，会发现它永远执行不到
 最后一行。执行过程中没有任何异常，但事应用已经停止响应了
 
 当应用出现类似问题时，首选的诊断方法是查看线程栈。下图是上面实例代码停止响应后的
 线程栈，你会发现线程池中的两个线程全部都阻塞在l2.awati这行代码上，也及时说
 线程池里所有的线程都在等待L2阶段的任务执行完，那L2阶段的子任务什么时候能够执行完呢
 永远都没有那一天，为什么因为线程池里的线程都阻塞了，没有空闲的线程执行L2阶段的任务了。
 
 原因找到了，那如何解决就简单了，最简单粗暴的办法就是将线程池的最大线程数调大，如果
 能够确定任务的数量不是非常多的话，这个办法也是可行的，否则这个办法就行不通了。其实
 这种问题通用的解决方案是为不同的任务创建不同的线程池。对于上面的这个应用，L2阶段
 的任务和L2阶段的任务如果各自都有自己的线程池，就不会出现这种问题了。
 
 
 最后再次强调一下：提交到相同线程池中的任务一定是互相独立的，否则就一定要慎重。
 
 总结
 
 我们曾经说过，解决并发变成里的分工问题，最好的办法是和显示世界做对比。对比现实世界
 构建变成领域的模型，能够让模型更容易理解。上一篇我们介绍的thread per message模式
 ，类似于现实世界里的委托他人办理，而今天介绍的workerthread模式则类似于车间里
 人工的工作模式。如果你在设计阶段，发现对业务模型建模之后，模型非常类似于车间里的工作
 模式，那基本上就能确定可以在实现阶段采用worker thread模式来实现。
 
 worker thread模式和thread permessage模式的区别有哪些呢？从现实世界的角度看
 你委托代办人做事，往往是和代办人直接沟通的；对应到变成领域，其实现也是住线程直接创建
 了一个子线程，主子线程之间是可以通信的；对应到编程领域，其实现也是主线程直接创建
 了一个子线程，主子线程之间是可以直接通信的。而车间工人的工作方式则是完全围绕任务
 展开的，一个具体的任务被那个工人执行，预先是无法知道的；对应到编程领域，则是主线程
 任务提交到线程池，但主线程并不关心任务被那个线程执行。
 
 worker thread模式能避免线程频繁创建、销毁的问题，而且能够限制线程的最大数量。
 java语言里可以直接使用线程池来实现worker thread模式，线程池是一个非常基础和优秀
 的工具类，甚至有些大肠的编码规范都不允许用 new Thread来创建线程的，必须使用线程池。
 
不过使用线程池还是需要格外谨慎的，除了今天重点降到的如何正确创建线程池，如果避免线程斯诺问题
，还需要注意前面我们曾经提到的threadlocal内存泄漏问题。同事对于提交到线程池
的任务，还要做好异常处理，避免异常的任务从眼前溜走，从业务角度看，有时没有
发现异常的任务后果往往都很严重。


35|两阶段终止模式：如何优雅地终止线程？
前面两篇文章我们讲述的内容，从纯技术的角度看，都是启动多线程去执行一个异步任务。既
启动，那又该如何终止呢？今天咱们就从技术的角度聊聊如何优雅地终止线程，正所谓有始有终
。

在09 java线程：java线程的生命周期中，我们曾讲过：线程执行完或出现异常
就会进入终止状态。这样看，终止一个线程看上去很简单啊！一个线程执行完自己的任务，
自己进入终止状态，这的确很简单。不过我今天谈到的优雅地终止线程，不是自己终止
自己，而是在一个线程T1中终止线程T2；这里所谓的优雅，指的是给T2一个机会料理后事，
而不是被一剑封口。

java语言的thread类中曾经提供了一个stop方法，用来终止线程，可是早已不建议使用了
。原因是这个方法用的就是一剑封口的做法，被终止的的线程没有机会料理后事。 

既然不建议使用stop方法，那在java领域，我们又该如何优雅地终止线程呢

如何理解两个阶段终止模式
前辈们经过认真对比分析，已经总结出了一套成熟的方案，叫做两阶段终止模式。顾名思义
就是将终止过程分成两个阶段，其中第一个阶段主要是线程T1向线程T2发送终止指令，而第二阶段
则是线程T2响应终止指令。

 interrupte
 
那在java语言里，终止指令是什么呢，这个要从java线程状态转换过程说起。我们在
中曾经提到过java线程状态转换图，如下图所示。
 
从这个图里你会发现，java线程进入终止的前提是线程进入runnable装填，而实际上
线程也可能处在休眠状态，也就是说，我们想终止一个线程，首先要把线程的状态从休眠状态
转换到runnable状态。

线程转换到runnable状态之后，我们如何再将其终止呢？runnable状态转换到终止状态
，优雅的方式是让java咸亨自己执行完run方法，所以一般我采用的方法是设置一个
标志位，然后线程会在何时的时机检测这个标志位，如果发现符合终止条件，则自动退出
run方法。这个过程其实就是我们前面提到的第二阶段：响应终止指令。

综合上面这两点，我们能总结出终止指令，其实包括方面内容：inerrupt方法和线程终止
的标志位。


理解了两阶段终止模式之后，下面我们看一个实际工作中的案例。

用两阶段终止模式终止监控操作

实际工作中，有些监控系统需要动态地采集一些数据，一般都是监控系统发送采集指令给被监控
系统的监控搭理，监控代理接收到指令之后，从监控目标收集数据，然后回传给监控系统，
详细过程如下图所示。处于都ixingn的考虑，有些监控项对系统性能影响很大，所以不能一直持续
监控，动态采集功能一般都会有终止操作。


下面的示例代码是监控代理简化之后的实现，start方法会启动一个新的线程rptthread来
执行监控数据采集和回传功能，stop方法需要优雅地终止线程rptthread那stop相关
功能该如何实现呢？

按照两阶段终止模式，我寿险需要做的就是线程rptThread状态转换到runnable，做法
很简单，只需要在调用rptThread.interrupt就可以了。线程rptThread的状态转换
到runnable之后，如何优雅地终止呢？下面的实例代码中，我们选择的标志位是线程的中断
状态:Thread.currentThread.isInterrupted，需要注意的是，我们在捕获
thread。sleep的中断异常之后，通过thread。currentThread。interrrupte重新设置
了线程的中断状态，因为JVM的异常处理会清除线程的中断状态。

上面的实例代码的确能够解决当前的问题，但是建议你在实际工作中谨慎使用。原因在于我们
很可能在线程的run方法中调用第三方类库提供的方法，而我们没有办法保证第三方类库正确
处理了线程的中断异常，例如第三方类库在捕获到threadsleep方法抛出的中断异常后，
没有重新设置线程的中断状态，那么就会导致线程不能够正常终止。所以强烈建议你设置自己
的线程终止标志位，例如在下面的代码中，使用isTerminated座位线程终止标志位，此时
无论是否正确处理线程的中断异常，都不会影响线程的优化地终止。

如何优雅地终止线程池
java领域用的最多的还是线程池，而不是手动地创建线程。那我们该如何优雅地终止线程池呢

线程池提供了两个方法：shutdown和shutdownNow。这两个方法有什么区别呢？要了解
他们的区别，就先需要了解线程池的实现原理。

我们曾经讲过，java线程池是生产者消费者模式的一种实现，提交给线程池的任务，寿险是
进入一个阻塞队列中，之后线程池中的线程从阻塞队列中取出任务执行。

shutdown方法是一宗很保守的关闭线程池的方法。线程池执行shutdown后，就会拒绝
接收新的任务，但是会等待线程池中正在执行的任务和已经进入阻塞队列的任务都执行完之后
才最终关闭线程池。

而shutdownNow方法，相对就激进一些了，线程池执行shutdownNow后，会拒绝
接收新的任务，同时还会中断线程池中正在执行的任务，已经进入阻塞队列的任务也被剥夺了执行
的机会，不过这些剥夺执行机会的任务会座位shutdownnow方法的返回值返回。因为
shutdownnow方法会中断正在执行的线程，所以提交到线程池的任务，如果需要优雅地
结束，就需要正确地处理线程中断。

如果提交到线程池的任务不允许取消，那就不能使用shutdownnow方法终止线程池，不过
㘝提交到线程池的任务允许后续补偿的方法重新执行，也是可以使用
shutdownnow方法终止线程池的。java并发变成实战这本书第七章取消与关闭
的shutdownnow的局限性一节中，提到一种将已提交但尚未开始执行的任务以及已经
取消的正在执行的任务报错起来，以便后续重新执行的方案，你可以参考一下，方法很简单
，这里就不详细介绍了。

其实分析完shutdown和shotdownnow方法你会发现，他们实质上使用的也是两阶段终止模式
，只是终止指令的范围不同而已，前者只影响阻塞队列接受任务，后者范围扩大到线程池
中所有的任务。

总结
两阶段终止模式是一种应用很广泛的并发设计模式，在java语言中使用两阶段终止模式来优雅地
终止线程内，需要注意两个关键点：一个是仅检查终止标志位是不够的，因为线程的状态可能
处于休眠态；另一个仅检查线程的中断状态也是不够的，因为我们依赖的第三方类库很可能
没有正确处理中断异常。

当你使用java的线程池来管理线程的时候，需要依赖线程池提供的shutdown和
shutdownnoe方法来终止线程池。只不过在使用需要注意他们的应用常军，尤其是在使用
shutdownnoew的时候一定要谨慎。


课后思考，本文的示例代码中，线程终止标志位siterminatef被声明为volatile，你觉得是否有必要呢

36|


















 
 
 
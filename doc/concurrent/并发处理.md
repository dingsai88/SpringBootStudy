操作系统原理:



I.第一讲 原子性、可见性、有序性：并发bug的源头


只要我们能够深刻理解可见性、原子性、有序性在并发场景下的原理，很多并发问题是可以理解的
缓存导致的可见性、线程切换带来的原子性、编译优化带来的有序性。


I.第二讲 JMM：看java如何解决可见性和有序性


volatile、synchronized、final+六项happens-before规则
 



synchronized 
修饰静态方法时，锁定当前类的class对象

非静态方法，锁定当前实例对象this



15 Lock和Condition下:dubbo如何用管程实现异步转同步
我们讲到了javaSDK并发包里的lock有别与synchronized隐士锁的三个特性
：能够响应中断、支持超时和非阻塞地获取锁。那今天我们接着再来详细聊聊javasdk并发
包里condition，condition实现了管程模型里面的条件变量。

在管程里我们提到过java语言内置的管程里只有一个条件变量
，而lockcondition实现的管程是支持多个条件变量的。这是二者的一个重要区别

在很多并发场景下，支持多个条件变量能够让我们的并发程序可读性更好，实现起来也更容易。
例如，实现一个阻塞对垒，就需要两个条件变量。

那如何利用两个条件变量快速实现阻塞队列呢

一个阻塞队列，需要两个条件变量，一个队列不空，另一个是队列不满
这个例子我们前面在介绍管程的时候详细说过，这里就不赘述。相关
的代码，我这里重新列出来，你可以温故知新一下。

不过，这里你需要注意，lock和condition实现的管程，线程等待和通知需要调用 await()
signal、signalAll,他们的寓意和waitnotify notifyall相同。但是不一样的是
lock 和condition实现的管程里只能使用前面的await signal signalall而后面的
wait notify notify all只有在synchronized实现管程里才能使用。如果一步小心在
lock condition实现的管程里调用了wait notify notifyall那程序可就彻底玩完了。

javasdk并发包里lock和condition不过就是管程的一种实现而已。管程你已经很熟悉了
那lock和condition的使用自然是小菜一碟。下面我们就来看看在指明项目dubbo中
lock和condition是怎么用的。不过在开始介绍源码之前，我们还要先介绍两个概念：同步和异步

同步和异步
我们平时写的代码，基本都是同步的。但最近几年，异步编程大火。那同步和异步的区别到底是什么
呢？通俗点来讲就是调用方式是否需要等待结果，如果需要等待结果，就是同步；如果不需要等待结果，就是异步。

比如在下面的代码里，有一个计算圆周率小数点后100万位的方法牌m，这个方法可能需要
执行两礼拜，如果调用pait1
后，线程一直等着计算结果，等两立牌后结果返回，就可以执行printyg了，这个属于同步；如果调用pai之后
线程不用等待计算结果，立刻就可以执行printf这个就属于异步。

同步，是java代码默认的处理方式。如果你想让你的程序支持异步，可以通过下面两种方式来
实现：
  1.调用方创建一个子线程，在子线程中执行方法调用，这种调用我们称为异步调用；
  2.方法实现的时候，创建一个新的线程执行主要逻辑，主线程直接return，这种方法我们一般称为
  异步方法
  
dubbo源码分析
其实在编程领域，异步场景还是挺多的，比如tcp协议本身就是异步的，我们工作中经常用到
的rpc调用，在tcp协议层面，发送完RPC之后，线程是不会等待RPC的响应结果的。可能
你会觉得奇怪，平时工作中的rpc调用大多数都是同步的啊，
其实很简单，一定是有人帮你做了异步转同步的事情。例如目前RPC dubbo就给我们
做了异步转同步的事情，那它是怎么做的呢？下面我们就来分析下dubbo源码

对于下面一个简单RPC调用，默认情况下sayhello方法，是个同步方法，也即是说，执行
service。sayhello的时候，线程会停下来。
如果你将dump出来的话，会是下图这个样子，你会发现调用线程阻塞了，线程状态
是timed waiting .本来发送请求时异步的，但是调用线程阻塞了，说明dubbo帮我们
做了异步转同步的事情。通过调用栈，你能看到线程是阻塞在defualtFuture.get方法上，所以
我们可以推断：dubbo异步转同步的功能应该是通过defaultFuture这个类实现的。

不过为了理清前后关系，还是有必要分析下调用defualtFutureget之前发生了什么
 dubboInvolker的108行调用了DefaultFuture.get这一银行很关键，我们稍微修改了一下列在
 了下面。这一行先调用了request这个方法其实就是发送rpc请求，之后通过gety方法等待RPC返回结果。

DefaultFuture这个类是很关键，我把相关的代码精简之后，列到了下面。不过在看代码之前，
你还是由必要重复一下我们的需求：当RPC返回结果之前，阻塞调用线程，让调用线程等待；
当RPC返回结果后，唤醒调用线程，让调用线程重新执行。不知道你有没有似曾相识的感觉，
这不就是经典的等待-通知机制吗，这个时候想必你的脑海里应该能够浮现出管程的解决方法了。
有了自己的方案之后，我们再来看看dubbo是怎么实现的。

调用线程通过调用get方法等待RPC返回结果，这个方法里面，你看到的都是熟悉的面孔
：调用lock获取锁，在finally里面调用unlock释放锁，获取锁后，通过经典的再循环
中调用await方法来实现等待。

当rpc结果返回时，会调用do Received 方法，这个方法里面，调用lock获取锁，在
finally里面调用unlock释放锁，获取锁后通过调用signal来通知调用线程，结果已经返回
，不用继续等待了。

至此，dubbo里面的异步转同步的源码就分析完了，有没有觉得还挺简单的？最近这几年，工作
中需要异步处理的越来越多了，其中有一个主要原因就是有些API本事就是异步API 。例如
websocket也是一个异步的通信协议，如果基于这个协议实现一个简单的rpc你也会遇到
异步转同步的问题。现在很多公有云的API本身也是异步的，例如创建云主机，就是一个异步的
API，调用虽然成功了，但是云主机并没有创建成功，你需要调用另外一个api去轮训云主机的状态
。如果你需要在项目内部封装创建云主机的API，你也会面临异步转同步的问题，因为同步api更易用。

总结

lock condition 是管程的一种实现，所以能否用好lcok和condition 要看你对管程模型理解
得怎么样。管程技术前面我们已经专门用一篇文章做了介绍，你可以结合着来学，理论联系实践

lock confition实现的管程相对于synchronized实现的管程来说更加灵活、功能也更丰富。

结果我自己的经验，我认为了解原理比了解实现更能让你快速学好并发编程，所以没有介绍太多
javasdk并发包里锁和条件变量时如何实现的。但如果你对实现感兴趣，可以参考java并发
编程的艺术艺术中的第五章 java中的锁。里面详细介绍了实现原理，我觉得写得非常好。





16 Semaphore :如何快速实现一个限流器
PV 信号量 semaphore

Semaphore 现在普遍翻译为信号量，以前也曾被翻译成信号灯，因为类似现实生活里
的红绿灯，车辆能不能通行，要看是不是绿灯。同样在编程世界里，线程能不能执行，也要看
信号量是不是允许。

信号量是由大名鼎鼎的计算机科学家迪杰斯特拉DIJKSTRA于1965年提出，在这之后的15年
，信号量一直都是并发编程领域的终结者，知道1980年管程被提出来，我们才有了第二选
则。目前几乎所有支持并发编程的语言都支持信号量机制，所以学号信号量还是很有必要的。

下面我们首先介绍信号量模型，之后介绍如何使用信号量，最后我们再用信号量来实现一个限流器。

信号量模型还是很简单的，可以简单概况为：一个计数器、一个等待队列，三个方法（init、up、down）。在
信号量模型里，计数器和等待队列对外是透明的，所以只能通过信号量模型提供的三个方法来访问它
们，这三个方法分别是：init、down和up。你可以结

这三个方法详细的语义具体如下所示
init:设置计数器的初始值。
down:计数器的值减一；如果此时计数器的值小于0，则当前线程被阻塞，否则当前线程可以继续执行。
up：计数器的值加一；如果此时计数器的值小于或者等于0，则唤醒等待队列中的一个线程，并将其从等待队列中移除。

这里提到的init、down、up三个方法都是原子性的，并且这个原子性是由信号量模型的实现方保证的。
在javasdk里面，信号量是由模型javauitl.concurrent.Symaphore实现的
，Semaphore这个类能够保证这三个方法都是原子操作。

semaphore.acquire减一
semphore.release加一

这里再插一句，信号量模型里面，down up这两个操作历史上最早称为P操作和V操作，
所以信号量模型也被称为PV原语。另外，还有些人喜欢用semWait和semSignal来称呼他们
，虽然叫法不同，但是语义都是相同的。在javaSDK并发包里，down和up对应的则是
acquire和release()


如何使用信号量
通过上文，你应该发现信号量的模型还是很简单的，那具体该如何使用呢？其实你想想红绿灯
就可以了。十字路口的红绿灯可以控制交通，得益于他的一个关键规则：车辆在通过路口前必须
先检查是否是绿灯，只有绿灯才能通过。这个规则和我前面提到的锁规则是不是很类似。

其实，信号量使用的也是类似的。这里我们还是用累加器的例子来说明信号量的使用吧。在累加器
的利器里。count+1的操作是个临界区，值运行一个线程执行，也即是说保证互斥。那这种
情况用信号量怎么控制呢

其实很简单，就像我们用互斥锁一样，只需要在进入临界区之前执行一个down操作，推出临界
区之前执行一下up操作就可以了。下面是java代码的示例，acquire就是信号量里的down
操作，release就是信号量里的up操作o

下面我们再来分析一下，信号量是如何保证互斥的。假设两个线程T1和T2同事访问addone方法
，当它们同事调用acquire的时候，由于acquire是一个原子操作，所以只能由一个
线程把信号量里的计数器减为0，另外一个线程T2则是将计数器减为-1。对于线程
T1，信号量里面的计数器的值是0，大于等于0，所以线程T1会继续执行；对于线程T2，信号量
里面的计数器的值是-1，晓宇0，按照信号量模型里对down操作的描述，线程T2将被阻塞。
所以此时只有线程T1会进入临界区执行count+1
当线程T1执行release操作，也就是up操作的时候，信号量里计数器的值是-1，加1之后的值是0，
小于等于0，按照信号量模型里对up操作的描述，此时等待队列中的T2将会被唤醒。
于是T2在T1执行完临界区代码之后才获得了进入临界区执行的机会，从而保证了互斥性。


快速实现一个限流器
上面的例子，我们用信号量实现了一个最简单的互斥锁功能。估计你会觉得奇怪，既然有java
SDK里面提供的lcok，为啥还要提供一个Semaphore其实实现一个互斥锁，仅仅是
semaphore的部分功能，semaphore还有一个功能是lcok不容易实现的，那就是
semaphore可以允许多个线程访问一个临界区。

现实中还有这种需求？有的。比较常见的需求就是我们工作中遇到的各种池化资源，例如
连接池、对象池、线程池等等。其中，你可可能最熟悉数据库连接池，在同一时刻，一定是允许多个线程
同时使用连接池的，当然，每个连接在被释放前，是不允许其他线程使用的。

其实前不久，我在工作中也遇到了一个对象池的需求。所谓对象池呢，值得是一次性创建出N个对象
，之后所有线程重复利用这N个对象，当然对象在被释放前，也是不允许其他线程使用的。
对象池，可以用list保存示例对象，这个很简单。但管家你是限流器的设计，这里的限流，指
的是不允许多余N个线程同时进入临界区。那如何快读实现一个这样的限流器呢？这种场景，
我立刻就想到了信号量的解决方案。
  
  
  信号量的计数器，在上面的例子中，我们设置成了1，这个1表示只允许一个线程进入临界区，
但如果我们把计数器的值设置成对象池里对象的个数N，就能完美解决对象池的限流问题了。


我们用一个list来保持对象实例，用semaphore 实现限流器。关键的代码是objpool里面的
exec方法，这个方法里面实现了限流的功能。在这个方法里面，我们首先调用acquire方法
与之匹配的是在finally里面调用了release方法，假设对象池的大小是10，信号量的计数器
初始化为10，那么前10个线程调用aquire方法，都能继续支持，相当于通过了信号灯，
而其他线程则会阻塞在acquire方法上。对于通过信号灯的线程，我们为每个线程分配了一个
对象T这个分配工作时通过pool.remove实现的，分配完之后会执行一个回调函数hunc，
而函数的参数正是前面分配的对象t；执行完回调函数之后，他们就会释放对象 这个释放工作时通过pooladd实现的
同时调用release方法来更新信号量的计数器。如果此时
信号量里计数器的值小于等于0，那么说明有线程在等待，此时会自动唤醒等待的线程。

简言之，使用信号量，我们可以轻松实现一个限流器，使用起来还是非常简单的。

总结:

信号量在java语言里面名气并不算大，但是在其他语言里却是很有知名度的。java在并发编程
领域走的很快，重点支持的还是管程模型。管程模型理论上解决了信号量模型的一些不足，主要
提现在易用性和工程方面，例如用信号量解决我们曾经提到过的阻塞队列问题，就比管程模型
麻烦很多，你如果感兴趣，可以课下了解尝试一下。



















42|Actor模型：面向对象原生的并发模型
上学的时候，有门计算机专业课叫做面向对象编程，学这门课的时候有个问题困扰了我很久，
按照面相对象编程的理论，对象之间通信需要依靠消息，而实际上，像C++，java这些面向
对象的语言，对象之间通信，依靠的是对象方法。对象方法和过程语言里的函数本质上没有区别
，有入参，有出参，思维方式很相似，使用起来都很简单。那面向对象理论里的消息是否就
等价于面向对象语言里的对象方法呢？很长一段时间里，我都以为对象方法是面向对象理论中
消息的一种实现，直到接触到Actor模型，才明白消息压根不是这个实现法。

Hello Actor模型
Actor 模型本质上是一种计算模型，基本的计算单元称为actor，换言之，在actor模型中，
所有的计算都是在actor中执行的。在面向对象编程里面，一切都是对象；在actor模型
里，一切都是actor，并且actor之间是完全隔离的，不会共享任何变量。

当看到不共享任何变量的时候，相信你一定会眼前一亮，并发问题的根源就在于共享变量
，而actor模型中actor之间不共享变量，那用actor模型解决并发问题，一定是相当顺手
。的确是这样，所以很多人就吧actor模型定义为一种并发计算模型。其实actor模型早在
1973年就被提出来了，只是知道最近几年才被广泛关注，一个主要原因就在于它是解决并发
问题的利器，而最近几年随着多核处理器的发展，并发问题被退到了风口浪尖上。

但是java语言本身并不支持actor模型，所以如果你ixiang在java语言里使用actor模型，就
需要借助第三方类库，目前能完备地支持actor模型而且比较成熟的类库就是akka了。在详细
介绍actor模型之前，我们就先基于akka写一个helloworld程序，让你对actor模型
现有个感官的印象。

在下面的实例代码中，我们首先创建了一个actorsystem actor不能脱离actorsystem存在
；忠厚创了一个helloactor，akka中创建actor并不是new一个对象出来，而是通过
调用system。actofof方法创建的，该方法返回的是actorref，而不是helloactor最后
通过调用actorref的tell方法给helloactor发动了一条消息actor。



通过这个例子，你会发现actor模型和面相对象切合度非常高，完全可以用actor类比
面相对象变长里面的对象，而且actor之间的通信方式万美地遵循了消息机制，而不是通过对
像方法来实现对象之间通信。那actor中的消息机制和面相对象语言里的对象方法有什么区别呢


消息和对象方法的区别
在没有计算机的时代，异地的朋友往往是通过写信来交流感情的，但新建发出去之后，也许会在寄送过程
中弄丢了，也有可能寄到后，对方一直没有时间写回信，这个时候都可以让邮局
背个锅，不过无论如何，也不过是重写一封，生活继续。

actor中的消息机制，就可以类比这现实世界里的写信。actor内部有一个邮箱
mailbox，接收到的消息都是先放到邮箱里，如果邮箱里积压的消息，那么新收到的消息
就不会马上得到处理，也正是因为actor使用单线程处理消息，所以不会出现并发问题。你
可以把actor内部的工作模式想想成只有一个消费者线程的生产者-消费者模式。

所以，在actor模型里，发送消息仅仅是吧消息发出去而已，接收消息的actor在接收到消息
后，也不一定会立即处理，也就是说actor中的消息机制完全是异步的。而调用对象方法
，实际上是同步的，对象方法retruen之前，调用方会一直等待。

除此之外，调用对象方法，需要持有对象的引用，所有的对象必须在同一个进程中。而在
actor中发送消息，类似于现实中的写信，只需要知道对方的地址就可以，发送消息和接收消息
的actor可以不再一个进程中，也可以不再同一台机器上。因此，actor模型不但适用于并发
计算，还适用于分布式计算。

actor的规范化定义
通过上面的介绍，相信你应该已经对actor有一个感官印象了，下面我们再来看看actor规范
化的定义是什么样的。actor是一种基础的计算单元，具体来讲包括三部分能力，分别是
1.处理能力，处理接收到的消息。
2.存储能力，actor可以存储自己的内部状态，并且内部状态不同actor之间是绝对隔离的
3.通信能力，actor可以和其他actor之间通信。

当一个actor接收的一条消息之后，这个actor可以做以下三件事

1.创建更多的actor
2.发消息给其他actor
3.确定如何处理吓一跳消息。

其中前两天还是很好理解的，就是最后一条，改如何去理解呢前面我们说过actor具备存储能力
，它有自己的内部状态，所以你也可以吧actor看做一个状态机，把actor处理消息
看做是触发状态机的状态变化；而装填机的变化往往要基于上一个状态，触发状态机发生变化的
时刻，上一个状态必须是确定的，所以确定如何处理下一条消息，本质上不过是改变内部装填。


在多线程里面，由于可能存在竞态条件，所以根据当前状态确定如何处理下一套消息还是有难度
的，需要使用各种同步工具，但在actor模型里，由于单线程处理，所以就不存在静态条件了问题了
。

用actor实现累加器
支持并发的累加器可能是最简单并且有代表性的并发问题了，可以基于互斥锁方案实现，也可以
基于原子类实现，但今天我们要尝试用actor来实现。

在下面的示例代码中，counteractor内部持有累积值counter当counteractor接收到yg
数值型的消息message时，九江累计值counter+=message但如果是其他心里的消息
，则打印当前累计值counter。子啊main方法中，我们启动了四个线程来执行累加操作。
整个程序没有锁，也没有cas，但是程序是线程安全的。


总结
actor模型是一种非常简单的计算模型，其中actor是最及你吧的计算单元，actor之间是通过
消息进行通信。actor与面向对象变长oop中的对象匹配度非常高，在面向对象编程里，
系统由类似于生物细胞那样的对象构成，对象之间也是通过消息进行通信，所以在面向兑现该语言
里使用actor模型基本上不会有违和感。

在java领域，除了可以使用akka来支持actor模型外，还可以使用vertx，不过相对来说
vert.x更像是actor模型的隐式实现，对应关系不想akka钠盐更明显，不过本质上也是一种
actor模型

actor可以创建新的actor这些actor最终会成仙出一个树状结构，非常像想回时间里的组织结构
，所以利用actor模型来对程序进行建模，和显示世界的匹配度非常高。actor模型和
显示世界一样都是异步模型，理论上不保证消息百分之百宋丹，也不保证消息送达的顺序和发送
的顺序是一直的，甚至无法博阿正消息会被百分之百处理。虽然实现actor模型的厂商斗志视图解决
这个问题，但以涵的是解决得并不完美，所以使用actor模型也是有成本的。



43|软件事务内存：借鉴数据库的并发经验

很多同学反馈说，工作挺长时间但是没有机会接触并发编程，实际上我们天天都在写并发程序
，只不过并发相关的问题都被类似tomcat这样的web服务器以及mysql这样的数据库解决了。
尤其是数据库，在解决并发问题方面，可谓成绩斐然，它的事务机制非常简单易用，
能甩java里面的锁，原子类十条街。技术无边界，很显然要借鉴一下。

其实很多编程语言都有从数据库的事务管理中获得灵感，并且总结出了一个新的并发解决方案
：软件事务内存software transactional memory 简称 stm 。传统的数据库事务，
支持四个特性：原子性atomictiy 一致性 sonsistency 隔离性 isolation
和持久性 durability 也就是大家常说的acid，STM由于不涉及到持久化，所以只支持
ACI

STM的使用很简单，下面我们以经典的转账操作为例，看看 用stm改如何实现。

用STM实现转账
我们曾经在异步消息就死锁怎么办这篇文章中，降到了并发转账的例子，示例
代码如下。简单地使用synchronized将transfer方法变成同步方法并不能解决并发问题，
因为还存在死锁问题。

改转账操作若使用数据库事务就会非常简单，如下面的实例代码所示。如果所有sql都正常执行
，则通过commit方法提交事务；如果SQL在执行过程中有异常，则通过rollback
方法回滚事务。数据库保证在并发情况下不会死锁，而且还能保证前面我们说的原子性一致性隔离性和持久性，
也就是acid。


Connection conn=null

conn=DriverManager.getConnection();
conn.setAutoCommit(false);
conn.commit();
conn.rollback();

那如果用STM又该如何实现呢？java语言并不支持STM，不过可以借助第三方的类库来支持，
multiverse就是个不错的选择。下面实例代码就是借助multiverse实现了线程安全
的转账操作，相比较上面线程不安全的unaseaccount，其实改动并不大，仅仅是将余额的类
从long变成了txnlong，将转账操作放到了atomic中

一个关键的atomic方法就吧并发问题解决了，这个方案看上去比传统的方案的却简单了很多，
那他是如何实现的呢？数据库事务发展了几十年了，目前被广泛使用的是MVCC全称是
multi-version concurrency control  多版本并发控制。

MVCC可以简单地理解为数据库事务在开启的时候，会给数据库打一个快照，以后所有的读写
都是基于这个快照的。当提交事务的时候，如果所有读写过的数据在该事务执行期间没有发生过
变长，那么就可以提交；如果发生了变化，说明该事务和有其他事务读写的数据冲突了，这个
时候是不可以提交的。

为了记录数据是否发生了变化，可以给每条数据增加一个版本好，这样每次成功修改数据都会
增加版本好的值。mvcc的工作原理和我们曾经在stampedlock 有没有比读写锁更快的锁
中提到的乐观锁非常相似。有不少stm的实现方案都是基于MVCC的，例如志明的
clojure stm

下面我们就用最简答的代码基于mvcc实现一个简版的stm这样你会读istm以及mvcc的
工作原理有更深入的认识；。


自己实现STM
我们首先要做的，就是让java中的对象有版本号，在下面的实例代码中，versionedref这个
类的作用就是将对象value包装成带版本号的对象。按照mvcc理论，数据的每一次修改都
赌赢这一个唯一的版本号，所以不存在仅仅改变value或者version的情况，用不变性模式就
可以很好地解决这个问题，所有versionedref这个类被我们设计成了不可变的。

所有对数据的读写操作，一定是在一个事务里面，txnref这个类负责完成事务内的读写操作，
读写操作委托给了接口txn txn代表的是读写操作所在的当前事务，内部持有的
curref代表的是系统中的最新值。

STM软件事务内存 STMtxn是txn最关键的一个实现类，事务内对于数据的读写，都是通过它来完成的。
stmtxn内部有两个map intxnmap，用于报错当前事务中所有读写的数据的快照；
writemap，用于报错当前事务需要写入的数据。每个事务都有一个唯一的事务ID
txnid，这个txnid是全局递增的。

STMTxn有三个核心方法，分别是读数据的get方法，写数据的set方法和提交事务的commit
方法。其中get方法将要读取数据作为快照放入intxnmap同事保证每次读取
的数据都是一个版本。set方法会将要写入的数据放入writemap，但如果写入的数据没被读取
过，也会将其放入intxnmap。

至于commit方法，我们为了简化实现，使用了互斥锁，所以事务的提交是串行的。
commit方法的实现很简单，寿险检测intxnmap中的数据是否发生过变化，如果没有发生
变化，那么就将writemap中的数据写入，这里的写入其实就是txnref内部持有的curref
如果发生变化，那么就不能讲writemap的中的数据写入了。

下面我们来模拟实现multivese中的原子化操作 atomic atomic方法中使用了类似于
cas的操作，如果事务提交失败，那么就重新创建一个新的事务，重新执行。
就这样，我们自己实现了stm，并完成了线程安全的转账操作，使用方法和multiverse差不多
这里就不追谁了，具体带入

总结
STM借鉴的是数据库的经验，数据库虽然复杂，但仅仅存储数据，而编程语言除了有共享变量
之外，还会执行各种IO操作，很显然IO操作是很难支持回滚的。所以，STM也不是万能的。
目前支持STM的变成语言主要是函数式语言，函数式语言里的数据天生具备不可变性，
利用这种不可变性上线STM相对来说跟简单。

另外，需要说明的是稳重的自己实现STM部分我参考了 这篇稳重中  和一个gethub项目，目前还很粗糙，
并不是一个晚辈的MVCC。如果你感兴趣，降到了如何有哈。


44|协程:更轻量级的线程

Java语言里解决并发问题靠的是多线程，但线程是个重量级的对象，不能频繁创建、销毁，而且
线程切换的成本也很高，为了解决这些问题，javaSDK提供了线程池。然而用好线程池并不容易，
java围绕线程池提供了很多工具类，这些工具类学起来也不容易。那有没有更好的解决
方案呢？java语言里目前还没有，但是其他语言里有，这个方案就是协程 coroutine

我们可以把协程简单地理解为一种轻量级的线程。从操作系统的角度来看，线程是在内核态中
调度的，而协程是在用户态调度的，所以相对于线程来说，协程切换的成本更低。协程虽然也有
自己的栈，但是相比线程栈要小的多，典型的线程栈大小差不多有1M，而协程栈的大小往往
只有几K或者几十K。所以，无论是从时间维度还是空间维度来看，协程都比线程轻量得多

支持协程的语言还是挺多的，例如golang python lua kotlin 等都支持协程。下面我们就以
golang为代表，看看协程是如何子啊golang中使用的。


Golang中的协程
在golang中创建协程非常简单，在下面的实例代码中，要让hello方法在一个新的协程中
执行，只需要 go hello这一行代码就搞定了。你可以对比着想想在java里是如何
辛勤地创建线程和线程池吧，我的感觉一直都是每次写完golang的代码，就再也不想写java代码了。

我们再 最简单的分工方法，中介绍过，利用协程能够很好地
实现threadper message模式。thread per mesaage模式非常简单，其实越是
简单的模式，功能上就越文档，可理解性也越好。

下面的实例代码是用golang实现的echo程序的服务端，用的是thread per message 模式
，为每个成功建立连接的socket分配一个协程，相比java线程池的实现方案，golang中
协程的方案更简单。

利用协程实现同同步

其实协程并不仅限于实现threadper message模式,它还可以将一部模式转换为同步模式
。一部编程虽然近几年取得了长足发展，但是一部的思维模式对于普通人来讲毕竟是有难度的
，只有线性的思维模式才是适合所有人的。而线性的思维模式反应到变成世界，就是同步。

在java里使用多线程并发地处理IO 基本上用的都是异步非阻塞模型，这种模型的异步主要
是靠注册回调函数实现的，那能否都使用同步处理呢？显然是不能的。因为同步意味着等待
，而线程等待，本质上就是一种严重的浪费。不过对于协程来说，等待的成本就没有那么高了
，所以基于协程的实现同步非阻塞是一个可行的方案。

OpenResty里实现的cosocket就是一种同步非阻塞方案，借助cosocket我们可以用先行的
思维模式来编写非阻塞的程序。下面的实例代码使用cosocket实现的socket程序的客户端
建立连接发送氢气，读取响应所有的操作都是同步的，由于cosocket本身是非阻塞的
所以这些操作虽然是同步的，带并不会阻塞

结构化并发编程
golang 中的go语句让协程用起来太简单了，但是这种简单也蕴含着风险。要深入了解这个
风险是什么，就需要先了解一下沟通语句的前世今生。

在我上学的时候，各种各样的编程语言数据中都会谈到不建议使用goto语句，原因是沟通
语句会让程序变得混乱，当时对于这个问题我也没有独享哦啊ing，不建议用那就不用了。那为什么
goto语句会让程序变得混乱呢？混乱具体指的又是什么呢，多年之后，我才了解到所谓的混乱
指的是代码的抒写顺序和执行顺序不一致。那就会干扰我们对代码的理解。我们的思维是线性
的，傻傻滴一条道跑到黑，而goto语句太灵活，随时可以穿越时空，实在是太混乱了。

首先发现goto语句是毒药的人是著名的急死算计科学家，
同时太还提出了结构化程序设计。在结构化程序设计中，可以使用三种基本控制
结构来代替goto，这三种基本的控制结构就是今天我们广泛使用的顺序结构，选择结构和循环
结构。

这三种基本的控制结构奠定了今天高级语言的基础，如果仔细观察这三种结构，你会发现它们
的入口和出口只有一个，这意味着他们是可组合的，而且组合起来一定是线性的，整体来看，代码
的书写顺序和执行顺序也是一致的。

我们以前写的并发程序，是否违背了结构化程序设计呢？这个问题以前并没有被关注，但是最近
两年，随着并发变成的快速发展，已经开始有人关注了，而且剑指golang中的go语句，
指其为毒药，类比是goto语句。

golang中的go语句不过是快速创建协程的方法而已，这篇文章本质上不仅仅在批判
golang中的go语句，而是在批判开启新的线程或者协程异步执行这种粗糙的做法，违背了结构化
程序设计，java语言其实也在其列。

当开启一个新的线程时，程序会并行地出现两个分支，主线程一个分支，子线程一个分支，这两个
分支很多情况下都是天各一方，永不相见。而结构化的程序，可以有分支，但是最终过一定
要汇聚，不能有多个出口，因为只有这样他们组合起来才是线性的。

总结
最近几年支持协程的开发语言越来越多了，javaopensdk中loom项目的目标就是支持协程
，相信不久的将来，java程序员也可以使用协程来解决并发问题了。

计算机里很多面相开发人员的技术，大多数都是在解决一个问题：易用性。协程座位意向并发
编程技术，本质上也不过是解决并发工具的易用性问题而已。对于易用性，我觉得最重要的就是
要适应我们的思维模式，在工作的前几年，我们并没有怎么关注它，但是最近几年思维模式已
成为我重点关注的对象。因为思维欧式对工作的很多方案斗湖产生影响，例如质量。

一个软件产品是否能够活下去，从质量的角度看，最核心的就是代码写的好。那什么样的代码
是好代码呢？我觉得，最根本的是可读性好。可读性好的代码意味着大家都可以上手，而且
上手不会大动干戈。那如何让代码的可读性好呢 很简单，换位思考，用大众普通的思维
模式去写代码


45|CSP模型：golang的主力队员

golang是一门号称从语言层面支持并发的编程语言，支持并发是golang一个非常重要的特性。
在上一篇文章中我们介绍过，golang支持协程，协程可以类比
java中的线程，解决并发问题的难点就在于线程（协程）之间的协作。

那golang是如何解决协作问题的呢

总得来说，golang提供了两种不同的方案：一种方案支持协程之间以共享内存的方式通信
，golang提供了管程和原子类来对协程进行同步控制，这个方案支持协程之间以共享内存的方式通信
，golang提供了管程和原子类对协程进行同步控制，这个方案与java语言类似；另一种
方案支持协程之间以消息传递的方式通信，本质上是要避免共享，
golang的这个方案就是基于CSP communicating sequential processes 模型实现的
golang比较推荐的方案是后者。

什么是CSP 

我们在42 actor模型：面向对象原生的并发模型中介绍了actor模型，actor模型中
actor之间就是不能共享内存的，彼此之间通信只能依靠消息传递的方式。golang实现的
csp模型和actor模型看上去非常相似。golang程序员中邮局格言：不要以共享内存方式通信
，要以通信方式共享内存 dont communicate by sharing memory share memory
by communicating 虽然golang中协程之间，也能够以共享内存的方式通信，但是并不推荐
而推荐的以通信的方式共享内存，实际上值得就是协程之间以消息传递方式来通信。

下面我们先结合一个简单的示例，看看golang中协程之间是如何 以消息传递的方式实现通信
的。我们示例的目标是打印从1累加到100亿的结果，如果使用单个协程来计算，大概需要
4秒多的时间。单个协程，之恩给你用到CPU中的一个核，为了提高计算能力，我们可以用多个
协程来并行计算，这样就发挥多核的优势了。

在下面的实例代码中，我们用了四个子协程来并行执行，这四个子协程分别计算1，25亿
25 50 50 75  74到100，最后再在朱携程中汇总四个子协程的计算
结果。主协程要汇总四个子协程的计算结果，是比要和四个子协程之间通信，golang中协程
之间通信推荐的是使用channel，channel你可以形象地理解为实现世界里的管道。另外，
calc方法的返回值是一个只能接受数据的channel ch它创建的子协程会吧计算结果发送
到这个ch中，而主协程也会将这个计算结果通过ch读取出来。




CSP模型与生产者-消费者模式
你可以简单地吧golang实现的csp模型类比为生产者-消费者模式，而channel可以类比为
生产者-消费者中的阻塞队列。不过，需要注意的是golang中channel的容量可以是0
容量为0的channel在golang中被称为无缓冲的channel，容量大于0的则被称为有缓存的channel


无缓冲的channel类似于java中提供的synchronousqueue主要有用途是在两个协程之间
做数据交换。比如上面累加器的实例代码中，calca方法内部创建的channel就是无缓冲的
channel。


而创建一个有缓冲的channel也很简单，在下面的实例代码中我们创建了一个容量为4的channel
同时创建了四个协程做为生产者四个协程座位消费者。


golang中的channel是语言层面支持的，所以可以使用一个坐享箭头来完成向
channel发送数据和读取数据的任务，使用上还是比较简单的。golang中的channel是支持
双向传输的，所谓双向传输，指的是一个协程既可以通过她发送数据，也可以通过他接受数据。

不仅如此，golang中还可以将一个双向的channel变成一个单项的channel，在累加器的例子中，
calc方法中创建了一个双向的channel，但是返回的就是一个只能接受数据的单项channel，所以
主协程中只能通过它接受数据，而不能通过它发送数据，如果视图通过它发送数据
编译器会提示错误。对比之下，双向变单项的功能，如果以sdk方式实现，还是很困难的。

casp模型与actor模型的区别

童言格式以消息床底的方式来避免共享，那golang实现的csp模型和actor模型有什么区别呢
一个最明显的区别及时actor模型中没有channel虽然actor模型的mailbox和
channel非常像，看上去就像个fifo队列，但是区别还是很大的。actor模型中的mailbox对于
程序员来说是透明的，mailbox明确归属于一个特性的actor，是actor模型中的内部机制；
而且actor之间是可以直接通信的，不需要通信中介。但csp模型中的channel就不一样了
他对于程序员来说是课件的，是通信的中介，传递的消息都是直接发送到channel中的。

第二个区别是：actor模型中发送消息是非阻塞的，而csp模型中的阻塞的。golang实现的csp模型，
channel是一个阻塞队列，当阻塞队列已满的时候，向channel中发送数据，会导致发送消息的协程阻塞。

第三个区别则是关于消息送达的。在42actor模型面向对象原生的并发模型这篇文航中，
我们介绍过actor模型理论上是不保证消息百分之百送达，而在golang实现的CSP模型中
是能保证消息百分之百送达的。不过这种百分之百是有代价的，那就是有可能会导致死锁。

比如，下面这段点就存在死锁问题，在主协程中，我们创建了一个屋缓冲的channelch
然后从ch中接收数据，此时主协程苏塞，main方法中的主协程阻塞，整个应用就阻塞了。
这就是golang中最简单的一种死锁。

总结
golang中虽然也支持传统的共享内存的协程间通信方式，但是推荐的还是使用csp模型，以
通信的方式共享内存。

golang中实现的CSP模型功能上还是很丰富的，例如支持select语句，select语句类似于
网络编程里的多路复用函数select 只要一个channel能够发送成或者接受到数据就可以
跳出阻塞状态。鉴于篇幅原因，我就点到这里，不详细介绍那么多了。


CSP模型是托尼霍尔在1978年提出的不过这个模型这些年有izhi都在发展
，起理论远比golang的实现复杂得多，如果你感兴趣可以参考活儿写的数据。

另外活儿在并发领域还有一项重要成就，那就是提出霍尔管程模型，这个你应该很熟悉了，java领域解决
并发问题的理论基础就是它。

java领域可以结束第三方类库JCSP来支持CSP模型，喜爱那个笔golang的实现，jcsp更接近理论模型
，如果你感兴趣，可以下载学习，不过需要注意的是，jcsp并没有经过广泛的生产环境检验，
所以并不建议你在生产环境中使用。












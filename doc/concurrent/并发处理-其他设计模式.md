

42|Actor模型：面向对象原生的并发模型
上学的时候，有门计算机专业课叫做面向对象编程，学这门课的时候有个问题困扰了我很久，
按照面相对象编程的理论，对象之间通信需要依靠消息，而实际上，像C++，java这些面向
对象的语言，对象之间通信，依靠的是对象方法。对象方法和过程语言里的函数本质上没有区别
，有入参，有出参，思维方式很相似，使用起来都很简单。那面向对象理论里的消息是否就
等价于面向对象语言里的对象方法呢？很长一段时间里，我都以为对象方法是面向对象理论中
消息的一种实现，直到接触到Actor模型，才明白消息压根不是这个实现法。

Hello Actor模型
Actor 模型本质上是一种计算模型，基本的计算单元称为actor，换言之，在actor模型中，
所有的计算都是在actor中执行的。在面向对象编程里面，一切都是对象；在actor模型
里，一切都是actor，并且actor之间是完全隔离的，不会共享任何变量。

当看到不共享任何变量的时候，相信你一定会眼前一亮，并发问题的根源就在于共享变量
，而actor模型中actor之间不共享变量，那用actor模型解决并发问题，一定是相当顺手
。的确是这样，所以很多人就吧actor模型定义为一种并发计算模型。其实actor模型早在
1973年就被提出来了，只是知道最近几年才被广泛关注，一个主要原因就在于它是解决并发
问题的利器，而最近几年随着多核处理器的发展，并发问题被退到了风口浪尖上。

但是java语言本身并不支持actor模型，所以如果你ixiang在java语言里使用actor模型，就
需要借助第三方类库，目前能完备地支持actor模型而且比较成熟的类库就是akka了。在详细
介绍actor模型之前，我们就先基于akka写一个helloworld程序，让你对actor模型
现有个感官的印象。

在下面的实例代码中，我们首先创建了一个actorsystem actor不能脱离actorsystem存在
；忠厚创了一个helloactor，akka中创建actor并不是new一个对象出来，而是通过
调用system。actofof方法创建的，该方法返回的是actorref，而不是helloactor最后
通过调用actorref的tell方法给helloactor发动了一条消息actor。



通过这个例子，你会发现actor模型和面相对象切合度非常高，完全可以用actor类比
面相对象变长里面的对象，而且actor之间的通信方式万美地遵循了消息机制，而不是通过对
像方法来实现对象之间通信。那actor中的消息机制和面相对象语言里的对象方法有什么区别呢


消息和对象方法的区别
在没有计算机的时代，异地的朋友往往是通过写信来交流感情的，但新建发出去之后，也许会在寄送过程
中弄丢了，也有可能寄到后，对方一直没有时间写回信，这个时候都可以让邮局
背个锅，不过无论如何，也不过是重写一封，生活继续。

actor中的消息机制，就可以类比这现实世界里的写信。actor内部有一个邮箱
mailbox，接收到的消息都是先放到邮箱里，如果邮箱里积压的消息，那么新收到的消息
就不会马上得到处理，也正是因为actor使用单线程处理消息，所以不会出现并发问题。你
可以把actor内部的工作模式想想成只有一个消费者线程的生产者-消费者模式。

所以，在actor模型里，发送消息仅仅是吧消息发出去而已，接收消息的actor在接收到消息
后，也不一定会立即处理，也就是说actor中的消息机制完全是异步的。而调用对象方法
，实际上是同步的，对象方法retruen之前，调用方会一直等待。

除此之外，调用对象方法，需要持有对象的引用，所有的对象必须在同一个进程中。而在
actor中发送消息，类似于现实中的写信，只需要知道对方的地址就可以，发送消息和接收消息
的actor可以不再一个进程中，也可以不再同一台机器上。因此，actor模型不但适用于并发
计算，还适用于分布式计算。

actor的规范化定义
通过上面的介绍，相信你应该已经对actor有一个感官印象了，下面我们再来看看actor规范
化的定义是什么样的。actor是一种基础的计算单元，具体来讲包括三部分能力，分别是
1.处理能力，处理接收到的消息。
2.存储能力，actor可以存储自己的内部状态，并且内部状态不同actor之间是绝对隔离的
3.通信能力，actor可以和其他actor之间通信。

当一个actor接收的一条消息之后，这个actor可以做以下三件事

1.创建更多的actor
2.发消息给其他actor
3.确定如何处理吓一跳消息。

其中前两天还是很好理解的，就是最后一条，改如何去理解呢前面我们说过actor具备存储能力
，它有自己的内部状态，所以你也可以吧actor看做一个状态机，把actor处理消息
看做是触发状态机的状态变化；而装填机的变化往往要基于上一个状态，触发状态机发生变化的
时刻，上一个状态必须是确定的，所以确定如何处理下一条消息，本质上不过是改变内部装填。


在多线程里面，由于可能存在竞态条件，所以根据当前状态确定如何处理下一套消息还是有难度
的，需要使用各种同步工具，但在actor模型里，由于单线程处理，所以就不存在静态条件了问题了
。

用actor实现累加器
支持并发的累加器可能是最简单并且有代表性的并发问题了，可以基于互斥锁方案实现，也可以
基于原子类实现，但今天我们要尝试用actor来实现。

在下面的示例代码中，counteractor内部持有累积值counter当counteractor接收到yg
数值型的消息message时，九江累计值counter+=message但如果是其他心里的消息
，则打印当前累计值counter。子啊main方法中，我们启动了四个线程来执行累加操作。
整个程序没有锁，也没有cas，但是程序是线程安全的。


总结
actor模型是一种非常简单的计算模型，其中actor是最及你吧的计算单元，actor之间是通过
消息进行通信。actor与面向对象变长oop中的对象匹配度非常高，在面向对象编程里，
系统由类似于生物细胞那样的对象构成，对象之间也是通过消息进行通信，所以在面向兑现该语言
里使用actor模型基本上不会有违和感。

在java领域，除了可以使用akka来支持actor模型外，还可以使用vertx，不过相对来说
vert.x更像是actor模型的隐式实现，对应关系不想akka钠盐更明显，不过本质上也是一种
actor模型

actor可以创建新的actor这些actor最终会成仙出一个树状结构，非常像想回时间里的组织结构
，所以利用actor模型来对程序进行建模，和显示世界的匹配度非常高。actor模型和
显示世界一样都是异步模型，理论上不保证消息百分之百宋丹，也不保证消息送达的顺序和发送
的顺序是一直的，甚至无法博阿正消息会被百分之百处理。虽然实现actor模型的厂商斗志视图解决
这个问题，但以涵的是解决得并不完美，所以使用actor模型也是有成本的。

























